<?xml version="1.0" encoding="us-ascii"?>
<!-- $Id: dom-spec.xml,v 1.48 2004/02/27 22:16:06 plehegar Exp $ --><!DOCTYPE spec PUBLIC "-//W3C//DTD Specification V2.2-Based DOM//EN" "http://www.w3.org/2002/08/xmlspec-v22-dom.dtd">
<spec w3c-doctype="rec" role="public">
  <!--
  *************************************************************************
  * FRONT MATTER                                                          *
  *************************************************************************
  -->
<!-- 
  ****************************************************** 
  | filenames to be used for each section              |
  ******************************************************
-->
<?command-options --map Copyright-Notice copyright-notice
--map Introduction     introduction
--map TOC expanded-toc
--map Core core
--map Events events
--map idl idl-definitions
--map ecma-binding ecma-script-binding
--map java-binding java-binding
--map Index def-index
--map Objects object-index
--map References references
--map Errors errors
--map Level-3-AS abstract-schemas
--map Load-Save load-save
--map XPath xpath
--map KeySet keyset
?>

<?command-options --map -IndexFile-      def-index
--map -OjbectIndexFile-      object-index
--strip-references
--strip-glossary
?>

<?command-options --map-type ECMAScript void void
--map-type ECMAScript "unsigned short" Number
--map-type ECMAScript "unsigned int" Number
--map-type ECMAScript "unsigned long" Number
--map-type ECMAScript short Number
--map-type ECMAScript long Number
--map-type ECMAScript float Number
--map-type ECMAScript double Number
--map-type ECMAScript boolean Boolean
--map-type ECMAScript Object Object
--map-type ECMAScript DOMString String
--map-type ECMAScript DOMTimeStamp Date
--map-type ECMAScript DOMObject Object
--map-type ECMAScript DOMUserData "any type"
--map-type ECMAScript LSInputStream Object
--map-type ECMAScript LSOutputStream Object
--map-type ECMAScript LSReader "this is an error and shouldn't be used."
--map-type ECMAScript LSWriter "this is an error and shouldn't be used."
--map-type ECMAScript DOMSystemException Object

--map-type Java void void
--map-type Java Object Object
--map-type Java DOMString String
--map-type Java "unsigned short" short
--map-type Java "unsigned int" int
--map-type Java "unsigned long" int
--map-type Java long int
--map-type Java short short
--map-type Java float float
--map-type Java double double
--map-type Java boolean boolean
--map-type Java DOMTimeStamp long
--map-type Java DOMObject Object
--map-type Java DOMUserData Object
--map-type Java LSInputStream java.io.InputStream
--map-type Java LSOutputStream java.io.OutputStream
--map-type Java LSReader java.io.Reader
--map-type Java LSWriter java.io.Writer
--map-type Java DOMSystemException Exception
?>

<header> 
<title>Document Object Model (DOM) Level 3 Core Specification</title>
<version>1.0</version> <w3c-designation>REC-DOM-Level-3-Core-20040407
</w3c-designation> <w3c-doctype>W3C Recommendation</w3c-doctype> <pubdate> 
<day>07</day> <month>April</month> <year>2004</year> 
</pubdate> 
    <publoc>
      <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407</loc>
    </publoc>
    <altlocs>
      <loc xmlns:xlink="http://www.w3.org/1999/xlink" role="html" href="http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/xml-source.xml" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">XML file</loc>
      <loc xmlns:xlink="http://www.w3.org/1999/xlink" role="plain" href="http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/DOM3-Core.txt" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">plain text</loc>
      <loc xmlns:xlink="http://www.w3.org/1999/xlink" role="postscript" href="http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/DOM3-Core.ps" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">PostScript file</loc>
      <loc xmlns:xlink="http://www.w3.org/1999/xlink" role="pdf" href="http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/DOM3-Core.pdf" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">PDF file</loc>
      <loc xmlns:xlink="http://www.w3.org/1999/xlink" role="html" href="http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/DOM3-Core.html" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">single HTML file</loc>
      <loc xmlns:xlink="http://www.w3.org/1999/xlink" role="zip" href="http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/DOM3-Core.zip" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">ZIP file</loc>
    </altlocs>
    <latestloc>
      <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/DOM-Level-3-Core" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/DOM-Level-3-Core</loc>
    </latestloc>
    <prevlocs>
      <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/2004/PR-DOM-Level-3-Core-20040205/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/2004/PR-DOM-Level-3-Core-20040205/</loc>
    </prevlocs> 
    <authlist> 
    <author role="editor">
      <name>Arnaud Le Hors</name>
      <affiliation>IBM</affiliation>
    </author>
      <author role="editor">
	<name>Philippe Le H&#233;garet</name> 
	<affiliation>W3C</affiliation>
      </author> 
    <author role="editor">
      <name>Lauren Wood</name>
      <affiliation>SoftQuad, Inc. (WG Chair emerita, for DOM Level 1 and 2)</affiliation>
    </author>
    <author role="editor">
      <name>Gavin Nicol</name>
      <affiliation>Inso EPS (for DOM Level 1)</affiliation>
    </author>
      <author role="editor">
	<name>Jonathan Robie</name>
	<affiliation>Texcel Research and Software AG (for DOM Level 1
	  and 2)</affiliation>
      </author>
    <author role="editor">
      <name>Mike Champion</name>
      <affiliation>Arbortext and Software AG (for DOM Level 1 and 2)</affiliation>
    </author>
    <author role="editor">
      <name>Steve Byrne</name>
      <affiliation>JavaSoft (for DOM Level 1 until November 19,
        1997)</affiliation>
    </author>
</authlist>
    <!--
    ******************************************************
    * DOCUMENT ABSTRACT                                  *
    ******************************************************
    -->
    <abstract id="id-abstract"> 

      <p>
	This specification defines the Document Object Model Core Level
	3, a platform- and language-neutral interface that allows
	programs and scripts to dynamically access and update the
	content, structure and style of documents.  The Document Object
	Model Core Level 3 builds on the Document Object Model Core
	Level 2 <bibref role="informative" ref="DOM2Core"/>.
      </p>
      <p>
	This version enhances DOM Level 2 Core by completing the mapping
	between DOM and the XML Information Set <bibref ref="InfoSet"/>,
	including the support for XML Base <bibref ref="XMLBase"/>,
	adding the ability to attach user information to DOM Nodes or to
	bootstrap a DOM implementation, providing mechanisms to resolve
	namespace prefixes or to manipulate "ID" attributes, giving to type
	information, etc.
      </p>

    </abstract>

    <status id="Level-3-status">
      <p>
	<emph>This section describes the status of this document at the
	time of its publication. Other documents may supersede this
	document. A list of current W3C publications and the latest
	revision of this technical report can be found in the <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">W3C technical reports index</loc>
	at http://www.w3.org/TR/.</emph>
      </p>
      <p>
	This document contains the Document Object Model Level 3 Core
	specification and is a <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/2004/02/Process-20040205/tr.html#RecsW3C" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">W3C
	Recommendation</loc>. It has been produced as part of the <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/DOM/Activity.html" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">W3C DOM
	Activity</loc>. The authors of this document are the <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/DOM/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">DOM Working Group</loc>
	participants. For more information about DOM, readers can also
	refer to <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/DOM/faq.html" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">DOM
	FAQ</loc> and <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/DOM/Test/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">DOM
	Conformance Test Suites</loc>.
      </p>
      <p>
	It is based on the feedback received during the <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/2004/02/19-dom-level-3-issues/issues.html" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Proposed
	Recommendation</loc> period. <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/2004/03/DOM-Level-3-Core-changes.html" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Changes
	since the Proposed Recommendation version</loc> and an <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/2003/10/DOM-Level-3-Core-implementations.html" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">implementation
	report</loc> are available. Please refer to the <loc xmlns:xlink="http://www.w3.org/1999/xlink" role="errata" href="http://www.w3.org/2004/01/DOM-Level-3-errata" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">errata</loc> for this
	document, which may include some normative corrections.

      </p>
      <p>
	Comments on this document should be sent to the public mailing
	list <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="mailto:www-dom@w3.org" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">www-dom@w3.org</loc> (<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://lists.w3.org/Archives/Public/www-dom/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">public archive</loc>).
      </p>
      <p>
	This is a stable document and has been endorsed by the W3C
	Membership and the participants of the DOM working group. The
	English version of this specification is the only normative
	version. See also <loc xmlns:xlink="http://www.w3.org/1999/xlink" role="translation" href="http://www.w3.org/2004/01/DOM-Level-3-translations" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">translations</loc>.
      </p>
      <p>
	Patent disclosures relevant to this specification may be found
	on the Working Group's <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/2002/08/02-DOM-Disclosures.html" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">patent
	disclosure page</loc>. This document has been produced under the
	<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/2002/NOTE-patent-practice-20020124" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">24
	January 2002 CPP</loc> as amended by the <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/2004/02/05-pp-transition" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">W3C Patent
	Policy Transition Procedure</loc>. An individual who has actual
	knowledge of a patent which the individual believes contains
	Essential Claim(s) with respect to this specification should
	disclose the information in accordance with <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/Consortium/Patent-Policy-20040205/#sec-Disclosure" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">section
	6 of the W3C Patent Policy</loc>.
      </p>
    </status>

<sourcedesc>
<p>Created in electronic form.</p>
</sourcedesc>
<langusage>
<language id="en">English</language>
</langusage>
<revisiondesc>
<p>$Revision: 1.48 $</p>
</revisiondesc>
<?GENERATE-TOC?>
</header>
<front>
  
<!-- $Id: toc.xml,v 1.1 2000/01/13 18:55:20 lwood Rel $ -->
<div1 id="TOC">
  <head>Expanded Table of Contents</head>
  <?GENERATE-EXPANDED-TOC?>	
</div1>

  
<!-- $Id: copyright.xml,v 1.11 2004/02/04 11:41:36 plehegar Exp $ -->
<!--
 *************************************************************************
 * BEGINNING OF COPYRIGHT NOTICE                                         *
 *************************************************************************
-->
<div1 id="Copyright-Notice">
  <head>W3C Copyright Notices and Licenses</head>

  <p role="important">
    Copyright &#169; 2004 <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">World
    Wide Web Consortium</loc>, (<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.csail.mit.edu/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Massachusetts Institute of
    Technology</loc>, <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.ercim.org/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">European
    Research Consortium for Informatics and Mathematics</loc>, <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.keio.ac.jp/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Keio University</loc>). All Rights
    Reserved.
  </p>
  <p>
    This document is published under the <specref ref="Copyright-notice-document"/>. The bindings within this document
    are published under the <specref ref="Copyright-notice-software"/>.
    The software license requires "Notice of any changes or
    modifications to the W3C files, including the date changes were
    made." Consequently, modified versions of the DOM bindings must
    document that they do not conform to the W3C standard; in the case
    of the IDL definitions, the pragma prefix can no longer be
    'w3c.org'; in the case of the Java language binding, the package
    names can no longer be in the 'org.w3c' package.
  </p>
  <div2 id="Copyright-notice-document">
    <head>W3C<sup>&#174;</sup> Document Copyright Notice and License</head>
    <note>
      <p>
	This section is a copy of the W3C<sup>&#174;</sup> Document
	Notice and License and could be found at <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/Consortium/Legal/2002/copyright-documents-20021231" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/Consortium/Legal/2002/copyright-documents-20021231</loc>.
      </p>
    </note>
    <p role="important">
      Copyright &#169; 2004 <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">World Wide Web Consortium</loc>, (<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.lcs.mit.edu/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Massachusetts Institute of
      Technology</loc>, <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.ercim.org/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">European
      Research Consortium for Informatics and Mathematics</loc>, <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.keio.ac.jp/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Keio University</loc>). All Rights
      Reserved.
    </p>
    <p role="important">      
      http://www.w3.org/Consortium/Legal/2002/copyright-documents-20021231
    </p>
    <p>
      Public documents on the W3C site are provided by the copyright
      holders under the following license. By using and/or copying this
      document, or the W3C document from which this statement is linked,
      you (the licensee) agree that you have read, understood, and will
      comply with the following terms and conditions:
    </p>
    <p>
      Permission to copy, and distribute the contents of this document,
      or the W3C document from which this statement is linked, in any
      medium for any purpose and without fee or royalty is hereby
      granted, provided that you include the following on
      <emph>ALL</emph> copies of the document, or portions thereof, that
      you use:
    </p>
    <olist>
      <item>
	<p>
	  A link or URL to the original W3C document.
	</p>
      </item>
      <item>
	<p>
	  The pre-existing copyright notice of the original author, or
	  if it doesn't exist, a notice (hypertext is preferred, but a
	  textual representation is permitted) of the form:
	  "Copyright &#169; [$date-of-document] <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">World Wide Web Consortium</loc>,
	  (<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.lcs.mit.edu/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Massachusetts Institute
	  of Technology</loc>, <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.ercim.org/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">European Research Consortium for
	  Informatics and Mathematics</loc>, <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.keio.ac.jp/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Keio University</loc>). All
	  Rights Reserved.  <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/Consortium/Legal/2002/copyright-documents-20021231" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/Consortium/Legal/2002/copyright-documents-20021231</loc>"
	</p>
      </item>
      <item>
	<p>
	  <emph>If it exists</emph>, the STATUS of the W3C document.
	</p>
      </item>
    </olist>
    <p>
      When space permits, inclusion of the full text of this <emph role="important">NOTICE</emph> should be provided. We request that
      authorship attribution be provided in any software, documents, or other
      items or products that you create pursuant to the implementation of the
      contents of this document, or any portion thereof.
    </p>
    <p>
      No right to create modifications or derivatives of W3C documents is
      granted pursuant to this license. However, if additional requirements
      (documented in the <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/Consortium/Legal/IPR-FAQ" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Copyright
      FAQ</loc>) are satisfied, the right to create modifications or
      derivatives is sometimes granted by the W3C to individuals complying with
      those requirements.
    </p>
    <p>
      THIS DOCUMENT IS PROVIDED "AS IS," AND COPYRIGHT HOLDERS MAKE
      NO REPRESENTATIONS OR WARRANTIES, EXPRESS OR IMPLIED, INCLUDING, BUT NOT
      LIMITED TO, WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
      PURPOSE, NON-INFRINGEMENT, OR TITLE; THAT THE CONTENTS OF THE DOCUMENT
      ARE SUITABLE FOR ANY PURPOSE; NOR THAT THE IMPLEMENTATION OF SUCH
      CONTENTS WILL NOT INFRINGE ANY THIRD PARTY PATENTS, COPYRIGHTS,
      TRADEMARKS OR OTHER RIGHTS.
    </p>
    <p>
      COPYRIGHT HOLDERS WILL NOT BE LIABLE FOR ANY DIRECT, INDIRECT, SPECIAL OR
      CONSEQUENTIAL DAMAGES ARISING OUT OF ANY USE OF THE DOCUMENT OR THE
      PERFORMANCE OR IMPLEMENTATION OF THE CONTENTS THEREOF.
    </p>
    <p>
      The name and trademarks of copyright holders may NOT be used in
      advertising or publicity pertaining to this document or its contents
      without specific, written prior permission. Title to copyright in this
      document will at all times remain with copyright holders.
    </p>
  </div2>
  <div2 id="Copyright-notice-software">
    <head>W3C<sup>&#174;</sup> Software Copyright Notice and License</head>
    <note>
      <p>
	This section is a copy of the W3C<sup>&#174;</sup> Software
	Copyright Notice and License and could be found at <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/Consortium/Legal/2002/copyright-software-20021231" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/Consortium/Legal/2002/copyright-software-20021231</loc>
      </p>
    </note>
    <p role="important">
      Copyright &#169; 2004 <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">World Wide Web Consortium</loc>, (<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.lcs.mit.edu/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Massachusetts Institute of
      Technology</loc>, <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.ercim.org/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">European
      Research Consortium for Informatics and Mathematics</loc>, <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.keio.ac.jp/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Keio University</loc>). All Rights
      Reserved.
    </p>
    <p role="important">      
      http://www.w3.org/Consortium/Legal/2002/copyright-software-20021231
    </p>
    <p>
      This work (and included software, documentation such as READMEs,
      or other related items) is being provided by the copyright holders
      under the following license. By obtaining, using and/or copying
      this work, you (the licensee) agree that you have read,
      understood, and will comply with the following terms and
      conditions.
    </p>
    <p>
      Permission to copy, modify, and distribute this software and its
      documentation, with or without modification, for any purpose and
      without fee or royalty is hereby granted, provided that you
      include the following on ALL copies of the software and
      documentation or portions thereof, including modifications:
    </p>
    <olist>
      <item>
	<p>The full text of this NOTICE in a location viewable to users of the
	redistributed or derivative work.</p>
      </item>
      <item>
	<p>
	  Any pre-existing intellectual property disclaimers, notices,
	  or terms and conditions. If none exist, the <specref ref="Copyright-short-notice"/> should be included (hypertext
	  is preferred, text is permitted) within the body of any
	  redistributed or derivative code.
	</p>
      </item>
      <item>
	<p>
	  Notice of any changes or modifications to the files, including
	  the date changes were made. (We recommend you provide URIs to
	  the location from which the code is derived.)
	</p>
      </item>
    </olist>
    <p>
      THIS SOFTWARE AND DOCUMENTATION IS PROVIDED "AS IS," AND COPYRIGHT
      HOLDERS MAKE NO REPRESENTATIONS OR WARRANTIES, EXPRESS OR IMPLIED,
      INCLUDING BUT NOT LIMITED TO, WARRANTIES OF MERCHANTABILITY OR FITNESS
      FOR ANY PARTICULAR PURPOSE OR THAT THE USE OF THE SOFTWARE OR
      DOCUMENTATION WILL NOT INFRINGE ANY THIRD PARTY PATENTS, COPYRIGHTS,
      TRADEMARKS OR OTHER RIGHTS.
    </p>
    <p>
      COPYRIGHT HOLDERS WILL NOT BE LIABLE FOR ANY DIRECT, INDIRECT, SPECIAL OR
      CONSEQUENTIAL DAMAGES ARISING OUT OF ANY USE OF THE SOFTWARE OR
      DOCUMENTATION.
    </p>
    <p>
      The name and trademarks of copyright holders may NOT be used in
      advertising or publicity pertaining to the software without specific,
      written prior permission. Title to copyright in this software and any
      associated documentation will at all times remain with copyright holders.
    </p>
  </div2>
  <div2 id="Copyright-short-notice">
    <head>W3C<sup>&#174;</sup> Short Software Notice</head>

    <note>
      <p>
	This section is a copy of the W3C<sup>&#174;</sup> Short Software
	Notice and could be found at <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/Consortium/Legal/2002/copyright-software-short-notice-20021231" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/Consortium/Legal/2002/copyright-software-short-notice-20021231</loc>
      </p>
    </note>
    <p role="important">
      Copyright &#169; 2004 <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">World
      Wide Web Consortium</loc>, (<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.lcs.mit.edu/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Massachusetts Institute of
      Technology</loc>, <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.ercim.org/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">European
      Research Consortium for Informatics and Mathematics</loc>, <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.keio.ac.jp/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Keio University</loc>). All Rights
      Reserved.
    </p>
    <p>
      Copyright &#169; [$date-of-software] <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">World Wide Web Consortium</loc>, (<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.lcs.mit.edu/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Massachusetts Institute of
      Technology</loc>, <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.ercim.org/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">European
      Research Consortium for Informatics and Mathematics</loc>, <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.keio.ac.jp/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Keio University</loc>). All Rights
      Reserved. This work is distributed under the W3C<sup>&#174;</sup>
      Software License [1] in the hope that it will be useful, but
      WITHOUT ANY WARRANTY; without even the implied warranty of
      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    </p>
    <p>
      [1] http://www.w3.org/Consortium/Legal/2002/copyright-software-20021231
    </p>
  </div2>
</div1>
<!--
 *************************************************************************
 * END OF COPYRIGHT NOTICE                                               *
 *************************************************************************
-->

  
<!-- $Id: introduction.xml,v 1.21 2004/01/12 19:29:11 plehegar Exp $ -->
<!--
 *************************************************************************
 * BEGINNING OF DOM INTRODUCTION                                         * 
 *************************************************************************
-->
<div1 id="Introduction">
  <head>What is the Document Object Model?</head>

  <orglist role="editors">
    <member>
      <name>Philippe Le H&#233;garet</name>
      <affiliation>W3C</affiliation>
    </member>
    <member>
      <name>Lauren Wood</name>
      <affiliation>SoftQuad Software Inc. (for DOM Level 2)</affiliation>
    </member>
    <member>
      <name>Jonathan Robie</name>
      <affiliation>Texcel (for DOM Level 1)</affiliation>
    </member>
  </orglist>

  <div2 id="ID-E7C3082">
    <head>Introduction</head>
    <p>The Document Object Model (DOM) is an application programming interface 
      (<termref def="dt-API">API</termref>) for valid <termref def="dt-HTML">HTML</termref> and
      well-formed <termref def="dt-XML">XML</termref> documents. It defines the logical structure of documents and
      the way a document is accessed and manipulated. In the DOM specification,
      the term "document" is used in the broad sense - increasingly, XML is being used as a
      way of representing many different kinds of information that may
      be stored in diverse systems, and much of this would traditionally
      be seen as data rather than as documents. Nevertheless, XML presents
      this data as documents, and the DOM may be used to manage this data.</p>

    <p>With the Document
      Object Model, programmers can build documents, navigate
      their structure, and add, modify, or delete elements and content.
      Anything found in an HTML or XML document can be accessed,
      changed, deleted, or added using the Document Object Model,
      with a few exceptions - in particular, the DOM <termref def="dt-interface">interfaces</termref> for
      the XML internal and external subsets have not yet been specified.</p>
    <p>As a W3C specification, one important objective for the Document
      Object Model is to provide a standard programming interface that
      can be used in a wide variety of environments and <termref def="dt-application">applications</termref>.
      The DOM is designed to be used with any programming
      language. In order to provide a precise, language-independent
      specification of the DOM interfaces, we have chosen to define
      the specifications in Object Management Group (OMG) IDL <bibref role="normative" ref="OMGIDL"/>, as defined in the CORBA 2.3.1 specification <bibref role="informative" ref="CORBA"/>. In addition to the OMG IDL specification, we provide
      <termref def="dt-lang-binding">language bindings</termref> for Java <bibref role="normative" ref="Java"/> and ECMAScript <bibref role="normative" ref="ECMAScript"/> (an industry-standard scripting
      language based on JavaScript <bibref role="informative" ref="JavaScript"/> and JScript
      <bibref role="informative" ref="JScript"/>). Because of language
      binding restrictions, a mapping has to be applied between the OMG
      IDL and the programming language in used. For example, while the
      DOM uses IDL attributes in the definition of interfaces, Java does
    not allow interfaces to contain attributes:</p>

    <eg role="code" xml:space="preserve">// example 1: removing the first child of an element using ECMAScript
mySecondTrElement.removeChild(mySecondTrElement.firstChild);

// example 2: removing the first child of an element using Java
mySecondTrElement.removeChild(mySecondTrElement.getFirstChild());</eg>
    <note><p>OMG IDL is used only as a language-independent and
	implementation-neutral way to specify <termref def="dt-interface">interfaces</termref>. Various other
	IDLs could have been used (<bibref role="informative" ref="COM"/>, <bibref role="informative" ref="JavaIDL"/>, <bibref role="informative" ref="MSIDL"/>, ...). In general, IDLs 
	are designed for specific computing environments. The Document Object
	Model can be implemented in any computing environment, and does not 
	require the object binding runtimes generally associated with 
	such IDLs.
      </p></note>

  </div2>
  <div2 id="ID-E7C30821">
    <head>What the Document Object Model is</head>
    <p>The DOM is a programming <termref def="dt-API">API</termref> for documents.
      It is based on an object structure that closely resembles the structure of the
      documents it <termref def="dt-model">models</termref>. For instance, consider this table, taken
      from an XHTML document: </p>
    <eg role="code" xml:space="preserve">&lt;table&gt;
  &lt;tbody&gt; 
    &lt;tr&gt; 
      &lt;td&gt;Shady Grove&lt;/td&gt;
      &lt;td&gt;Aeolian&lt;/td&gt; 
    &lt;/tr&gt; 
    &lt;tr&gt;
      &lt;td&gt;Over the River, Charlie&lt;/td&gt;        
      &lt;td&gt;Dorian&lt;/td&gt; 
    &lt;/tr&gt; 
  &lt;/tbody&gt;
&lt;/table&gt;</eg> 
    <p>
      A graphical representation of the DOM of the example table, with
      whitespaces in element content (often abusively called "ignorable
      whitespace") removed, is:      
    </p>
    <graphic xmlns:xlink="http://www.w3.org/1999/xlink" source="./images/table.png" alt="graphical representation of the DOM of the example table" xlink:type="simple" xlink:show="embed" xlink:actuate="onLoad"/>
    <p>
      An example of DOM manipulation using ECMAScript would be:
    </p>
<eg role="code" xml:space="preserve">// access the tbody element from the table element
var myTbodyElement = myTableElement.firstChild;

// access its second tr element
// The list of children starts at 0 (and not 1).
var mySecondTrElement = myTbodyElement.childNodes[1];

// remove its first td element
mySecondTrElement.removeChild(mySecondTrElement.firstChild);

// change the text content of the remaining td element
mySecondTrElement.firstChild.firstChild.data = "Peter";</eg>
    <p>In the DOM, documents have a logical
      structure which is very much like a tree; to be more precise, which is
      like a "forest" or "grove",
      which can contain more than one tree. Each document contains zero or one
      doctype nodes, one document element node,
      and zero or more comments 
		or processing instructions; the document element serves as the root
		of the element tree for the document. However, the DOM
      does not specify that documents must be <emph>implemented</emph> as a
      tree or a grove<!--but not the same as an sgml grove-->, nor
      does it specify how the relationships among objects be
      implemented. The DOM is a logical model that may be implemented in any
      convenient manner. In this
      specification, we use the term <emph>structure model</emph> to
      describe the tree-like representation of a document.
      We also use the term "tree" when referring to the arrangement of 
      those information items which can be reached by using "tree-walking" 
      methods; (this does not include attributes).
      One important property of DOM structure models
      is <emph>structural isomorphism</emph>: if any two Document
      Object Model implementations are used to create a representation
      of the same document, they will create the same structure model,
      in accordance with the XML Information Set <bibref role="informative" ref="InfoSet"/>.</p>
    <note><p>There may be some variations depending on the parser being
	used to build the DOM. For instance, the DOM may not contain
	white spaces in element content if the parser discards them.</p>
    </note>
      <p>The name "Document Object Model" was chosen because
      it is an "<termref def="dt-object-model">object model</termref>" in the traditional
      object oriented design sense: documents are modeled using
      objects, and the model encompasses not only the structure of a
      document, but also the behavior of a document and the objects
      of which it is composed. In other words, the nodes in the
      above diagram do not represent a data structure, they
      represent objects, which have functions and identity. As an
      object model, the DOM identifies:</p>
    <ulist>
      <item><p>the interfaces and objects used to represent and manipulate
	  a document</p></item>
      <item><p>the semantics of these interfaces and objects - including
	  both behavior and attributes</p></item>
      <item><p>the relationships and collaborations among these interfaces
	  and objects</p></item>
    </ulist>
    
    <p>The structure of SGML documents has traditionally been
      represented by an abstract <termref def="dt-datamodel">data model</termref>, not by an object model.
      In an abstract <termref def="dt-datamodel">data model</termref>, the model is centered around the
      data. In object oriented programming languages, the data itself
      is encapsulated in objects that hide the data, protecting it
      from direct external manipulation. The functions associated with
      these objects determine how the objects may be manipulated, and
      they are part of the object model.</p>

  </div2>
  <div2 id="ID-E7C30822">
    <head>What the Document Object Model is not</head>
    <p>This section is designed to give a more precise understanding
      of the DOM by distinguishing it from other
      systems that may seem to be like it.</p>
    <ulist>
      <item><p>The Document Object Model is not a binary specification.
	  DOM programs written in the same language binding will be
	  source code compatible across platforms, but the DOM
	  does not define any form of binary interoperability.</p></item>
      <item><p>The Document Object Model is not a way of persisting objects
	  to XML or HTML. Instead of specifying how objects may be
	  represented in XML, the DOM specifies how
	  XML and HTML documents are represented as objects, so that
	  they may be used in object oriented programs.</p></item>
      <item><p>The Document Object Model is not a set of data structures;
	  it is an <termref def="dt-object-model">object model</termref> that specifies interfaces. Although this
	  document contains diagrams showing parent/child relationships,
	  these are logical relationships defined by the programming
	  interfaces, not representations of any particular internal
	  data structures.</p></item>

      <item><p>The Document Object Model does not define what information in a
	  document is relevant or how information in a document is structured. For
	  XML, this is specified by the XML Information Set <bibref role="informative" ref="InfoSet"/>. The DOM is simply an <termref def="dt-API">API</termref> to this information set. <!-- @@SEEME
	  --></p></item>

      <item><p>The Document Object Model, despite its name, is not a
	  competitor to the Component Object Model <bibref role="informative" ref="COM"/>. COM, like
	  CORBA, is a language independent way to specify interfaces and
	  objects; the DOM is a set of interfaces and
	  objects designed for managing HTML and XML documents. The DOM
	  may be implemented using language-independent systems like COM
	  or CORBA; it may also be implemented using language-specific
	  bindings like the Java or ECMAScript bindings specified in
	  this document.</p></item>
    </ulist>
  </div2>
  <div2 id="ID-E7C30823">
    <head>Where the Document Object Model came from</head>
    <p>The DOM originated as a specification to
      allow JavaScript scripts and Java programs to be portable among
      Web browsers.  "Dynamic HTML" was  the immediate ancestor of the
      Document Object Model, and it was originally thought of largely
      in terms of  browsers. However, when the DOM
      Working Group was formed at W3C, it was also joined by vendors in other
      domains, including HTML or XML editors and document
      repositories. Several of these vendors had worked with SGML
      before XML was developed; as a result, the DOM
      has been influenced by SGML Groves and the HyTime standard. Some
      of these vendors had also developed their own object models for
      documents in order to provide an API for SGML/XML
      editors or document repositories, and these object models have
      also influenced the DOM.</p>
  </div2>
  

  <div2 id="ID-E7C30824"><head>Entities and the DOM Core</head>
    <p>In the fundamental DOM interfaces, there are no objects representing
      entities. Numeric character references, and references to the
      pre-defined entities in HTML and XML, are replaced by the
      single character that makes up the entity's replacement.
      For example, in:   
    </p>
      <eg role="code" xml:space="preserve">
        &lt;p&gt;This is a dog &amp;amp; a cat&lt;/p&gt;        
      </eg>
    <p>
      the "&amp;amp;" will be replaced by the character "&amp;", and the text
      in the P element will form a single continuous sequence of
      characters. Since numeric character references and pre-defined entities
      are not recognized as such in CDATA sections, or in the SCRIPT and STYLE
      elements in HTML, they are not replaced by the single character they
      appear to refer to. If the example above were enclosed in a CDATA
      section, the "&amp;amp;" would not be replaced by "&amp;"; neither would
      the &lt;p&gt; be recognized as a start tag. The representation of general
      entities, both internal and external, are defined within the
      extended (XML) interfaces of <specref ref="Core"/>.</p>
    <p>
      Note: When a DOM representation of a document is serialized
      as XML or HTML text, applications will need to check each
      character in text data to see if it needs to be escaped
      using a numeric or pre-defined entity. Failing to do so
      could result in invalid HTML or XML. Also, <termref def="dt-implementation">implementations</termref> should be
      aware of the fact that serialization into a character encoding
      ("charset") that does not fully cover ISO 10646 may fail if there are
      characters in markup or CDATA sections that are not present in the
      encoding.</p>
  </div2>

  <div2 id="DOMArchitecture">
    <head>DOM Architecture</head>
    <p>
      The DOM specifications provide a set of APIs that forms the DOM
      API. Each DOM specification defines one or more modules and each
      module is associated with one feature name. For example, the DOM
      Core specification (this specification) defines two modules:
    </p>
    <ulist>
      <item>
	<p>The Core module, which contains the fundamental interfaces
	  that must be implemented by all DOM conformant
	  implementations, is associated with the feature name "Core";</p>
      </item>
      <item>
	<p>
	  The XML module, which contains the interfaces that must be
	  implemented by all conformant XML 1.0 <bibref ref="XML" role="informative"/> (and higher) DOM implementations, is
	  associated with the feature name "XML".
	</p>
      </item>
    </ulist>
    <p>
      The following representation contains all DOM modules, represented
      using their feature names, defined along the DOM specifications:
    </p>
    <graphic xmlns:xlink="http://www.w3.org/1999/xlink" source="./images/dom-architecture.png" alt="A view of the DOM Architecture" xlink:type="simple" xlink:show="embed" xlink:actuate="onLoad"/>
    <p>
      A DOM implementation can then implement one (i.e. only the Core
      module) or more modules depending on the host application. A Web
      user agent is very likely to implement the "MouseEvents" module,
      while a server-side application will have no use of this module
      and will probably not implement it.
    </p>
  </div2>

  <div2 id="ID-Conformance">
    <head>Conformance</head>
    <p>
      This section explains the different levels of conformance to DOM Level 3.
      DOM Level 3 consists of 16 modules. It is possible to conform to DOM
      Level 3, or to a DOM Level 3 module.
    </p>

    <p>
      An implementation is DOM Level 3 conformant if it supports the Core
      module defined in this document (see <specref ref="ID-BBACDC08"/>). An
      implementation conforms to a DOM Level 3 module if it supports all the
      interfaces for that module and the associated semantics.
    </p>
    <p>
      Here is the complete list of DOM Level 3.0 modules and the features used
      by them.  Feature names are case-insensitive.
    </p>

    <glist>
      <gitem>
	<label>Core module</label>
	<def>
	  <p>
	    defines the feature <xspecref xmlns:xlink="http://www.w3.org/1999/xlink" href="core.html#ID-BBACDC08" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">"Core"</xspecref>.
	  </p>
	</def>
      </gitem>
      <gitem>
	<label>XML module</label>
	<def>
	  <p>
	    Defines the feature <xspecref xmlns:xlink="http://www.w3.org/1999/xlink" href="core.html#ID-E067D597" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">"XML"</xspecref>.
	  </p>
	</def>
      </gitem>
      <gitem>
	<label>Events module</label>
	<def>
	  <p>defines the feature <xspecref xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/DOM-Level-3-Events/events.html" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">"Events"</xspecref> in <bibref role="informative" ref="DOMEvents"/>.</p>
	</def>
      </gitem>
      <gitem>
	<label>User interface Events module</label>
	<def>
	  <p>defines the feature <xspecref xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/DOM-Level-3-Events/events.html" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">"UIEvents"</xspecref> in
	  <bibref role="informative" ref="DOMEvents"/>.</p>
	</def>
      </gitem>
      <gitem>
	<label>Mouse Events module</label>
	<def>
	  <p>defines the feature <xspecref xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/DOM-Level-3-Events/events.html" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">"MouseEvents"</xspecref> in
	  <bibref role="informative" ref="DOMEvents"/>.</p>
	</def>
      </gitem>
      <gitem>
	<label>Text Events module</label>
	<def>
	  <p>defines the feature <xspecref xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/DOM-Level-3-Events/events.html" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">"TextEvents"</xspecref> in
	  <bibref role="informative" ref="DOMEvents"/>.</p>
	</def>
      </gitem>
      <gitem>
	<label>Keyboard Events module</label>
	<def>
	  <p>defines the feature <xspecref xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/DOM-Level-3-Events/events.html" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">"KeyboardEvents"</xspecref> in
	  <bibref role="informative" ref="DOMEvents"/>.</p>
	</def>
      </gitem>
      <gitem>
	<label>Mutation Events module</label>
	<def>
	  <p>defines the feature <xspecref xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/DOM-Level-3-Events/events.html" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">"MutationEvents"</xspecref> in
	  <bibref role="informative" ref="DOMEvents"/>.</p>
	</def>
      </gitem>
      <gitem>
	<label>Mutation name Events module</label>
	<def>
	  <p>defines the feature <xspecref xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/DOM-Level-3-Events/events.html" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">"MutationNameEvents"</xspecref> in
	  <bibref role="informative" ref="DOMEvents"/>.</p>
	</def>
      </gitem>
      <gitem>
	<label>HTML Events module</label>
	<def>
	  <p>defines the feature <xspecref xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/DOM-Level-3-Events/events.html" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">"HTMLEvents"</xspecref> in
	  <bibref role="informative" ref="DOMEvents"/>.</p>
	</def>
      </gitem>
      <gitem>
	<label>Load and Save module</label>
	<def>
	  <p>defines the feature <xspecref xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/DOM-Level-3-LS/load-save.html" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">"LS"</xspecref> in <bibref role="informative" ref="DOMLS"/>.</p>
	</def>
      </gitem>
      <gitem>
	<label>Asynchronous load module</label>
	<def>
	  <p>defines the feature <xspecref xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/DOM-Level-3-LS/load-save.html" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">"LS-Async"</xspecref>
	  in <bibref role="informative" ref="DOMLS"/>.</p>
	</def>
      </gitem>
      <gitem>
	<label>Validation module</label>
	<def>
	  <p>defines the feature <xspecref xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/DOM-Level-3-Val/validation.html" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">"Validation"</xspecref>
	  in <bibref role="informative" ref="DOMVal"/>.</p>
	</def>
      </gitem>
      <gitem>
	<label>XPath module</label>
	<def>
	  <p>defines the feature <xspecref xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/DOM-Level-3-XPath/xpath.html" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">"XPath"</xspecref> in
	   <bibref role="informative" ref="DOMXPath"/>.</p>
	</def>
      </gitem>
    </glist>
    
    <p>
      A DOM implementation must not return <code>true</code> to the
      <code>DOMImplementation.hasFeature(feature, version)</code> <termref def="dt-method">method</termref> of the <code>DOMImplementation</code>
      interface for that feature unless the implementation conforms to that
      module. The <code>version</code> number for all features used in DOM
      Level 3.0 is <code>"3.0"</code>.
    </p>
  </div2>

  <div2 id="ID-E7C30826"><head>DOM Interfaces and DOM Implementations</head>

    <p>The DOM specifies interfaces which may be used to manage XML or
      HTML documents. It is important to realize that these interfaces
      are an abstraction - much like "abstract base classes" in C++,
      they are a means of specifying a way to access and manipulate an
      application's internal representation of a document. Interfaces 
	do not imply a particular concrete
      implementation. Each DOM application is free to maintain
      documents in any convenient representation, as long as the
      interfaces shown in this specification are supported. Some
      DOM implementations will be existing programs that use the
      DOM interfaces to access software written long before the
      DOM specification existed. Therefore, the DOM is designed
      to avoid implementation dependencies; in particular,</p>
    <olist>
      <item><p>Attributes defined in the IDL do not imply concrete
	  objects which must have specific data members - in the
	  language bindings, they are translated to a pair of
	  get()/set() functions, not to a data member. Read-only
	  attributes have only a get() function in the language
	  bindings.  </p>
      </item>
      <item><p>DOM applications may provide additional interfaces
	  and objects not found in this specification and still be
	  considered DOM conformant.</p></item>
      <item><p>Because we specify interfaces and not the actual
	  objects that are to be created, the DOM cannot know what
	  constructors to call for an implementation.  In general,
	  DOM users call the createX() methods on the Document
	  class to create document structures, and DOM
	  implementations create their own internal representations
	  of these structures in their implementations of the
	  createX() functions.
	</p></item>
    </olist>
    <p>
      The Level 2 interfaces were extended to provide both Level 2 and Level 3
      functionality.
    </p>
    <p>
      DOM implementations in languages other than Java or ECMAScript may choose
      bindings that are appropriate and natural for their language and run time
      environment.  For example, some systems may need to create a Document3
      class which inherits from a Document class and contains the new methods
      and attributes.
    </p>
    <p>DOM Level 3 does not specify multithreading mechanisms.</p>
  </div2>
</div1>
<!--
  *************************************************************************
  * END OF DOM INTRODUCTION                                               *
  *************************************************************************
-->


</front> 
 
<body>
  
<!-- $Id: core.xml,v 1.90 2004/03/15 20:01:16 plehegar Exp $ -->
<!--
 *************************************************************************
 * BEGINNING OF CORE                                                     *
 *************************************************************************
-->
<div1 id="Core">
  <head>Document Object Model Core</head>
  <orglist role="editors">
    <member>
      <name>Arnaud Le Hors</name>
      <affiliation>IBM</affiliation>
    </member>
    <member>
      <name>Philippe Le H&#233;garet</name>
      <affiliation>W3C</affiliation>
    </member>
    <member>
      <name>Gavin Nicol</name>
      <affiliation>Inso EPS (for DOM Level 1)</affiliation>
    </member>
    <member>
      <name>Lauren Wood</name>
      <affiliation>SoftQuad, Inc. (for DOM Level 1)</affiliation>
    </member>
    <member>
      <name>Mike Champion</name>
      <affiliation>Arbortext and Software AG (for DOM Level 1 from November 20,
        1997)</affiliation>
    </member>
    <member>
      <name>Steve Byrne</name>
      <affiliation>JavaSoft (for DOM Level 1 until November 19,
        1997)</affiliation>
    </member>
  </orglist>
  <?GENERATE-MINI-TOC?>

  <p>
    This specification defines a set of objects and interfaces for
    accessing and manipulating document objects. The functionality
    specified (the <emph>Core</emph> functionality) is sufficient to
    allow software developers and Web script authors to access and
    manipulate parsed HTML <bibref role="informative" ref="HTML40"/> and
    XML <bibref role="informative" ref="XML"/> content inside conforming
    products. The DOM Core <termref def="dt-API">API</termref> also
    allows creation and population of a <code>Document</code> object
    using only DOM API calls. A solution for loading a
    <code>Document</code> and saving it persistently is proposed in
    <bibref role="informative" ref="DOMLS"/>.
  </p>

  <!--
  ******************************************************
  | INTRODUCTION                                       |
  ******************************************************
  -->
  <div2 id="ID-1590626201">
    <head>Overview of the DOM Core Interfaces</head>

    <div3 id="ID-1590626202"><head>The DOM Structure Model</head>	
      <p>The DOM presents documents as a hierarchy of <code>Node</code> objects
        that also implement other, more specialized interfaces. Some types of
        nodes may have <termref def="dt-child">child</termref> nodes of various
        types, and others are leaf nodes that cannot have anything below them
        in the document structure. For XML and HTML, the node types, and which
        node types they may have as children, are as follows:
        <ulist>	
          <item>
            <p><code>Document</code> -- <code>Element</code> (maximum of one),
              <code>ProcessingInstruction</code>, <code>Comment</code>,
              <code>DocumentType</code> (maximum of one) </p>
          </item>	
          <item>
            <p><code>DocumentFragment</code> -- <code>Element</code>,
              <code>ProcessingInstruction</code>, <code>Comment</code>,
              <code>Text</code>, <code>CDATASection</code>,
              <code>EntityReference</code> </p>
          </item>	
          <item>
            <p><code>DocumentType</code> -- no children</p>
          </item>	
          <item>
            <p><code>EntityReference</code> -- <code>Element</code>,
              <code>ProcessingInstruction</code>, <code>Comment</code>,
              <code>Text</code>, <code>CDATASection</code>,
              <code>EntityReference</code> </p>
          </item>	
          <item>
            <p><code>Element</code> -- <code>Element</code>, <code>Text</code>,
              <code>Comment</code>, <code>ProcessingInstruction</code>,
              <code>CDATASection</code>, <code>EntityReference</code></p>
          </item>	
          <item>
            <p><code>Attr</code> -- <code>Text</code>,
              <code>EntityReference</code></p>
          </item>	
          <item>
            <p><code>ProcessingInstruction</code> -- no children</p>
          </item>	
          <item>
            <p><code>Comment</code> -- no children</p>
          </item>	
          <item>
            <p><code>Text</code> -- no children</p>
          </item>	
          <item>
            <p><code>CDATASection</code> -- no children</p>
          </item>	
          <item>
            <p><code>Entity</code> -- <code>Element</code>,
              <code>ProcessingInstruction</code>, <code>Comment</code>,
              <code>Text</code>, <code>CDATASection</code>,
              <code>EntityReference</code></p>
          </item>	
          <item>
            <p><code>Notation</code> -- no children</p>
          </item>	
        </ulist> </p>
      <p>The DOM also specifies a <code>NodeList</code> interface to handle
        ordered lists of <code>Nodes</code>, such as the children of a
        <code>Node</code>, or the <termref def="dt-element">elements</termref>
        returned by the
	<code>Element.getElementsByTagNameNS(namespaceURI, localName)</code> method, and also a <code>NamedNodeMap</code>
        interface to handle unordered sets of nodes referenced by their name
        attribute, such as the attributes of an <code>Element</code>.
        <termdef id="td-live" term="live"> <code>NodeList</code> and
          <code>NamedNodeMap</code> objects in the DOM are <term>live</term>;
          that is, changes to the underlying document structure are reflected
          in all relevant <code>NodeList</code> and <code>NamedNodeMap</code>
          objects. For example, if a DOM user gets a <code>NodeList</code>
          object containing the children of an <code>Element</code>, then
          subsequently adds more children to that
          <termref def="dt-element">element</termref> (or removes children, or
          modifies them), those changes are automatically reflected in the
          <code>NodeList</code>, without further action on the user's
          part. Likewise, changes to a <code>Node</code> in the tree are
          reflected in all references to that <code>Node</code> in
          <code>NodeList</code> and <code>NamedNodeMap</code>
          objects.</termdef></p> <p>Finally, the interfaces <code>Text</code>,
        <code>Comment</code>, and <code>CDATASection</code> all inherit from
        the <code>CharacterData</code> interface.</p>
    </div3>
    <div3 id="ID-249F15BA"><head>Memory Management</head>
      <p>Most of the APIs defined by this specification are
        <emph>interfaces</emph> rather than classes. That means that an
        implementation need only expose methods with the defined names and
        specified operation, not implement classes that correspond directly to
        the interfaces. This allows the DOM APIs to be implemented as a thin
        veneer on top of legacy applications with their own data structures, or
        on top of newer applications with different class hierarchies. This
        also means that ordinary constructors (in the Java or C++ sense) cannot
        be used to create DOM objects, since the underlying objects to be
        constructed may have little relationship to the DOM interfaces. The
        conventional solution to this in object-oriented design is to define
        <emph>factory</emph> methods that create instances of objects that
        implement the various interfaces. Objects implementing some interface
        "X" are created by a "createX()" method on the <code>Document</code>
        interface; this is because all DOM objects live in the context of a
        specific Document.</p>
      <p>The Core DOM APIs are designed to be compatible with a wide range of
        languages, including both general-user scripting languages and the more
        challenging languages used mostly by professional programmers. Thus,
        the DOM APIs need to operate across a variety of memory management
        philosophies, from language bindings that do not expose memory
        management to the user at all, through those (notably Java) that
        provide explicit constructors but provide an automatic garbage
        collection mechanism to automatically reclaim unused memory, to those
        (especially C/C++) that generally require the programmer to explicitly
        allocate object memory, track where it is used, and explicitly free it
        for re-use. To ensure a consistent API across these platforms, the DOM
        does not address memory management issues at all, but instead leaves
        these for the implementation. Neither of the explicit language bindings
        defined by the DOM API (for
        <termref def="dt-ECMAScript">ECMAScript</termref> and Java) require any
        memory management methods, but DOM bindings for other languages
        (especially C or C++) may require such support. These extensions will
        be the responsibility of those adapting the DOM API to a specific
        language, not the DOM Working Group.</p>
    </div3>
    <div3 id="ID-45A944CB">
      <head>Naming Conventions</head>
      <p>While it would be nice to have attribute and method names that are
        short, informative, internally consistent, and familiar to users of
        similar APIs, the names also should not clash with the names in legacy
        APIs supported by DOM implementations. Furthermore, both OMG IDL  <bibref role="informative" ref="OMGIDL"/> and ECMAScript <bibref role="informative" ref="ECMAScript"/> have significant limitations in their ability
        to disambiguate names from different namespaces that make it difficult
        to avoid naming conflicts with short, familiar names. So, DOM names
        tend to be long and descriptive in order to be unique across all
        environments.</p>
      <p>The Working Group has also attempted to be internally consistent in
        its use of various terms, even though these may not be common
        distinctions in other APIs. For example, the DOM API uses the method
        name "remove" when the method changes the structural model, and the
        method name "delete" when the method gets rid of something inside the
        structure model. The thing that is deleted is not returned. The thing
        that is removed may be returned, when it makes sense to return it.</p>
    </div3>
    <div3 id="ID-1CED5498">
      <head>Inheritance vs. Flattened Views of the API</head>
      <p>The DOM Core <termref def="dt-API">APIs</termref> present two somewhat
        different sets of interfaces to an XML/HTML document: one presenting an
        "object oriented" approach with a hierarchy of
        <termref def="dt-inheritance">inheritance</termref>, and a "simplified"
        view that allows all manipulation to be done via the <code>Node</code>
        interface without requiring casts (in Java and other C-like languages)
        or query interface calls in <termref def="dt-COM">COM</termref>
        environments. These operations are fairly expensive in Java and COM,
        and the DOM may be used in performance-critical environments, so we
        allow significant functionality using just the <code>Node</code>
        interface. Because many other users will find the
        <termref def="dt-inheritance">inheritance</termref> hierarchy easier to
        understand than the "everything is a <code>Node</code>" approach to the
        DOM, we also support the full higher-level interfaces for those who
        prefer a more object-oriented <termref def="dt-API">API</termref>. </p>
      <p>In practice, this means that there is a certain amount of redundancy
        in the <termref def="dt-API">API</termref>. The Working Group considers
        the "<termref def="dt-inheritance">inheritance</termref>" approach the
        primary view of the API, and the full set of functionality on
        <code>Node</code> to be "extra" functionality that users may employ,
        but that does not eliminate the need for methods on other interfaces
        that an object-oriented analysis would dictate. (Of course, when the
        O-O analysis yields an attribute or method that is identical to one on
        the <code>Node</code> interface, we don't specify a completely
        redundant one.) Thus, even though there is a generic
        <code>Node.nodeName</code> attribute on the <code>Node</code> interface,
        there is still a <code>Element.tagName</code> attribute on the
        <code>Element</code> interface; these two attributes must contain the
        same value, but the it is worthwhile to support both, given the
        different constituencies the DOM <termref def="dt-API">API</termref>
        must satisfy.</p>
    </div3>
  </div2>
  <div2 id="BasicTypes">
    <head>Basic Types</head>

    <p>
      To ensure interoperability, this specification specifies the following
      basic types used in various DOM modules. Even though the DOM
      uses the basic types in the interfaces, bindings may use
      different types and normative bindings are only given for Java and
      ECMAScript in this specification.
    </p>

    <div3 id="ID-C74D1578">
      <head>The <code>DOMString</code> Type</head>

      <p>
	The <code>DOMString</code> type is used to store <bibref ref="Unicode"/> characters as a sequence of <termref def="dt-16-bit-unit">16-bit units</termref> using UTF-16 as
	defined in <bibref ref="Unicode"/> and Amendment 1 of <bibref ref="ISO10646"/>.
      </p>
      <p>
	Characters are <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/2004/REC-xml11-20040204/#dt-fullnorm" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">fully
	normalized</loc> as defined in appendix B of <bibref ref="XML11"/> if:
      </p>
      <ulist>
	<item>
	  <p>
	    the parameter "<termref def="parameter-normalize-characters">normalize-characters</termref>"
	    was set to <code>true</code> while loading the document or
	    the document was certified as defined in <bibref ref="XML11"/>;
	  </p>
	</item>
	<item>
	  <p>
	    the parameter "<termref def="parameter-normalize-characters">normalize-characters</termref>"
	    was set to <code>true</code> while using the method
	    <code>Document.normalizeDocument()</code>, or while using
	    the method <code>Node.normalize()</code>;
	  </p>
	</item>
      </ulist>
      <p>
	Note that, with the exceptions of
	<code>Document.normalizeDocument()</code> and
	<code>Node.normalize()</code>, manipulating characters using DOM
	methods does not guarantee to preserve a
	<term>fully-normalized</term> text.
      </p>
      <definitions>
	<typedef name="DOMString" id="DOMString">
	  <descr>
	    <p>A <code>DOMString</code> is a sequence of
	      <termref def="dt-16-bit-unit">16-bit units</termref>.</p>
	  </descr>
	  <sequence type="unsigned short"/>
	</typedef>
      </definitions>	
      <p><!--empty paragraph--></p>
      <p>The UTF-16 encoding was chosen because of its widespread industry
      practice. Note that for both HTML and XML, the document character set
      (and therefore the notation of numeric character references) is based on
      UCS <bibref ref="ISO10646"/>. A single numeric character reference in a
      source document may therefore in some cases correspond to two 16-bit
      units in a <code>DOMString</code> (a high surrogate and a low
	surrogate). For issues related to string comparisons, refer to
	<specref ref="ID-5DFED1F0"/>.</p>
      <p>
	For Java and ECMAScript, <code>DOMString</code> is bound to the
	<code>String</code> type because both languages also use UTF-16
	as their encoding.
      </p>
      <note>
        <p>As of August 2000, the OMG IDL specification
          (<bibref ref="OMGIDL"/>) included a <code>wstring</code>
            type. However, that definition did not meet the interoperability
            criteria of the DOM <termref def="dt-API">API</termref> since it
            relied on negotiation to decide the width and encoding of a
            character.</p>
      </note>
    </div3>
    <div3 id="Core-DOMTimeStamp">
      <head>The <code>DOMTimeStamp</code> Type</head>
      
      <p>
	The <code>DOMTimeStamp</code> type is used to store an absolute
	or relative time.
      </p>	
      <definitions>
	<typedef name="DOMTimeStamp" id="DOMTimeStamp">
	  <descr>
	    <p>A <code>DOMTimeStamp</code> represents a number of
	      milliseconds.</p>
	  </descr>
	  <typename>unsigned long long</typename>
	</typedef>
      </definitions>	 
      <p>
	For Java, <code>DOMTimeStamp</code> is bound to the
	<code>long</code> type. For ECMAScript, <code>DOMTimeStamp</code>
	is bound to the <code>Date</code> type because the range of the
	<code>integer</code> type is too small.
      </p>
    </div3>
    <div3 id="Core-DOMUserData">
      <head>The <code>DOMUserData</code> Type</head>
      <p>
	The <code>DOMUserData</code> type is used to store
	application data.
      </p>
      <definitions>
	<typedef name="DOMUserData" id="DOMUserData">
	  <descr>
	    <p>A <code>DOMUserData</code> represents a reference to
              application data.</p>
	  </descr>
	  <typename>any</typename>
	</typedef>
      </definitions>
      <p>
	For Java, <code>DOMUserData</code> is bound to the
	<code>Object</code> type. For ECMAScript,
	<code>DOMUserData</code> is bound to <code>any type</code>.
      </p>
    </div3>
    <div3 id="Core-DOMObject">
      <head>The <code>DOMObject</code> Type</head>
      <p>
	The <code>DOMObject</code> type is used to represent an
	  object.
      </p>
      <definitions>
	<typedef name="DOMObject" id="DOMObject">
	  <descr>
	    <p>A <code>DOMObject</code> represents an object reference.</p>
	  </descr>
	  <typename>Object</typename>
	</typedef>
      </definitions>
      <p>
	For Java and ECMAScript, <code>DOMObject</code> is bound to the
	<code>Object</code> type.
      </p>
    </div3>
  </div2>
  <div2 id="Consideration">
    <head>General Considerations</head>

    <div3 id="ID-5DFED1F0">
      <head>String Comparisons in the DOM</head>

      <p>The DOM has many interfaces that imply string matching. For
        XML, string comparisons are case-sensitive and performed with a
        binary <termref def="dt-string-compare">comparison</termref> of
        the <termref def="dt-16-bit-unit">16-bit units</termref> of the
        <code>DOMStrings</code>. However, for case-insensitive markup
        languages, such as HTML 4.01 or earlier, these comparisons are
        case-insensitive where appropriate.</p>

      <p>Note that HTML processors often perform specific case
        normalizations (canonicalization) of the markup before the DOM
        structures are built. This is typically using uppercase for
        <termref def="dt-element">element</termref> names and lowercase
        for attribute names. For this reason, applications should also
        compare element and attribute names returned by the DOM
        implementation in a case-insensitive manner.</p>

      <p>
	The character normalization, i.e. transforming into their <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/2004/REC-xml11-20040204/#dt-fullnorm" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">fully normalized</loc> form as
	as defined in <bibref ref="XML11"/>, is assumed to happen at
	serialization time. The DOM Level 3 Load and Save module <bibref role="informative" ref="DOMLS"/> provides a serialization
	mechanism (see the <code>DOMSerializer</code> interface, section
	2.3.1) and uses the <code>DOMConfiguration</code> parameters
	"<termref def="parameter-normalize-characters">normalize-characters</termref>"
	and "<termref def="parameter-check-character-normalization">check-character-normalization</termref>"
	to assure that text is <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/2004/REC-xml11-20040204/#dt-fullnorm" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">fully normalized</loc> <bibref ref="XML11"/>. Other serialization mechanisms built on top of
	the DOM Level 3 Core also have to assure that text is
	<term>fully normalized</term>.
      </p>

<!--
      <note>	
        <p>Besides case folding, there are additional normalizations that can
          be applied to text. The W3C I18N Working Group is in the process of
          defining exactly which normalizations are necessary, and where they
          should be applied. The W3C I18N Working Group expects to require
          early normalization, which means that data read into the DOM is
          assumed to already be normalized. The DOM and applications built on
          top of it in this case only have to assure that text remains
          normalized when being changed. For further details, please see
          <bibref ref="Charmod"/>.</p>
      </note>
-->
    </div3>

    <div3 id="domURIs">
      <head>DOM URIs</head>

      <p>
	The DOM specification relies on <code>DOMString</code> values as
	resource identifiers, such that the following conditions are
	met:
      </p>
      <olist>
	<item>
	  <p>
	    An absolute identifier absolutely identifies a resource on
	    the Web;
	  </p>
	</item>
	<item>
	  <p>
	    Simple string equality establishes equality of absolute
	    resource identifiers, and no other equivalence of resource
	    identifiers is considered significant to the DOM
	    specification;
	  </p>
	</item>
	<item>
	  <p>
	    A relative identifier is easily detected and made absolute
	    relative to an absolute identifier;
	  </p>
	</item>
	<item>
	  <p>
	    Retrieval of content of a resource may be accomplished where
	    required.
	  </p>
	</item>
      </olist>

      <p>
	The term "<term>absolute URI</term>" refers to a complete
	resource identifier and the term "<term>relative URI</term>"
	refers to an incomplete resource identifier.
      </p>
      <p>
	Within the DOM specifications, these identifiers are called
	URIs, "Uniform Resource Identifiers", but this is meant
	abstractly. The DOM implementation does not necessarily process
	its URIs according to the URI specification <bibref role="informative" ref="URIRef"/>.  Generally the particular
	form of these identifiers must be ignored.
      </p>
      <p>
	When is not possible to completely ignore the type of a DOM URI,
	either because a relative identifier must be made absolute or
	because content must be retrieved, the DOM implementation must
	at least support identifier types appropriate to the content
	being processed.  <bibref role="informative" ref="HTML40"/>,
	<bibref role="informative" ref="XML"/>, and associated namespace
	specification <bibref role="informative" ref="Namespaces"/> rely
	on <bibref role="informative" ref="URIRef"/> to determine
	permissible characters and resolving relative URIs.  Other
	specifications such as namespaces in XML 1.1 <bibref role="informative" ref="Namespaces11"/> may rely on alternative
	resource identifier types that may, for example, include
	non-ASCII characters, necessitating support for alternative
	resource identifier types where required by applicable
	specifications.
      </p>
    </div3>

    <div3 id="Namespaces-Considerations">
      <head>XML Namespaces</head>

      <p>
	DOM Level 2 and 3 support XML namespaces <bibref ref="Namespaces"/> by augmenting several interfaces of the DOM
	Level 1 Core to allow creating and manipulating <termref def="dt-element">elements</termref> and attributes associated to
	a namespace. When <bibref ref="XML11"/> is in use (see
	<code>Document.xmlVersion</code>), DOM Level 3 also supports
	<bibref ref="Namespaces11"/>.
      </p>
      <p>As far as the DOM is concerned, special attributes used for declaring
        XML namespaces are still
        exposed and can be manipulated just like any other attribute. However,
        nodes are permanently bound to <termref def="dt-namespaceURI">namespace
          URIs</termref> as they get created. Consequently, moving a node
        within a document, using the DOM, in no case results in a change of its
        <termref def="dt-namespaceprefix">namespace prefix</termref> or
        namespace URI. Similarly, creating a node with a namespace prefix and
        namespace URI, or changing the namespace prefix of a node, does not
        result in any addition, removal, or modification of any special
        attributes for declaring the appropriate XML namespaces. Namespace
        validation is not enforced; the DOM application is responsible. In
        particular, since the mapping between prefixes and namespace URIs is
        not enforced, in general, the resulting document cannot be serialized
        naively. For example, applications may have to declare every namespace
        in use when serializing a document.</p>
      <p>In general, the DOM implementation (and higher) doesn't perform any
        URI normalization or canonicalization. The URIs given to the DOM are
        assumed to be valid (e.g., characters such as white spaces are properly
        escaped), and no lexical checking is performed. Absolute URI references
        are treated as strings and <termref def="dt-string-compare">compared
          literally</termref>. How relative namespace URI references are
        treated is undefined. To ensure interoperability only absolute
        namespace URI references (i.e., URI references beginning with a scheme
        name and a colon) should be used. Applications should use the
	value <code>null</code> as the <code>namespaceURI</code>
	parameter 
	for methods if they wish to have no namespace. In programming
	languages where empty strings can be differentiated from null,
	empty strings, when given as a namespace URI, are converted to
	<code>null</code>.
	This is
	true even though the DOM does no lexical checking of URIs.</p> 
      <note>
	<p>
	  <code>Element.setAttributeNS(null, ...)</code> puts the attribute in
	  the <term>per-element-type partitions</term> as defined in
	  <xspecref xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/1999/REC-xml-names-19990114" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">XML Namespace
	  Partitions</xspecref> in <bibref ref="Namespaces"/>.
	</p>
      </note>
      <note>
        <p>In the DOM, all namespace declaration attributes are <emph>by
            definition</emph> bound to the namespace URI:
          "<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/2000/xmlns/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/2000/xmlns/</loc>". These are the attributes
          whose <termref def="dt-namespaceprefix">namespace prefix</termref> or
          <termref def="dt-qualifiedname">qualified name</termref> is
          "xmlns" as introduced in <bibref ref="Namespaces11"/>.</p>
      </note>
      <p>In a document with no namespaces, the
        <termref def="dt-child">child</termref> list of an
        <code>EntityReference</code> node is always the same as that of the
        corresponding <code>Entity</code>. This is not true in a document where
        an entity contains unbound <termref def="dt-namespaceprefix">namespace
          prefixes</termref>. In such a case, the
        <termref def="dt-descendant">descendants</termref> of the corresponding
        <code>EntityReference</code> nodes may be bound to different
        <termref def="dt-namespaceURI">namespace URIs</termref>, depending on
        where the entity references are. Also, because, in the DOM, nodes
        always remain bound to the same namespace URI, moving such
        <code>EntityReference</code> nodes can lead to documents that cannot be
        serialized. This is also true when the DOM Level 1 method
        <code>Document.createEntityReference(name)</code> is used to create
	entity references that correspond to such
        entities, since the <termref def="dt-descendant">descendants</termref>
        of the returned <code>EntityReference</code> are unbound. While DOM Level
        3 does have support for the resolution of namespace prefixes,
        use of such entities and entity references should be
        avoided or used with extreme care.</p>
      <p>The "NS" methods, such as
	<code>Document.createElementNS(namespaceURI, qualifiedName)</code> and
        <code>Document.createAttributeNS(namespaceURI, qualifiedName)</code>,
        are meant to be used by namespace aware applications. Simple
        applications that do not use namespaces can use the DOM Level 1
        methods, such as <code>Document.createElement(tagName)</code> and
        <code>Document.createAttribute(name)</code>. Elements and attributes created in this
        way do not have any namespace prefix, namespace URI, or local name.</p>
      <note>
        <p>DOM Level 1 methods are namespace ignorant. Therefore, while it is
          safe to use these methods when not dealing with namespaces, using
          them and the new ones at the same time should be avoided. DOM Level 1
          methods solely identify attribute nodes by their
          <code>Node.nodeName</code>. On the contrary, the DOM Level 2 methods
          related to namespaces, identify attribute nodes by their
          <code>Node.namespaceURI</code> and <code>Node.localName</code>. Because of this
          fundamental difference, mixing both sets of methods can lead to
          unpredictable results. In particular, using
          <code>Element.setAttributeNS(namespaceURI, qualifiedName, value)</code>, an
          <termref def="dt-element">element</termref> may have two attributes
          (or more) that have the same <code>Node.nodeName</code>, but different
          <code>Node.namespaceURI</code>s. Calling <code>Element.getAttribute(name)</code> with
          that <code>nodeName</code> could then return any of those
          attributes. The result depends on the implementation. Similarly,
          using <code>Element.setAttributeNode(newAttr)</code>, one can set two attributes (or
          more) that have different <code>Node.nodeName</code>s but the same
          <code>Node.prefix</code> and <code>Node.namespaceURI</code>. In this case
          <code>Element.getAttributeNodeNS(namespaceURI, localName)</code> will return either attribute, in an
          implementation dependent manner. The only guarantee in such cases is
          that all methods that access a named item by its
          <code>nodeName</code> will access the same item, and all methods
          which access a node by its URI and local name will access the same
          node. For instance, <code>Element.setAttribute(name, value)</code> and
          <code>Element.setAttributeNS(namespaceURI, qualifiedName, value)</code> affect the node that
          <code>Element.getAttribute(name)</code> and
	  <code>Element.getAttributeNS(namespaceURI, localName)</code>,
          respectively, return.</p>
      </note>
    </div3>

    <div3 id="baseURIs-Considerations">
      <head>Base URIs</head>

      <p>The DOM Level 3 adds support for the <b>[base URI]</b> property
	defined in
        <bibref ref="InfoSet"/> by providing a new attribute on the
        <code>Node</code> interface that exposes this information. However,
        unlike the <code>Node.namespaceURI</code> attribute, the
        <code>Node.baseURI</code> attribute is not a static piece of information
        that every node carries. Instead, it is a value that is dynamically
        computed according to <bibref ref="XMLBase"/>. This means its value
        depends on the location of the node in the tree and moving the node
        from one place to another in the tree may affect its value. Other
        changes, such as adding or changing an <code>xml:base</code> attribute on the node
        being queried or one of its ancestors may also affect its value.
      </p>

      <p>One consequence of this it that when external entity references are
        expanded while building a <code>Document</code> one may need to add, or
        change, an xml:base attribute to the
        <code>Element</code> nodes originally contained in the entity being
        expanded so that the <code>Node.baseURI</code> returns the correct value. In
        the case of <code>ProcessingInstruction</code> nodes originally
        contained in the entity being expanded the information is lost.
        <bibref role="informative" ref="DOMLS"/> handles elements as described
        here and generates a warning in the latter case.
      </p>

    </div3>

    <div3 id="Embedded-DOM">
      <head>Mixed DOM Implementations</head>

      <p>As new XML vocabularies are developed, those defining the vocabularies
	are also beginning to define specialized APIs for manipulating XML
	instances of those vocabularies. This is usually done by extending the
	DOM to provide interfaces and methods that perform operations
	frequently needed by their users. For example, the MathML <bibref role="informative" ref="MathML2"/> and SVG
	<bibref role="informative" ref="SVG1"/> specifications have developed DOM extensions to allow users to
	manipulate instances of these vocabularies using semantics appropriate
	to images and mathematics, respectively, as well as the generic DOM XML
	semantics. Instances of SVG or MathML are often embedded in XML
	documents conforming to a different schema such as XHTML.
      </p>

      <p>
	While the Namespaces in XML specification <bibref ref="Namespaces"/> provides a mechanism for integrating these
	documents at the syntax level, it has become clear that the DOM
	Level 2 Recommendation <bibref role="informative" ref="DOM2Core"/> is not rich enough to cover all the issues that
	have been encountered in having these different DOM
	implementations be used together in a single application. DOM
	Level 3 deals with the requirements brought about by embedding
	fragments written according to a specific markup language (the
	embedded component) in a document where the rest of the markup
	is not written according to that specific markup language (the
	host document). It does not deal with fragments embedded by
	reference or linking.</p>

      <p>A DOM implementation supporting DOM Level 3 Core should be able to
	collaborate with subcomponents implementing specific DOMs to assemble a
	compound document that can be traversed and manipulated via DOM
	interfaces as if it were a seamless whole.</p>

      <p>The normal typecast operation on an object should support the
	interfaces expected by legacy code for a given document type.
	Typecasting techniques may not be adequate for selecting between
	multiple DOM specializations of an object which were combined at run
	time, because they may not all be part of the same object as defined by
	the binding's object model. Conflicts are most obvious with the
	<code>Document</code> object, since it is shared as owner by the rest
	of the document. In a homogeneous document, elements rely on the
	Document for specialized services and construction of specialized
	nodes. In a heterogeneous document, elements from different modules
	expect different services and APIs from the same <code>Document</code>
	object, since there can only be one owner and root of the document
	hierarchy.</p>
    </div3>

    <div3 id="DOMFeatures">
      <head>DOM Features</head>

      <p>
	Each DOM module defines one or more features, as listed in the
	conformance section (<specref ref="ID-Conformance"/>). Features
	are case-insensitive and are also defined for a specific set of
	versions. For example, this specification defines the features
	<code>"Core"</code> and <code>"XML"</code>, for the
	version <code>"3.0"</code>.  Versions <code>"1.0"</code> and
	<code>"2.0"</code> can also be used for features defined in the corresponding DOM
	Levels.  To avoid possible conflicts, as a convention, names
	referring to features defined outside the DOM specification
	should be made unique. Applications could then request for
	features to be supported by a DOM implementation using the
	methods
	<code>DOMImplementationSource.getDOMImplementation(features)</code>
	or
	<code>DOMImplementationSource.getDOMImplementationList(features)</code>,
	check the features supported by a DOM implementation using the
	method <code>DOMImplementation.hasFeature(feature, version)</code>, or by a specific node using
	<code>Node.isSupported(feature, version)</code>. Note that when
	using the methods that take a feature and a version as
	parameters, applications can use <code>null</code> or empty
	string for the version parameter if they don't wish to specify a
	particular version for the specified feature.
      </p>
      <p>
	Up to the DOM Level 2 modules, all interfaces, that were an
	extension of existing ones, were accessible using
	binding-specific casting mechanisms if the feature associated to
	the extension was supported. For example, an instance of the
	<code>EventTarget</code> interface could be obtained from an
	instance of the <code>Node</code> interface if the feature
	"Events" was supported by the node.
      </p>
      <p>
	As discussed <specref ref="Embedded-DOM"/>, DOM Level 3 Core
	should be able to collaborate with subcomponents implementing
	specific DOMs. For that effect, the methods
	<code>DOMImplementation.getFeature(feature, version)</code> and
	<code>Node.getFeature(feature, version)</code> were
	introduced. In the case of
	<code>DOMImplementation.hasFeature(feature, version)</code> and
	<code>Node.isSupported(feature, version)</code>, if a plus sign
	"+" is prepended to any feature name, implementations are
	considered in which the specified feature may not be directly
	castable but would require discovery through
	<code>DOMImplementation.getFeature(feature, version)</code> and
	<code>Node.getFeature(feature, version)</code>. Without a plus,
	only features whose interfaces are directly castable are
	considered.
      </p>
      <eg role="code" xml:space="preserve">// example 1, without prepending the "+"
if (myNode.isSupported("Events", "3.0")) {
    EventTarget evt = (EventTarget) myNode;
    // ...
}
// example 2, with the "+"
if (myNode.isSupported("+Events", "3.0")) {
    // (the plus sign "+" is irrelevant for the getFeature method itself
    // and is ignored by this method anyway)
    EventTarget evt = (EventTarget) myNode.getFeature("Events", "3.0");
    // ...
}</eg>
    </div3>

    <div3 id="Bootstrap">
      <head>Bootstrapping</head>

      <p>Because previous versions of the DOM specification only defined a set
        of interfaces, applications had to rely on some implementation
        dependent code to start from. However, hard-coding the application to a
        specific implementation prevents the application from running on other
        implementations and from using the most-suitable implementation of the
        environment. At the same time, implementations may also need to load
        modules or perform other setup to efficiently adapt to different and
        sometimes mutually-exclusive feature sets.</p>

      <p>To solve these problems this specification introduces a
        <code>DOMImplementationRegistry</code> object with a function that lets
        an application find implementations, based on the specific features
        it requires. How this object is found and what it exactly looks like is
        not defined here, because this cannot be done in a language-independent
        manner. Instead, each language binding defines its own way of doing
        this. See <specref ref="java-binding"/> and
          <specref ref="ecma-binding"/> for specifics.</p>

      <p>In all cases, though, the <code>DOMImplementationRegistry</code>
        provides a <code>getDOMImplementation</code> method accepting a
        features string, which is passed to every known
        <code>DOMImplementationSource</code> until a suitable
        <code>DOMImplementation</code> is found and returned.
	The <code>DOMImplementationRegistry</code>
        also provides a <code>getDOMImplementationList</code> method accepting a
        features string, which is passed to every known
        <code>DOMImplementationSource</code>, and returns a list of suitable
        <code>DOMImplementations</code>. Those two methods are
        the same as the ones found on the <code>DOMImplementationSource</code>
        interface. </p>

      <p>Any number of <code>DOMImplementationSource</code> objects can be
        registered. A source may return one or more
        <code>DOMImplementation</code> singletons or construct new
        <code>DOMImplementation</code> objects, depending upon whether the
        requested features require specialized state in the
        <code>DOMImplementation</code> object.</p>

    </div3>

  </div2>
  <!--
  ******************************************************
  | DOCUMENT OBJECT MODEL APIs                         |
  ******************************************************
  -->
  <div2 id="ID-BBACDC08">
    <head>Fundamental Interfaces: Core Module</head>

    <p>The interfaces within this section are considered
      <emph>fundamental</emph>, and must be fully implemented by all conforming
      implementations of the DOM, including all HTML DOM implementations
      <bibref role="informative" ref="DOM2HTML"/>, unless otherwise specified.
    </p>
    <p>A DOM application may use the
    <code>DOMImplementation.hasFeature(feature, version)</code> method
    with parameter values "Core" and "3.0" (respectively) to determine
    whether or not this module is supported by the implementation. Any
    implementation that conforms to DOM Level 3 or a DOM Level 3 module
    must conform to the Core module. Please refer to additional
    information about <xspecref xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/DOM-Level-3-Core/introduction.html#ID-Conformance" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">conformance</xspecref> in this specification.  The DOM Level 3 Core
    module is backward compatible with the DOM Level 2 Core <bibref role="informative" ref="DOM2Core"/> module, i.e. a DOM Level 3 Core
    implementation who returns <code>true</code> for "Core" with the
    <code>version</code> number <code>"3.0"</code> must also return
    <code>true</code> for this <code>feature</code> when the
    <code>version</code> number is <code>"2.0"</code>, <code>""</code>
    or, <code>null</code>.
    </p>

    <definitions>
      
<!-- $Date: 2004/02/25 20:38:26 $ $Revision: 1.10 $ -->
<!--[ Exceptions description ]-->
<exception name="DOMException" id="ID-17189187">
  <descr>
    <p>DOM operations only raise exceptions in "exceptional"
      circumstances, i.e., when an operation is impossible to perform (either
      for logical reasons, because data is lost, or because the implementation
      has become unstable). In general, DOM methods return specific error
      values in ordinary processing situations, such as out-of-bound errors
      when using <code>NodeList</code>.</p>
    <p>Implementations should raise other exceptions under other circumstances.
      For example, implementations should raise an implementation-dependent 
      exception if a <code>null</code> argument is passed when
      <code>null</code> was not expected.</p>
    <p>Some languages and object systems do not support the concept of
      exceptions. For such systems, error conditions may be indicated using
      native error reporting mechanisms. For some bindings, for example,
      methods may return error codes similar to those listed in the
      corresponding method descriptions.</p>
  </descr>
  <component id="ID-146F692A" name="code">
    <typename>unsigned short</typename>
  </component>
</exception>
<group id="ID-258A00AF" name="ExceptionCode">
  <descr>
    <p>An integer indicating the type of error generated.</p>
    <note>
      <p>Other numeric codes are reserved for W3C for possible future use.</p>
    </note>
  </descr>
  <constant id="DOMException-INDEX_SIZE_ERR" name="INDEX_SIZE_ERR" type="unsigned short" value="1">
    <descr>
      <p>If index or size is negative, or greater than the allowed value.</p>
    </descr>
  </constant>
  <constant id="DOMException-DOMSTRING_SIZE_ERR" name="DOMSTRING_SIZE_ERR" type="unsigned short" value="2">
    <descr>
      <p>If the specified range of text does not fit into a <code>DOMString</code>.</p>
    </descr>
  </constant>
  <constant id="DOMException-HIERARCHY_REQUEST_ERR" name="HIERARCHY_REQUEST_ERR" type="unsigned short" value="3">
    <descr>
      <p>If any <code>Node</code> is inserted somewhere it doesn't belong.</p>
    </descr>
  </constant>
  <constant id="DOMException-WRONG_DOCUMENT_ERR" name="WRONG_DOCUMENT_ERR" type="unsigned short" value="4">
    <descr>
      <p>If a <code>Node</code> is used in a different document than the one that created it
        (that doesn't support it).</p>
    </descr>
  </constant>
  <constant id="DOMException-INVALID_CHARACTER_ERR" name="INVALID_CHARACTER_ERR" type="unsigned short" value="5">
    <descr>
      <p>If an invalid or illegal character is specified, such as in an
        XML name.<!-- See <xspecref href="&xml-spec;#NT-Char">production 2</xspecref>
        in the XML specification for the definition of a legal character, and 
        <xspecref href="&xml-spec;#NT-Name">production 5</xspecref> for the
        definition of a legal name character.--></p>
    </descr>
  </constant>
  <constant id="DOMException-NO_DATA_ALLOWED_ERR" name="NO_DATA_ALLOWED_ERR" type="unsigned short" value="6">
    <descr>
      <p>If data is specified for a <code>Node</code> which does not support data.</p>
    </descr>
  </constant>
  <constant id="DOMException-NO_MODIFICATION_ALLOWED_ERR" name="NO_MODIFICATION_ALLOWED_ERR" type="unsigned short" value="7">
    <descr>
      <p>If an attempt is made to modify an object where modifications are not
        allowed.</p>
    </descr>
  </constant>
  <constant id="DOMException-NOT_FOUND_ERR" name="NOT_FOUND_ERR" type="unsigned short" value="8">
    <descr>
      <p>If an attempt is made to reference a <code>Node</code> in a context where it does
        not exist.</p>
    </descr>
  </constant>
  <constant id="DOMException-NOT_SUPPORTED_ERR" name="NOT_SUPPORTED_ERR" type="unsigned short" value="9">
    <descr>
      <p>If the implementation does not support the requested type of object or
        operation.</p>
    </descr>
  </constant>
  <constant id="DOMException-INUSE_ATTRIBUTE_ERR" name="INUSE_ATTRIBUTE_ERR" type="unsigned short" value="10">
    <descr>
      <p>If an attempt is made to add an attribute that is already in use
	elsewhere.</p>
    </descr>
  </constant>
  <!-- ****** DOM Level 2 additions ****** -->
  <constant id="DOMException-INVALID_STATE_ERR" name="INVALID_STATE_ERR" type="unsigned short" value="11" since="DOM Level 2">
    <descr>
      <p>If an attempt is made to use an object that is not, or is no longer,
        usable.</p>
    </descr>
  </constant>
  <constant id="DOMException-SYNTAX_ERR" name="SYNTAX_ERR" type="unsigned short" value="12" since="DOM Level 2">
    <descr>
      <p>If an invalid or illegal string is specified.</p>
    </descr>
  </constant>
  <constant id="DOMException-INVALID_MODIFICATION_ERR" name="INVALID_MODIFICATION_ERR" type="unsigned short" value="13" since="DOM Level 2">
    <descr>
      <p>If an attempt is made to modify the type of the underlying object.</p>
    </descr>
  </constant>
  <constant id="DOMException-NAMESPACE_ERR" name="NAMESPACE_ERR" type="unsigned short" value="14" since="DOM Level 2">
    <descr>
      <p>If an attempt is made to create or change an object in a way which is
        incorrect with regard to namespaces.</p>
    </descr>
  </constant>
  <constant id="DOMException-INVALID_ACCESS_ERR" name="INVALID_ACCESS_ERR" type="unsigned short" value="15" since="DOM Level 2">
    <descr>
      <p>If a parameter or an operation is not supported by the underlying
        object.</p>
    </descr>
  </constant>
  <constant id="DOMException-VALIDATION_ERR" name="VALIDATION_ERR" type="unsigned short" value="16" since="DOM Level 3">
    <descr>
      <p>If a call to a method such as <code>insertBefore</code> or
      <code>removeChild</code> would make the <code>Node</code> invalid with
      respect to <termref def="dt-partially-valid">"partial
      validity"</termref>, this exception would be raised and the operation
      would not be done. This code is used in <bibref role="informative" ref="DOMVal"/>. Refer to this specification for further information.</p>
    </descr>
  </constant>
  <constant id="DOMException-TYPE_MISMATCH_ERR" name="TYPE_MISMATCH_ERR" type="unsigned short" value="17" since="DOM Level 3">
    <descr>
      <p>
	If the type of an object is incompatible with the expected type
	of the parameter associated to the object.
      </p>
    </descr>
  </constant>
</group>
 
<!-- $Date: 2003/08/16 02:20:28 $ -->
<!--[ NameList object description ]-->
<interface name="DOMStringList" id="DOMStringList" since="DOM Level 3">
  <descr>
    <p>
      The <code>DOMStringList</code> interface provides the abstraction
      of an ordered collection of <code>DOMString</code> values, without
      defining or constraining how this collection is implemented. The
      items in the <code>DOMStringList</code> are accessible via an
      integral index, starting from 0.
    </p>
  </descr>

  <method name="item" id="DOMStringList-item">
    <descr>
      <p>
	Returns the <code>index</code>th item in the collection. If
	<code>index</code> is greater than or equal to the number of
	<code>DOMString</code>s in the list, this returns
	<code>null</code>.
      </p>
    </descr>
    <parameters>
      <param name="index" type="unsigned long" attr="in">
	<descr>
          <p>Index into the collection.</p>
        </descr>
      </param>
    </parameters>
    <returns type="DOMString">
      <descr>
        <p>
	  The <code>DOMString</code> at the <code>index</code>th
	  position in the <code>DOMStringList</code>, or
	  <code>null</code> if that is not a valid index.
	</p>
      </descr>
    </returns>
    <raises>
      <!-- No exceptions -->
    </raises>
  </method>

  <attribute type="unsigned long" readonly="yes" name="length" id="DOMStringList-length">
    <descr>
      <p>The number of <code>DOMString</code>s in the list. The range of
      valid child node indices is 0 to <code>length-1</code>
      inclusive.</p>
    </descr>
  </attribute>

  <method name="contains" id="DOMStringList-contains">
    <descr>
      <p>
	Test if a string is part of this <code>DOMStringList</code>.
      </p>
    </descr>
    <parameters>
      <param name="str" type="DOMString" attr="in">
	<descr>
	  <p>
	    The string to look for.
	  </p>
	</descr>
      </param>
    </parameters>
    <returns type="boolean">
      <descr>
	<p>
	  <code>true</code> if the string has been found,
	  <code>false</code> otherwise.
	</p>
      </descr>
    </returns>
    <raises>
    </raises>
  </method>

</interface>
      
 
<!-- $Date: 2004/01/05 14:46:52 $ -->
<!--[ NameList object description ]-->
<interface name="NameList" id="NameList" since="DOM Level 3">
  <descr>
    <p>
      The <code>NameList</code> interface provides the abstraction of an
      ordered collection of parallel pairs of name and namespace values
      (which could be null values), without defining or constraining how
      this collection is implemented. The items in the
      <code>NameList</code> are accessible via an integral index,
      starting from 0.
    </p>
  </descr>

  <method name="getName" id="NameList-getName">
    <descr>
      <p>
	Returns the <code>index</code>th name item in the collection.
      </p>
    </descr>
    <parameters>
      <param name="index" type="unsigned long" attr="in">
	<descr>
          <p>Index into the collection.</p>
        </descr>
      </param>
    </parameters>
    <returns type="DOMString">
      <descr>
        <p>
	  The name at the <code>index</code>th
	  position in the <code>NameList</code>, or <code>null</code> if
	  there is no name for the specified index or if the index is
	  out of range.
	</p>
      </descr>
    </returns>
    <raises>
    </raises>
  </method>

  <method name="getNamespaceURI" id="NameList-getNamespaceURI">
    <descr>
      <p>
	Returns the <code>index</code>th namespaceURI item in the
	collection.
      </p>
    </descr>
    <parameters>
      <param name="index" type="unsigned long" attr="in">
	<descr>
          <p>Index into the collection.</p>
        </descr>
      </param>
    </parameters>
    <returns type="DOMString">
      <descr>
        <p>
	  The namespace URI at the <code>index</code>th
	  position in the <code>NameList</code>, or <code>null</code> if
	  there is no name for the specified index or if the index is
	  out of range.
	</p>
      </descr>
    </returns>
    <raises>
    </raises>
  </method>

  <attribute type="unsigned long" readonly="yes" name="length" id="NameList-length">
    <descr>
      <p>
	The number of pairs (name and namespaceURI) in the list. The
	range of valid child node indices is 0 to <code>length-1</code>
	inclusive.
      </p>
    </descr>
  </attribute>

  <method name="contains" id="NameList-contains">
    <descr>
      <p>
	Test if a name is part of this <code>NameList</code>.
      </p>
    </descr>
    <parameters>
      <param name="str" type="DOMString" attr="in">
	<descr>
	  <p>
	    The name to look for.
	  </p>
	</descr>
      </param>
    </parameters>
    <returns type="boolean">
      <descr>
	<p>
	  <code>true</code> if the name has been found,
	  <code>false</code> otherwise.
	</p>
      </descr>
    </returns>
    <raises>
    </raises>
  </method>

  <method name="containsNS" id="NameList-containsNS">
    <descr>
      <p>
	Test if the pair namespaceURI/name is part of this
	<code>NameList</code>.
      </p>
    </descr>
    <parameters>
      <param name="namespaceURI" type="DOMString" attr="in">
	<descr>
	  <p>
	    The namespace URI to look for.
	  </p>
	</descr>
      </param>
      <param name="name" type="DOMString" attr="in">
	<descr>
	  <p>
	    The name to look for.
	  </p>
	</descr>
      </param>
    </parameters>
    <returns type="boolean">
      <descr>
	<p>
	  <code>true</code> if the pair namespaceURI/name has been
	  found, <code>false</code> otherwise.
	</p>
      </descr>
    </returns>
    <raises>
    </raises>
  </method>

</interface>
      

      
<!-- $Date: 2003/02/03 23:17:47 $ -->
<!--[ NameList object description ]-->
<interface name="DOMImplementationList" id="DOMImplementationList" since="DOM Level 3">
  <descr>
    <p>
      The <code>DOMImplementationList</code> interface provides the
      abstraction of an ordered collection of DOM implementations,
      without defining or constraining how this collection is
      implemented. The items in the <code>DOMImplementationList</code>
      are accessible via an integral index, starting from 0.
    </p>
  </descr>

  <method name="item" id="DOMImplementationList-item">
    <descr>
      <p>
	Returns the <code>index</code>th item in the collection. If
	<code>index</code> is greater than or equal to the number of
	<code>DOMImplementation</code>s in the list, this returns
	<code>null</code>.
      </p>
    </descr>
    <parameters>
      <param name="index" type="unsigned long" attr="in">
	<descr>
          <p>Index into the collection.</p>
        </descr>
      </param>
    </parameters>
    <returns type="DOMImplementation">
      <descr>
        <p>
	  The <code>DOMImplementation</code> at the <code>index</code>th
	  position in the <code>DOMImplementationList</code>, or
	  <code>null</code> if that is not a valid index.
	</p>
      </descr>
    </returns>
    <raises>
      <!-- No exceptions -->
    </raises>
  </method>

  <attribute type="unsigned long" readonly="yes" name="length" id="DOMImplementationList-length">
    <descr>
      <p>
	The number of <code>DOMImplementation</code>s in the list. The
	range of valid child node indices is 0 to <code>length-1</code>
	inclusive.
      </p>
    </descr>
  </attribute>
</interface>
      
 
<!-- $Id: impl-source.xml,v 1.7 2003/10/29 19:10:01 plehegar Exp $ -->
<interface name="DOMImplementationSource" id="DOMImplementationSource" since="DOM Level 3">
  <descr>
    <p>This interface permits a DOM implementer to supply one or more
      implementations, based upon requested features and versions, as
      specified in <specref ref="DOMFeatures"/>. Each implemented
      <code>DOMImplementationSource</code> object is listed in the
      binding-specific list of available sources so that its
      <code>DOMImplementation</code> objects are made available.</p>
  </descr>
  <method name="getDOMImplementation" id="ID-getDOMImpl">
    <descr>
      <p>
	A method to request the first DOM implementation that supports the
	specified features.
      </p>
    </descr>
    <parameters>
      <param name="features" type="DOMString" attr="in">
        <descr>
          <p>
	    A string that specifies which features and versions are
	    required. This is a space separated list in which each
	    feature is specified by its name optionally followed by a
	    space and a version number.
	  </p>
	  <p>
	    This method returns the first item of the list returned by
	    <code>getDOMImplementationList</code>.
	  </p>
	  <p>
	    As an example, the string <code>"XML 3.0 Traversal +Events
	    2.0"</code> will request a DOM implementation that supports
	    the module "XML" for its 3.0 version, a module that support
	    of the "Traversal" module for any version, and the module
	    "Events" for its 2.0 version. The module "Events" must be
	    accessible using the method <code>Node.getFeature()</code> and
	    <code>DOMImplementation.getFeature()</code>.
	  </p>
        </descr>
      </param>
    </parameters>
    <returns type="DOMImplementation">
      <descr>
        <p>The first DOM implementation that support the desired features, or
          <code>null</code> if this source has none.</p>
      </descr>
    </returns>
    <raises>
      <!-- Throws no exceptions -->
    </raises>
  </method>

  <method name="getDOMImplementationList" id="ID-getDOMImpls">
    <descr>
      <p>A method to request a list of DOM implementations that support
      the specified features and versions, as specified in <specref ref="DOMFeatures"/>.</p>
    </descr>
    <parameters>
      <param name="features" type="DOMString" attr="in">
        <descr>
          <p>A string that specifies which features and versions are
          required. This is a space separated list in which each feature
          is specified by its name optionally followed by a space and a
          version number. This is something like: "XML 3.0 Traversal
          +Events 2.0"</p>
        </descr>
      </param>
    </parameters>
    <returns type="DOMImplementationList">
      <descr>
        <p>A list of DOM implementations that support the desired
        features.</p>
      </descr>
    </returns>
    <raises>
      <!-- Throws no exceptions -->
    </raises>
  </method>
</interface>

      
<!--[ DOMImplementation object description ]-->    
<!-- $Date: 2004/02/25 20:35:13 $ $Revision: 1.14 $ -->
<interface name="DOMImplementation" id="ID-102161490">
  <descr>
    <p>The <code>DOMImplementation</code> interface provides a number of
      methods for performing operations that are independent of any particular
      instance of the document object model.</p>
  </descr>
  <method name="hasFeature" id="ID-5CED94D7">
    <descr>
      <p>Test if the DOM implementation implements a specific feature
      and version, as specified in <specref ref="DOMFeatures"/>.</p>
    </descr>
    <parameters>
      <param name="feature" type="DOMString" attr="in">
	<descr>
          <p>
	    The name of the feature to test.
	  </p>
        </descr>
      </param>
      <param name="version" type="DOMString" attr="in">
	<descr>
          <p>
	    This is the version number of the feature to test.
	  </p>
        </descr>
      </param>
    </parameters>
    <returns type="boolean">
      <descr>
        <p><code>true</code> if the feature is implemented in the specified
          version, <code>false</code> otherwise.</p>
      </descr>
    </returns>
    <raises>
      <!-- Throws no exceptions -->
    </raises>
  </method>

  <!-- ****** DOM Level 2 additions ****** -->
  <method name="createDocumentType" id="Level-2-Core-DOM-createDocType" since="DOM Level 2">
    <descr>
      <p>Creates an empty <code>DocumentType</code> node. Entity declarations
        and notations are not made available. Entity reference expansions and
        default attribute additions do not occur.<!-- It is expected that a future
        version of the DOM will provide a way for populating a
        <code>DocumentType</code> -->.</p>
    </descr>
    <parameters>
      <param name="qualifiedName" type="DOMString" attr="in">
	<descr>
          <p>The <termref def="dt-qualifiedname">qualified name</termref>
	    of the document type to be created.</p>
	</descr>
      </param>
      <param name="publicId" type="DOMString" attr="in">
	<descr>
          <p>The external subset public identifier.</p>
	</descr>
      </param>
      <param name="systemId" type="DOMString" attr="in">
	<descr>
          <p>The external subset system identifier.</p>
	</descr>
      </param>
    </parameters>
    <returns type="DocumentType">
      <descr>
        <p>A new <code>DocumentType</code> node with
          <code>Node.ownerDocument</code> set to <code>null</code>.</p>
      </descr>
    </returns>
    <raises>
      <exception name="DOMException">
	<descr>
          <p>INVALID_CHARACTER_ERR: Raised if the specified qualified name
	    is not an XML name according to <bibref ref="XML"/>.</p>
	  <p>NAMESPACE_ERR: Raised if the <code>qualifiedName</code> is
	    malformed.</p>
          <p>NOT_SUPPORTED_ERR: May be raised if the implementation does
	    not support the feature "XML" and the language exposed
	    through the Document does not support XML Namespaces (such
	    as <bibref role="informative" ref="HTML40"/>).
          </p>
	</descr>
      </exception>
    </raises>
  </method>

  <method name="createDocument" id="Level-2-Core-DOM-createDocument" since="DOM Level 2">
    <descr>
      <p>Creates a DOM Document object of the specified type with its document
        element.</p>
      <p>Note that based on the <code>DocumentType</code> given to create the
        document, the implementation may instantiate specialized
        <code>Document</code> objects that support additional features than the
        "Core", such as "HTML" <bibref role="informative" ref="DOM2HTML"/>.
        On the other hand, setting the <code>DocumentType</code> after the
        document was created makes this very unlikely to happen. Alternatively,
        specialized <code>Document</code> creation methods, such as
        <code>createHTMLDocument</code>
        <bibref role="informative" ref="DOM2HTML"/>, can be used to obtain
        specific types of <code>Document</code> objects.</p>
    </descr>
    <parameters>
      <param name="namespaceURI" type="DOMString" attr="in">
	<descr>
          <p>The <termref def="dt-namespaceURI">namespace URI</termref> of the
            document element to create or <code>null</code>.</p>
	</descr>
      </param>
      <param name="qualifiedName" type="DOMString" attr="in">
	<descr>
          <p>The <termref def="dt-qualifiedname">qualified name</termref> of
            the document element to be created or <code>null</code>.</p>
	</descr>
      </param>
      <param name="doctype" type="DocumentType" attr="in">
	<descr>
          <p>The type of document to be created or <code>null</code>.</p>
	  <p>When <code>doctype</code> is not <code>null</code>, its
	    <code>Node.ownerDocument</code> attribute is set to the document
	    being created.</p>
	</descr>
      </param>
    </parameters>
    <returns type="Document">
      <descr>
        <p>A new <code>Document</code> object with its document element. If the
	  <code>NamespaceURI</code>, <code>qualifiedName</code>, and
	  <code>doctype</code> are <code>null</code>, the returned
	  <code>Document</code> is empty with no document element.</p>
      </descr>
    </returns>
    <raises>
      <exception name="DOMException">
	<descr>
          <p>INVALID_CHARACTER_ERR: Raised if the specified qualified name
	    is not an XML name according to <bibref ref="XML"/>.</p>
	  <p>NAMESPACE_ERR: Raised if the <code>qualifiedName</code> is
            malformed, if the <code>qualifiedName</code> has a prefix and the
            <code>namespaceURI</code> is <code>null</code>, or if the
	    <code>qualifiedName</code> is <code>null</code> and the
            <code>namespaceURI</code> is different from <code>null</code>, or if the
            <code>qualifiedName</code> has a prefix that is "xml" and the
            <code>namespaceURI</code> is different from
            "<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/XML/1998/namespace" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/XML/1998/namespace</loc>" <bibref ref="Namespaces"/>,
              or if the DOM implementation does not support the
              <code>"XML"</code> feature but a non-null namespace URI was
              provided, since namespaces were defined by XML.</p>
	  <p>WRONG_DOCUMENT_ERR: Raised if <code>doctype</code> has already
	    been used with a different document or was created from a different
            implementation.</p>

          <p>NOT_SUPPORTED_ERR: May be raised if the implementation does
	    not support the feature "XML" and the language exposed
	    through the Document does not support XML Namespaces (such
	    as <bibref role="informative" ref="HTML40"/>).
          </p>
	</descr>
      </exception>
    </raises>
  </method>

  <!-- ****** DOM Level 3 additions ****** -->
  <method name="getFeature" id="DOMImplementation3-getFeature" since="DOM Level 3">
    <descr>
      <p>
	This method returns a specialized object which implements the
	specialized APIs of the specified feature and version, as
	specified in <specref ref="DOMFeatures"/>. The specialized
	object may also be obtained by using binding-specific casting
	methods but is not necessarily expected to, as discussed in
	<specref ref="Embedded-DOM"/>. This method also allow the
	implementation to provide specialized objects which do not
	support the <code>DOMImplementation</code> interface.
      </p>
    </descr>
    <parameters>
      <param name="feature" type="DOMString" attr="in">
        <descr>
          <p>
	    The name of the feature requested. Note that any plus sign
	    "+" prepended to the name of the feature will be ignored
	    since it is not significant in the context of this method.
	  </p>
        </descr>
      </param>
      <param name="version" type="DOMString" attr="in">
        <descr>
          <p>
	    This is the version number of the feature to test.
	  </p>
        </descr>
      </param>
    </parameters>
    <returns type="DOMObject">
      <descr>
        <p>
	  Returns an object which implements the specialized APIs of the
	  specified feature and version, if any, or <code>null</code> if
	  there is no object which implements interfaces associated with
	  that feature. If the <code>DOMObject</code> returned by this
	  method implements the <code>DOMImplementation</code>
	  interface, it must delegate to the primary core
	  <code>DOMImplementation</code> and not return results
	  inconsistent with the primary core
	  <code>DOMImplementation</code> such as
	  <code>hasFeature</code>, <code>getFeature</code>, etc.
	</p>
      </descr>
    </returns>
    <raises>
    </raises>
  </method>
</interface>
 
<!--[ DocumentFragment object description ]-->    
<!-- $Date: 2004/03/19 16:11:40 $ $Revision: 1.90 $ -->
<interface name="DocumentFragment" inherits="Node" id="ID-B63ED1A3">
  <descr>
    <p><code>DocumentFragment</code> is a "lightweight" or "minimal"
      <code>Document</code> object. It is very common to want to be able to
      extract a portion of a document's tree or to create a new fragment of a
      document. Imagine implementing a user command like cut or rearranging a
      document by moving fragments around. It is desirable to have an object
      which can hold such fragments and it is quite natural to use a Node for
      this purpose. While it is true that a <code>Document</code> object could
      fulfill this role, a <code>Document</code> object can potentially be a
      heavyweight object, depending on the underlying implementation. What is
      really needed for this is a very lightweight
      object. <code>DocumentFragment</code> is such an object.</p>
    <p>Furthermore, various operations -- such as inserting nodes as children
      of another <code>Node</code> -- may take <code>DocumentFragment</code>
      objects as arguments;  this results in all the child nodes of the
      <code>DocumentFragment</code> being moved to the child list of this
      node.</p>
    <p>The children of a <code>DocumentFragment</code> node are zero or more
      nodes representing the tops of any sub-trees defining the structure of
      the document. <code>DocumentFragment</code> nodes do not need to be
      <termref def="dt-well-formed">well-formed XML documents</termref>
      (although they do need to follow the rules imposed upon well-formed XML
      parsed entities, which can have multiple top nodes). For example, a
      <code>DocumentFragment</code> might have only one child and that child
      node could be a <code>Text</code> node. Such a structure model represents
      neither an HTML document nor a well-formed XML document.</p>
    <p>When a <code>DocumentFragment</code> is inserted into a
      <code>Document</code> (or indeed any other <code>Node</code> that may
      take children) the children of the <code>DocumentFragment</code> and not
      the <code>DocumentFragment</code> itself are inserted into the
      <code>Node</code>. This makes the <code>DocumentFragment</code> very
      useful when the user wishes to create nodes that are
      <termref def="dt-sibling">siblings</termref>; the
      <code>DocumentFragment</code> acts as the parent of these nodes so that
      the user can use the standard methods from the <code>Node</code>
      interface, such as <code>Node.insertBefore</code> and
      <code>Node.appendChild</code>.</p>
  </descr> 
</interface>

<!--[ Document object description ]-->    
<interface name="Document" inherits="Node" id="i-Document">
  <descr>
    <p>The <code>Document</code> interface represents the entire HTML or XML
      document. Conceptually, it is the
      <termref def="dt-root-node">root</termref> of the document tree, and
      provides the primary access to the document's data.</p>
    <p>Since elements, text nodes, comments, processing instructions,
      etc. cannot exist outside the context of a <code>Document</code>, the
      <code>Document</code> interface also contains the factory methods needed
      to create these objects. The <code>Node</code> objects created have a
      <code>ownerDocument</code> attribute which associates them with the
      <code>Document</code> within whose context they were created.</p>
  </descr>

  <attribute id="ID-B63ED1A31" name="doctype" type="DocumentType" readonly="yes" version="DOM Level 3">
    <descr>
      <p>The Document Type Declaration (see <code>DocumentType</code>)
        associated with this document. For XML
        documents without a document type declaration this returns
        <code>null</code>. For HTML documents, a
	<code>DocumentType</code> object may be returned, independently
	of the presence or absence of document type declaration in the
	HTML document.</p>
      <p>This provides direct access to the <code>DocumentType</code> node,
        child node of this <code>Document</code>. This node can be set at
        document creation time and later changed through the use of child nodes
        manipulation methods, such as <code>Node.insertBefore</code>, or
        <code>Node.replaceChild</code>. Note, however, that while some
        implementations may instantiate different types of
        <code>Document</code> objects supporting additional features than the
        "Core", such as "HTML" <bibref role="informative" ref="DOM2HTML"/>,
        based on the <code>DocumentType</code> specified at creation time,
        changing it afterwards is very unlikely to result in a change of the
        features supported.</p>
    </descr> 
  </attribute>

  <attribute readonly="yes" name="implementation" type="DOMImplementation" id="ID-1B793EBA">
    <descr>
      <p>The <code>DOMImplementation</code> object that handles this
        document. A DOM application may use objects from multiple
        implementations.</p>
    </descr> 
  </attribute>
  
  <attribute readonly="yes" name="documentElement" type="Element" id="ID-87CD092">
    <descr>

      <p>This is a <termref def="dt-convenience">convenience</termref>
	attribute that allows direct access to the child node that is the
	<termref def="dt-document-element">document element</termref> of the
	document.</p>
    </descr>
  </attribute>

  <!-- ********** -->
  <method name="createElement" id="ID-2141741547">
    <descr>
      <p>Creates an element of the type specified. Note that the instance
        returned implements the <code>Element</code> interface, so attributes
        can be specified directly  on the returned object.</p>
      <p>In addition, if there are known attributes with default values,
	<code>Attr</code> nodes representing them are automatically created and
	attached to the element.</p>
      <p>To create an element with a <termref def="dt-qualifiedname">qualified name</termref> and <termref def="dt-namespaceURI">namespace URI</termref>, use the
	<code>createElementNS</code> method.</p>
    </descr>
    <parameters>
      <param name="tagName" type="DOMString" attr="in">
	<descr>
          <p>The name of the element type to instantiate. For XML, this is
            case-sensitive, otherwise it depends on the case-sensitivity of the
            markup language in use. In that case, the name is mapped to the
            canonical form of that markup by the DOM implementation.</p>
        </descr>
      </param>
    </parameters>
    <returns type="Element">
      <descr><p>A new <code>Element</code> object with the
          <code>nodeName</code> attribute set to <code>tagName</code>, and
          <code>localName</code>, <code>prefix</code>, and
          <code>namespaceURI</code> set to <code>null</code>.</p>
      </descr>
    </returns>
    <raises>
      <exception name="DOMException">
        <descr>
          <p>INVALID_CHARACTER_ERR: Raised if the specified name is not
	    an XML name according to the XML version in use
	    specified in the <code>Document.xmlVersion</code> attribute.</p>
        </descr>
      </exception>
    </raises>
  </method>
  
  <!-- ********** -->
  <method name="createDocumentFragment" id="ID-35CB04B5">
    <descr>
      <p>Creates an empty <code>DocumentFragment</code> object.</p>
    </descr>
    <parameters>
      <!-- No parameters -->
    </parameters>
    <returns type="DocumentFragment">
      <descr>
        <p>A new <code>DocumentFragment</code>.</p>
      </descr>
    </returns>
    <raises>
      <!-- Throws no exceptions -->
    </raises>
  </method>

  <!-- ********** -->
  <method name="createTextNode" id="ID-1975348127">
    <descr>
      <p>Creates a <code>Text</code> node given the specified string.</p>
    </descr> 
    <parameters>
      <param name="data" type="DOMString" attr="in">
	<descr>
          <p>The data for the node.</p>
        </descr>
      </param>
    </parameters>
    <returns type="Text">
      <descr>
        <p>The new <code>Text</code> object.</p>
      </descr>
    </returns>
    <raises>
      <!-- Throws no exceptions -->
    </raises>
  </method>

  <!-- ********** -->
  <method name="createComment" id="ID-1334481328">
    <descr>
      <p>Creates a <code>Comment</code> node given the specified string.</p>
    </descr> 
    <parameters>
      <param name="data" type="DOMString" attr="in">
	<descr>
          <p>The data for the node.</p>
        </descr>
      </param>
    </parameters>
    <returns type="Comment">
      <descr>
        <p>The new <code>Comment</code> object.</p>
      </descr>
    </returns>
    <raises>
      <!-- Throws no exceptions -->
    </raises>
  </method>

  <!-- ********** -->
  <method name="createCDATASection" id="ID-D26C0AF8">
    <descr>
      <p>Creates a <code>CDATASection</code> node whose value is the specified
        string.</p>
    </descr> 
    <parameters>
      <param name="data" type="DOMString" attr="in">
	<descr>
          <p>The data for the <code>CDATASection</code> contents.</p>
	</descr>
      </param>
    </parameters>
    <returns type="CDATASection">
      <descr>
        <p>The new <code>CDATASection</code> object.</p>
      </descr>
    </returns>
    <raises>
      <exception name="DOMException">
        <descr>
          <p>NOT_SUPPORTED_ERR: Raised if this document is an HTML
            document.</p>
        </descr>
      </exception>
    </raises>
  </method>

  <!-- ********** -->
  <method name="createProcessingInstruction" id="ID-135944439">
    <descr>
      <p>Creates a <code>ProcessingInstruction</code> node given the specified
        name and data strings.</p>
    </descr> 
    <parameters>
      <param name="target" type="DOMString" attr="in">
	<descr>
          <p>The target part of the processing instruction.</p>
          <p>Unlike <code>Document.createElementNS</code> or
          <code>Document.createAttributeNS</code>, no namespace
          well-formed checking is done on the target name. Applications
          should invoke <code>Document.normalizeDocument()</code> with
          the parameter "<termref def="parameter-namespaces">namespaces</termref>" set to
          <code>true</code> in order to ensure that the target name is
          namespace well-formed.
	  </p>
        </descr>
      </param>
      <param name="data" type="DOMString" attr="in">
	<descr>
          <p>The data for the node.</p>
        </descr>
      </param>
    </parameters>
    <returns type="ProcessingInstruction">
      <descr>
        <p>The new <code>ProcessingInstruction</code> object.</p>
      </descr>
    </returns>
    <raises>
      <exception name="DOMException">
        <descr>
          <p>INVALID_CHARACTER_ERR: Raised if the specified target is
	    not an XML name according to the XML version in use
	    specified in the <code>Document.xmlVersion</code> attribute.</p>
          <p>NOT_SUPPORTED_ERR: Raised if this document is an HTML
            document.</p>
	</descr>
      </exception>
    </raises>
  </method>

  <!-- ********** -->
  <method name="createAttribute" id="ID-1084891198">
    <descr>
      <p>Creates an <code>Attr</code> of the given name. Note that the
        <code>Attr</code> instance can then be set on an <code>Element</code>
        using the <code>setAttributeNode</code> method. </p>
      <p>To create an attribute with a <termref def="dt-qualifiedname">qualified name</termref> and <termref def="dt-namespaceURI">namespace URI</termref>, use
	the <code>createAttributeNS</code> method.</p>
    </descr>
    <parameters>
      <param name="name" type="DOMString" attr="in">
	<descr>
          <p>The name of the attribute.</p>
        </descr>
      </param>
    </parameters>
    <returns type="Attr">
      <descr>
        <p>A new <code>Attr</code> object with the <code>nodeName</code>
          attribute set to <code>name</code>, and <code>localName</code>,
          <code>prefix</code>, and <code>namespaceURI</code> set to
          <code>null</code>. The value of the attribute is the empty
          string.</p>
      </descr>
    </returns>
    <raises>
      <exception name="DOMException">
        <descr>
          <p>INVALID_CHARACTER_ERR: Raised if the specified name is not
	    an XML name according to the XML version in use
	    specified in the <code>Document.xmlVersion</code> attribute.</p>
        </descr>
      </exception>
    </raises>
  </method>

  <method name="createEntityReference" id="ID-392B75AE">
    <descr>
      <p>Creates an <code>EntityReference</code> object. In addition, if the
        referenced entity is known, the child list of the
        <code>EntityReference</code> node is made the same as that of the
        corresponding <code>Entity</code> node.</p>
      <note>
        <p>If any descendant of the <code>Entity</code> node has an unbound
          <termref def="dt-namespaceprefix">namespace prefix</termref>, the
          corresponding descendant of the created <code>EntityReference</code>
          node is also unbound; (its <code>namespaceURI</code> is
          <code>null</code>). The DOM Level 2 and 3 do not support any mechanism to
          resolve namespace prefixes in this case.</p>
      </note>
    </descr>
    <parameters>
      <param name="name" type="DOMString" attr="in">
	<descr>
          <p>The name of the entity to reference.</p>
          <p>Unlike <code>Document.createElementNS</code> or
          <code>Document.createAttributeNS</code>, no namespace
          well-formed checking is done on the entity name. Applications
          should invoke <code>Document.normalizeDocument()</code> with
          the parameter "<termref def="parameter-namespaces">namespaces</termref>" set to
          <code>true</code> in order to ensure that the entity name is
          namespace well-formed.
	  </p>
        </descr>
      </param>
    </parameters>
    <returns type="EntityReference">
      <descr><p>The new <code>EntityReference</code> object.</p></descr>
    </returns>
    <raises>
      <exception name="DOMException">
	<descr>
          <p>INVALID_CHARACTER_ERR: Raised if the specified name is not
	    an XML name according to the XML version in use
	    specified in the <code>Document.xmlVersion</code> attribute.</p>
          <p>NOT_SUPPORTED_ERR: Raised if this document is an HTML
            document.</p>
	</descr>
      </exception>
    </raises>
  </method>

  <!-- ********** -->
  <method name="getElementsByTagName" id="ID-A6C9094">
    <descr>
      <p>Returns a <code>NodeList</code> of all the
	<code>Elements</code> in <termref def="dt-document-order">document
          order</termref> with a given tag name and are contained in the
	document.</p>
    </descr>
    <parameters>
      <param name="tagname" type="DOMString" attr="in">
	<descr>
          <p>
	    The name of the tag to match on. The special value "*"
	    matches all tags. For XML, the <code>tagname</code>
	    parameter is case-sensitive, otherwise it depends on the
	    case-sensitivity of the markup language in use.
	  </p>
        </descr>
      </param>
    </parameters>
    <returns type="NodeList">
      <descr>
        <p>A new <code>NodeList</code> object containing all the matched
          <code>Elements</code>.</p>
      </descr>
    </returns>
    <raises>
      <!-- Throws no exceptions -->
    </raises>
  </method>

  <!-- ****** DOM Level 2 additions ****** -->
  <method name="importNode" id="Core-Document-importNode" since="DOM Level 2">
    <descr>
      <p>Imports a node from another document to this document, without
      altering or removing the source node from the original document;
      this method creates a new copy of the source node.  The returned
      node has no parent; (<code>parentNode</code> is
      <code>null</code>).</p>

      <p>For all nodes, importing a node creates a node object owned by the
	importing document, with attribute values identical to the source
	node's <code>nodeName</code> and <code>nodeType</code>, plus the
	attributes related to namespaces (<code>prefix</code>,
	<code>localName</code>, and <code>namespaceURI</code>). As in the
	<code>cloneNode</code> operation, the source node is not altered. User
        data associated to the imported node is not carried over. However,
        if any <code>UserDataHandlers</code> has been specified along with the
        associated data these handlers will be called with the appropriate
        parameters before this method returns.</p>

      <p>Additional information is copied as appropriate to the
        <code>nodeType</code>, attempting to mirror the behavior expected if a
        fragment of XML or HTML source was copied from one document to another,
        recognizing that the two documents may have different DTDs in the XML
        case. The following list describes the specifics for each type of node.

	<glist>
	  <gitem>
	    <label>ATTRIBUTE_NODE</label>

	    <def>
              <p>The <code>ownerElement</code> attribute is set to
                <code>null</code> and the <code>specified</code> flag is set to
		<code>true</code> on the generated <code>Attr</code>. The
		<termref def="dt-descendant">descendants</termref> of the
                source <code>Attr</code> are recursively imported and the
                resulting nodes reassembled to form the corresponding
                subtree.</p>
	      <p>Note that the <code>deep</code> parameter has no effect on 
		<code>Attr</code> nodes; they always carry their children with
		them when imported.</p>
	    </def>
	  </gitem>
	  <gitem>
	    <label>DOCUMENT_FRAGMENT_NODE</label>
	    <def>
              <p>If the <code>deep</code> option was set to
                <code>true</code>, the
                <termref def="dt-descendant">descendants</termref> of the
                source <code>DocumentFragment</code> are recursively imported
                and the resulting nodes reassembled under the imported
                <code>DocumentFragment</code> to form the corresponding
                subtree. Otherwise, this simply generates an empty
                <code>DocumentFragment</code>.</p>
	    </def>
	  </gitem>
	  <gitem>
	    <label>DOCUMENT_NODE</label>
	    <def>
              <p><code>Document</code> nodes cannot be imported.</p>
	    </def>
	  </gitem>
	  <gitem>
	    <label>DOCUMENT_TYPE_NODE</label>
	    <def>
              <p><code>DocumentType</code> nodes cannot be imported.</p>
	    </def>
	  </gitem>
	  <gitem>
	    <label>ELEMENT_NODE</label>
	    <def>
              <p><emph>Specified</emph> attribute nodes of the source element
                are imported, and the generated <code>Attr</code> nodes are
                attached to the generated <code>Element</code>. Default
                attributes are <emph>not</emph> copied, though if the document
                being imported into defines default attributes for this element
                name, those are assigned. If the <code>importNode</code>
                <code>deep</code> parameter was set to <code>true</code>, the
                <termref def="dt-descendant">descendants</termref> of the
                source element are recursively imported and the resulting nodes
                reassembled to form the corresponding subtree.</p>
	    </def>
	  </gitem>
	  <gitem>
	    <label>ENTITY_NODE</label>
	    <def>
              <p><code>Entity</code> nodes can be imported, however in the
		current release of the DOM the <code>DocumentType</code> is
		readonly. Ability to add these imported nodes to a
		<code>DocumentType</code> will be considered for addition to a
		future release of the DOM.</p>
	      <p>On import, the <code>publicId</code>, <code>systemId</code>,
		and <code>notationName</code> attributes are copied. If a
		<code>deep</code> import is requested, the
                <termref def="dt-descendant">descendants</termref> of the
		the source <code>Entity</code> are recursively imported and the
		resulting nodes reassembled to form the corresponding
		subtree.</p>
	    </def>
	  </gitem>
	  <gitem>
	    <label>ENTITY_REFERENCE_NODE</label>
	    <def>
              <p>Only the <code>EntityReference</code> itself is copied, even
                if a <code>deep</code> import is requested, since the source
                and destination documents might have defined the entity
                differently. If the document being imported into provides a
                definition for this entity name, its value is assigned.</p>
	    </def>
	  </gitem>
	  <gitem>
	    <label>NOTATION_NODE</label>
	    <def>
              <p><code>Notation</code> nodes can be imported, however in the
		current release of the DOM the <code>DocumentType</code> is
		readonly. Ability to add these imported nodes to a
		<code>DocumentType</code> will be considered for addition to a
		future release of the DOM.</p>
	      <p>On import, the <code>publicId</code> and
		<code>systemId</code> attributes are copied.</p>
	      <p>Note that the <code>deep</code> parameter has no effect on 
		this type of nodes since they cannot have any children.</p>
	    </def>
	  </gitem>
	  <gitem>
	    <label>PROCESSING_INSTRUCTION_NODE</label>
	    <def>
              <p>The imported node copies its <code>target</code> and
                <code>data</code> values from those of the source node.</p>
	      <p>Note that the <code>deep</code> parameter has no effect on 
		this type of nodes since they cannot have any children.</p>
	    </def>
	  </gitem>
	  <gitem>
	    <label>TEXT_NODE, CDATA_SECTION_NODE, COMMENT_NODE</label>
	    <def>
              <p>These three types of nodes inheriting from
                <code>CharacterData</code> copy their <code>data</code> and
		<code>length</code> attributes from those of the source
		node.</p>
	      <p>Note that the <code>deep</code> parameter has no effect on 
		these types of nodes since they cannot have any children.</p>
	    </def>
	  </gitem>
	</glist>
      </p>
    </descr>
    <parameters>
      <param name="importedNode" type="Node" attr="in">
	<descr>
          <p>The node to import.</p>
        </descr>
      </param>
      <param name="deep" type="boolean" attr="in">
	<descr>
          <p>If <code>true</code>, recursively import the subtree under the
            specified node; if <code>false</code>, import only the node itself,
            as explained above. This has no effect on nodes that cannot have
            any children, and on <code>Attr</code>, and
            <code>EntityReference</code> nodes.</p>
	</descr>
      </param>
    </parameters>
    <returns type="Node">
      <descr>
        <p>The imported node that belongs to this <code>Document</code>.</p>
      </descr>
    </returns>
    <raises>
      <exception name="DOMException" version="DOM Level 3">
	<descr>
          <p>NOT_SUPPORTED_ERR: Raised if the type of node being imported
	    is not supported.</p>
          <p>INVALID_CHARACTER_ERR: Raised if one of the imported names is
	    not an XML name according to the XML version in use
	    specified in the <code>Document.xmlVersion</code> attribute. This may happen when importing an XML 1.1
            <bibref role="informative" ref="XML11"/> element into an XML 1.0 document, for
              instance.</p>
        </descr>
      </exception>
    </raises>
  </method>

  <method name="createElementNS" id="ID-DocCrElNS" since="DOM Level 2">
    <descr>
      <p>Creates an element of the given <termref def="dt-qualifiedname">qualified name</termref> and <termref def="dt-namespaceURI">namespace URI</termref>.</p>
      <p>Per <bibref ref="Namespaces"/>, applications must use the value <code>null</code>
      as the namespaceURI parameter for methods if they wish to have no
      namespace.</p>
    </descr>
    <parameters>
      <param name="namespaceURI" type="DOMString" attr="in">
	<descr>
          <p>The <termref def="dt-namespaceURI">namespace URI</termref> of the
            element to create.</p>
	</descr>
      </param>
      <param name="qualifiedName" type="DOMString" attr="in">
	<descr>
          <p>The <termref def="dt-qualifiedname">qualified name</termref> of
            the element type to instantiate.</p>
	</descr>
      </param>
    </parameters>
    <returns type="Element">
      <descr>
        <p>A new <code>Element</code> object with the following attributes:</p>
	<table cellpadding="3" summary="Layout table: the first cell the name property,                the second cell contains his initial value">
	  <tbody>
	    <tr><th rowspan="1" colspan="1">Attribute</th><th rowspan="1" colspan="1">Value</th></tr>
	    <tr><td rowspan="1" colspan="1"><code>Node.nodeName</code></td>
	      <td rowspan="1" colspan="1"><code>qualifiedName</code></td>
	    </tr>
	    <tr><td rowspan="1" colspan="1"><code>Node.namespaceURI</code></td>
	      <td rowspan="1" colspan="1"><code>namespaceURI</code></td></tr>
	    <tr><td rowspan="1" colspan="1"><code>Node.prefix</code></td><td rowspan="1" colspan="1">prefix, extracted from
		<code>qualifiedName</code>, or <code>null</code> if there is no
		prefix</td></tr>
	    <tr><td rowspan="1" colspan="1"><code>Node.localName</code></td>
              <td rowspan="1" colspan="1"><termref def="dt-localname">local name</termref>, extracted
                from <code>qualifiedName</code></td></tr>
	    <tr><td rowspan="1" colspan="1"><code>Element.tagName</code></td>
	      <td rowspan="1" colspan="1"><code>qualifiedName</code></td>
	    </tr>
	  </tbody>
	</table>
      </descr>
    </returns>
    <raises>
      <exception name="DOMException">
	<descr>
          <p>INVALID_CHARACTER_ERR: Raised if the specified <code>qualifiedName</code>
	    is not an XML name according to the XML version in use
	    specified in the <code>Document.xmlVersion</code> attribute.</p>
	  <p>NAMESPACE_ERR: Raised if the <code>qualifiedName</code> is
            a malformed <termref def="dt-qualifiedname">qualified name</termref>, if the
            <code>qualifiedName</code> has a prefix and the
            <code>namespaceURI</code> is <code>null</code>, or if the
            <code>qualifiedName</code> has a prefix that is "xml" and the
            <code>namespaceURI</code> is different from
            "<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/XML/1998/namespace" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/XML/1998/namespace</loc>"
            <bibref ref="Namespaces"/>, or if the
            <code>qualifiedName</code> or its prefix is "xmlns" and the
            <code>namespaceURI</code> is different from
            "<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/2000/xmlns/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/2000/xmlns/</loc>", or if the
            <code>namespaceURI</code> is
            "<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/2000/xmlns/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/2000/xmlns/</loc>" and neither the
            <code>qualifiedName</code> nor its prefix is "xmlns".</p>
          <p>NOT_SUPPORTED_ERR: Always thrown if the current document does not
            support the <code>"XML"</code> feature, since namespaces were
            defined by XML.</p>
	</descr>
      </exception>
    </raises>
  </method>

  <method name="createAttributeNS" id="ID-DocCrAttrNS" since="DOM Level 2">
    <descr>
      <p>Creates an attribute of the given <termref def="dt-qualifiedname">qualified name</termref> and <termref def="dt-namespaceURI">namespace
        URI</termref>.</p>
      <p>Per <bibref ref="Namespaces"/>, applications must use the value <code>null</code>
      as the <code>namespaceURI</code> parameter for methods if they wish to have no
      namespace.</p>
    </descr>
    <parameters>
      <param name="namespaceURI" type="DOMString" attr="in">
	<descr>
          <p>The <termref def="dt-namespaceURI">namespace URI</termref> of the
            attribute to create.</p>
	</descr>
      </param>
      <param name="qualifiedName" type="DOMString" attr="in">
	<descr>
          <p>The <termref def="dt-qualifiedname">qualified name</termref> of
            the attribute to instantiate.</p>
	</descr>
      </param>
    </parameters>
    <returns type="Attr">
      <descr>
        <p>A new <code>Attr</code> object with the following attributes:</p>
	<table cellpadding="3" summary="Layout table: the first cell the name property,                the second cell contains his initial value">
	  <tbody>
	    <tr><th rowspan="1" colspan="1">Attribute</th><th rowspan="1" colspan="1">Value</th></tr>
	    <tr><td rowspan="1" colspan="1"><code>Node.nodeName</code></td><td rowspan="1" colspan="1">qualifiedName</td>
	    </tr>
	    <tr><td rowspan="1" colspan="1"><code>Node.namespaceURI</code></td>
	      <td rowspan="1" colspan="1"><code>namespaceURI</code></td></tr>
	    <tr><td rowspan="1" colspan="1"><code>Node.prefix</code></td><td rowspan="1" colspan="1">prefix, extracted from
		<code>qualifiedName</code>, or <code>null</code> if there is no
		prefix</td></tr>
	    <tr><td rowspan="1" colspan="1"><code>Node.localName</code></td>
              <td rowspan="1" colspan="1"><termref def="dt-localname">local name</termref>, extracted
                from <code>qualifiedName</code></td></tr>
	    <tr><td rowspan="1" colspan="1"><code>Attr.name</code></td>
	      <td rowspan="1" colspan="1"><code>qualifiedName</code></td></tr>
	    <tr><td rowspan="1" colspan="1"><code>Node.nodeValue</code></td>
	      <td rowspan="1" colspan="1">the empty string</td></tr>
	  </tbody>
	</table>
      </descr>
    </returns>
    <raises>
      <exception name="DOMException">
	<descr>
          <p>INVALID_CHARACTER_ERR: Raised if the specified <code>qualifiedName</code>
	    is not an XML name according to the XML version in use
	    specified in the <code>Document.xmlVersion</code> attribute.</p>
	  <p>NAMESPACE_ERR: Raised if the <code>qualifiedName</code> is
            a malformed <termref def="dt-qualifiedname">qualified name</termref>, if the
            <code>qualifiedName</code> has a prefix and the
            <code>namespaceURI</code> is <code>null</code>, if the
            <code>qualifiedName</code> has a prefix that is "xml" and the
            <code>namespaceURI</code> is different from
            "<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/XML/1998/namespace" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/XML/1998/namespace</loc>", if the
            <code>qualifiedName</code> or its prefix is "xmlns" and the
            <code>namespaceURI</code> is different from
            "<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/2000/xmlns/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/2000/xmlns/</loc>", or if the
            <code>namespaceURI</code> is
            "<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/2000/xmlns/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/2000/xmlns/</loc>" and neither the
            <code>qualifiedName</code> nor its prefix is "xmlns".</p>
          <p>NOT_SUPPORTED_ERR: Always thrown if the current document does not
            support the <code>"XML"</code> feature, since namespaces were
            defined by XML.</p>
	</descr>
      </exception>
    </raises>
  </method>

  <method name="getElementsByTagNameNS" id="ID-getElBTNNS" since="DOM Level 2">
    <descr>
      <p>Returns a <code>NodeList</code> of all the <code>Elements</code> with
        a given <termref def="dt-localname">local name</termref> and <termref def="dt-namespaceURI">namespace
        URI</termref> in <termref def="dt-document-order">document order</termref>.</p>
    </descr>
    <parameters>
      <param name="namespaceURI" type="DOMString" attr="in">
	<descr>
          <p>The <termref def="dt-namespaceURI">namespace URI</termref> of the
            elements to match on. The special value <code>"*"</code> matches all
            namespaces.</p>
	</descr>
      </param>
      <param name="localName" type="DOMString" attr="in">
	<descr>
          <p>The <termref def="dt-localname">local name</termref> of the
	    elements to match on. The special value "*" matches all local
	    names.</p>
	</descr>
      </param>
    </parameters>
    <returns type="NodeList">
      <descr>
        <p>A new <code>NodeList</code> object containing all the matched
	  <code>Elements</code>.</p>
      </descr>
    </returns>
    <raises>
      <!-- Throws no exceptions -->
    </raises>
  </method>

  <method name="getElementById" id="ID-getElBId" since="DOM Level 2">
    <descr>
      <p>Returns the <code>Element</code> that has an ID attribute with the
        given value. If no such element exists, this returns <code>null</code>.
        If more than one element has an ID attribute with that value, what
        is returned is undefined.
      </p>
      <p>
	The DOM implementation is expected to use the attribute
	<code>Attr.isId</code> to determine if an attribute is of type
	ID.
      </p>
        <note>
          <p>Attributes with the name "ID" or "id" are not of type ID unless
            so defined.</p>
        </note>
    </descr>
    <parameters>
      <param name="elementId" type="DOMString" attr="in">
	<descr>
          <p>The unique <code>id</code> value for an element.</p>
        </descr>
      </param>
    </parameters>
    <returns type="Element">
      <descr>
        <p>The matching element or <code>null</code> if there is none.</p>
      </descr>
    </returns>
    <raises>
      <!-- Throws no exceptions -->
    </raises>
  </method>

  <!-- ****** DOM Level 3 additions ****** -->
  <attribute readonly="yes" type="DOMString" name="inputEncoding" id="Document3-inputEncoding" since="DOM Level 3">
    <descr>
      <p>An attribute specifying the encoding used for this
	document at the time of the parsing. This is
        <code>null</code> when it is not known, such as when the
	<code>Document</code> was created in memory.</p>
    </descr>
  </attribute>

  <attribute readonly="yes" type="DOMString" name="xmlEncoding" id="Document3-encoding" since="DOM Level 3">
    <descr>
      <p>An attribute specifying, as part of the <xspecref xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/2004/REC-xml-20040204#NT-XMLDecl" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">XML declaration</xspecref>, the
      encoding of this document. This is <code>null</code> when
      unspecified or when it is not known, such as when the
      <code>Document</code> was created in memory.</p>
    </descr>
  </attribute>

  <attribute readonly="no" type="boolean" name="xmlStandalone" id="Document3-standalone" since="DOM Level 3">
    <descr>
      <p>An attribute specifying, as part of the <xspecref xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/2004/REC-xml-20040204#NT-XMLDecl" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">XML declaration</xspecref>, whether this
        document is standalone. This is <code>false</code> when
	unspecified.</p>
      <note>
	<p>
	  No verification is done on the value when setting this
	  attribute. Applications should use
	  <code>Document.normalizeDocument()</code> with the "<termref def="parameter-validate">validate</termref>" parameter to
	  verify if the value matches the <xspecref xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/2004/REC-xml-20040204#sec-rmd" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">validity constraint for standalone
	    document declaration</xspecref> as defined in <bibref ref="XML"/>.
	</p>
      </note>
    </descr>
    <setraises> 
      <exception name="DOMException">	
        <descr>
          <p>
	    NOT_SUPPORTED_ERR: Raised if this document does not support the
	    "XML" feature.
	  </p>
        </descr> 
      </exception> 
    </setraises> 
  </attribute>

  <attribute readonly="no" type="DOMString" name="xmlVersion" id="Document3-version" since="DOM Level 3">
    <descr>
      <p>
	An attribute specifying, as part of the <xspecref xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/2004/REC-xml-20040204#NT-XMLDecl" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">XML declaration</xspecref>, the
	version number of this document. If there is no declaration and
	if this document supports the "XML" feature, the value is
	<code>"1.0"</code>. If this document does not support the "XML"
	feature, the value is always <code>null</code>. Changing this
	attribute will affect methods that check for invalid characters
	in XML names. Application should invoke
	<code>Document.normalizeDocument()</code> in order to check for
	invalid characters in the <code>Node</code>s that are already
	part of this <code>Document</code>.
      </p>
      <p>
	DOM applications may use the
	<code>DOMImplementation.hasFeature(feature, version)</code>
	method with parameter values "XMLVersion" and "1.0"
	(respectively) to determine if an implementation supports
	<bibref ref="XML"/>. DOM applications may use the same method
	with parameter values "XMLVersion" and "1.1" (respectively) to
	determine if an implementation supports <bibref ref="XML11"/>. In both cases, in order to support XML, an
	implementation must also support the "XML" feature defined in
	this specification. <code>Document</code> objects supporting a
	version of the "XMLVersion" feature must not raise a
	<code>NOT_SUPPORTED_ERR</code> exception for the same version
	number when using <code>Document.xmlVersion</code>.
      </p>
    </descr>
    <setraises> 
      <exception name="DOMException">	
        <descr>
          <p>
	    NOT_SUPPORTED_ERR: Raised if the version is set to a value
	    that is not supported by this <code>Document</code> or if
	    this document does not support the "XML" feature.
	  </p>
        </descr> 
      </exception> 
    </setraises> 
  </attribute>

  <attribute readonly="no" type="boolean" name="strictErrorChecking" id="Document3-strictErrorChecking" since="DOM Level 3">
    <descr>
      <p>An attribute specifying whether error checking is enforced or
      not. When set to <code>false</code>, the implementation is free to
      not test every possible error case normally defined on DOM
      operations, and not raise any <code>DOMException</code> on DOM
      operations or report errors while using
      <code>Document.normalizeDocument()</code>. In case of error, the
      behavior is undefined. This attribute is <code>true</code> by
      default.</p>
    </descr>
  </attribute>

  <attribute name="documentURI" id="Document3-documentURI" type="DOMString" readonly="no" since="DOM Level 3">
    <descr>
      <p>
	The location of the document or <code>null</code> if undefined
	or if the <code>Document</code> was created using
	<code>DOMImplementation.createDocument</code>. No lexical
	checking is performed when setting this attribute; this could
	result in a <code>null</code> value returned when using
	<code>Node.baseURI</code>.
      </p>
      <p>
	Beware that when the <code>Document</code> supports the feature
	"HTML" <bibref role="informative" ref="DOM2HTML"/>, the href
	attribute of the HTML BASE element takes precedence over this
	attribute when computing <code>Node.baseURI</code>.
      </p>
    </descr>
  </attribute>

  <method name="adoptNode" id="Document3-adoptNode" since="DOM Level 3">
    <descr>
      <p>
	Attempts to adopt a node from another document to this
	document. If supported, it changes the
	<code>ownerDocument</code> of the source node, its children, as
	well as the attached attribute nodes if there are any. If the
	source node has a parent it is first removed from the child list
	of its parent. This effectively allows moving a subtree from one
	document to another (unlike <code>importNode()</code> which
	create a copy of the source node instead of moving it). When it
	fails, applications should use
	<code>Document.importNode()</code> instead. Note that if the
	adopted node is already part of this document (i.e. the source
	and target document are the same), this method still has the
	effect of removing the source node from the child list of its
	parent, if any. The following list describes the specifics for
	each type of node.
	<glist>
	  <gitem>
	    <label>ATTRIBUTE_NODE</label>
	    <def>
              <p>The <code>ownerElement</code> attribute is set to
                <code>null</code> and the <code>specified</code> flag is set to
		<code>true</code> on the adopted <code>Attr</code>. The
		descendants of the source <code>Attr</code> are recursively
		adopted.</p>
	    </def>
	  </gitem>
	  <gitem>
	    <label>DOCUMENT_FRAGMENT_NODE</label>
	    <def>
              <p>The descendants of the source node are recursively
                adopted.</p>
	    </def>
	  </gitem>
	  <gitem>
	    <label>DOCUMENT_NODE</label>
	    <def>
              <p><code>Document</code> nodes cannot be adopted.</p>
	    </def>
	  </gitem>
	  <gitem>
	    <label>DOCUMENT_TYPE_NODE</label>
	    <def>
              <p><code>DocumentType</code> nodes cannot be adopted.</p>
	    </def>
	  </gitem>
	  <gitem>
	    <label>ELEMENT_NODE</label>
	    <def>
              <p><emph>Specified</emph> attribute nodes of the source element
                are adopted. Default attributes are discarded, though if
		the document being adopted into defines default
		attributes for this element name, those are
		assigned. The descendants of the source element are
		recursively adopted.</p>
	    </def>
	  </gitem>
	  <gitem>
	    <label>ENTITY_NODE</label>
	    <def>
              <p><code>Entity</code> nodes cannot be adopted.</p>
	    </def>
	  </gitem>
	  <gitem>
	    <label>ENTITY_REFERENCE_NODE</label>
	    <def>
              <p>Only the <code>EntityReference</code> node itself is adopted,
                the descendants are discarded, since the source and destination
                documents might have defined the entity differently. If the
                document being imported into provides a definition for this
                entity name, its value is assigned.</p>
	    </def>
	  </gitem>
	  <gitem>
	    <label>NOTATION_NODE</label>
	    <def>
              <p><code>Notation</code> nodes cannot be adopted.</p>
	    </def>
	  </gitem>
	  <gitem>
	    <label>PROCESSING_INSTRUCTION_NODE, TEXT_NODE, CDATA_SECTION_NODE,
              COMMENT_NODE</label>
	    <def>
              <p>These nodes can all be adopted. No specifics.</p>
	    </def>
	  </gitem>
	</glist>
      </p>
      <note>
	<p>
	  Since it does not create new nodes unlike the
	  <code>Document.importNode()</code> method, this method does
	  not raise an <code>INVALID_CHARACTER_ERR</code> exception, and
	  applications should use the
	  <code>Document.normalizeDocument()</code> method to check if
	  an imported name is not an XML name according to the
	  XML version in use.
	</p>
      </note>
    </descr>
    <parameters>
      <param attr="in" type="Node" name="source">
        <descr>
          <p>The node to move into this document.</p>
        </descr>
      </param>
    </parameters>
    <returns type="Node">
      <descr>
        <p>The adopted node, or <code>null</code> if this operation fails, such
          as when the source node comes from a different implementation.</p>
      </descr>
    </returns>
    <raises>
      <exception name="DOMException">
        <descr>
          <p>NOT_SUPPORTED_ERR: Raised if the source node is of type
            <code>DOCUMENT</code>, <code>DOCUMENT_TYPE</code>.</p>
          <p>NO_MODIFICATION_ALLOWED_ERR: Raised when the source node is
            readonly.</p>
        </descr>
      </exception>
    </raises>
  </method>

  <attribute readonly="yes" type="DOMConfiguration" name="domConfig" id="Document3-domConfig" since="DOM Level 3">
    <descr>
      <p>
	The configuration used when
	<code>Document.normalizeDocument()</code> is invoked.
      </p>
    </descr>
  </attribute>

  <method name="normalizeDocument" id="Document3-normalizeDocument" since="DOM Level 3">
    <descr>
      <p>
	This method acts as if the document was going through a save and
	load cycle, putting the document in a "normal" form. As a
	consequence, this method updates the replacement tree of
	<code>EntityReference</code> nodes and normalizes
	<code>Text</code> nodes, as defined in the method
	<code>Node.normalize()</code>.
      </p>
      <p>
	Otherwise, the actual result depends on the features being set
	on the <code>Document.domConfig</code> object and governing what
	operations actually take place. Noticeably this method could
	also make the document <termref def="dt-namespace-well-formed">namespace well-formed</termref>
	according to the algorithm described in <specref ref="normalizeDocumentAlgo"/>, check the character
	normalization, remove the <code>CDATASection</code> nodes,
	etc. See <code>DOMConfiguration</code> for details.
      </p>
      <eg role="code" xml:space="preserve">// Keep in the document the information defined
// in the XML Information Set (Java example)
DOMConfiguration docConfig = myDocument.getDomConfig();
docConfig.setParameter("infoset", Boolean.TRUE);
myDocument.normalizeDocument();</eg>
      <p>Mutation events, when supported, are generated to reflect the changes
        occurring on the document.</p>
      <p>
	If errors occur during the invocation of this method, such as an
	attempt to update a <termref def="dt-readonly-node">read-only
	node</termref> or a <code>Node.nodeName</code> contains an
	invalid character according to the XML version in use, errors or
	warnings (<code>DOMError.SEVERITY_ERROR</code> or
	<code>DOMError.SEVERITY_WARNING</code>) will be reported using
	the <code>DOMErrorHandler</code> object associated with the
	"<termref def="parameter-error-handler">error-handler</termref>"
	parameter. Note this method might also report fatal errors
	(<code>DOMError.SEVERITY_FATAL_ERROR</code>) if an
	implementation cannot recover from an error.
      </p>
    </descr>
    <parameters>
      <!-- no params -->
    </parameters>
    <returns type="void">
      <descr><p><!--empty paragraph--></p></descr>
    </returns>
    <raises>
      <!-- no exception -->
    </raises>
  </method>

  <method name="renameNode" id="Document3-renameNode" since="DOM Level 3">
    <descr>
      <p>Rename an existing node of type <code>ELEMENT_NODE</code> or
	<code>ATTRIBUTE_NODE</code>.</p>
      <p>When possible this simply changes the name of the given node,
	otherwise this creates a new node with the specified name and
	replaces the existing node with the new node as described
	below.</p>
      <p>If simply changing the name of the given node is not possible,
	the following operations are performed: 
        a new node is created, any registered event listener is registered on
        the new node, any user data attached to the old node is removed from
        that node, the old node is removed from its parent if it has one, the
        children are moved to the new node, if the renamed node is an
        <code>Element</code> its attributes are moved to the new node,
        the new node is inserted at the position the old node used to have in
        its parent's child nodes list if it has one, the user data that was
        attached to the old node is attached to the new node.</p>
      <p>When the node being renamed is an <code>Element</code> only the
        specified attributes are moved, default attributes originated from the
        DTD are updated according to the new element name. In addition, the
        implementation may update default attributes from other
        schemas. Applications should use
	<code>Document.normalizeDocument()</code> to guarantee these
	attributes are up-to-date.</p>
      <p>When the node being renamed is an <code>Attr</code> that is attached
        to an <code>Element</code>, the node is first removed from the
        <code>Element</code> attributes map. Then, once renamed, either by
        modifying the existing node or creating a new one as described above,
        it is put back.</p>
      <p>In addition,</p>
      <ulist>
	<item>
	  <p>
	    a user data event <code>NODE_RENAMED</code> is fired,
	  </p>
	</item>
	<item>
	  <p>
	    when the implementation supports the feature
	    "MutationNameEvents", each mutation operation involved in
	    this method fires the appropriate event, and in the end the
	    event {<code>http://www.w3.org/2001/xml-events</code>,
	    <code>DOMElementNameChanged</code>} or
	    {<code>http://www.w3.org/2001/xml-events</code>,
	    <code>DOMAttributeNameChanged</code>} is fired.
	  </p>
	</item>
      </ulist>
    </descr>

    <parameters>
      <param name="n" type="Node" attr="in">
        <descr>
          <p>The node to rename.</p>
        </descr>
      </param>
      <param name="namespaceURI" type="DOMString" attr="in">
        <descr>
          <p>The new <termref def="dt-namespaceURI">namespace URI</termref>.</p>
        </descr>
      </param>
      <param name="qualifiedName" type="DOMString" attr="in">
        <descr>
          <p>The new <termref def="dt-qualifiedname">qualified name</termref>.</p>
        </descr>
      </param>
    </parameters>

    <returns type="Node">
      <descr>
        <p>The renamed node. This is either the specified node or the new node
          that was created to replace the specified node.</p>
      </descr>
    </returns>

    <raises>
      <exception name="DOMException">
        <descr>
          <p>NOT_SUPPORTED_ERR: Raised when the type of the specified node is
            neither  <code>ELEMENT_NODE</code> nor
            <code>ATTRIBUTE_NODE</code>, or if the implementation does
	    not support the renaming of the <termref def="dt-document-element">document element</termref>.</p>
          <p>INVALID_CHARACTER_ERR: Raised if the new qualified name is not
            an XML name according to the XML version in use
	    specified in the <code>Document.xmlVersion</code> attribute.</p>
          <p>WRONG_DOCUMENT_ERR: Raised when the specified node was created
            from a different document than this document.</p>
	  <p>NAMESPACE_ERR: Raised if the <code>qualifiedName</code> is a malformed <termref def="dt-qualifiedname">qualified name</termref>, if the
            <code>qualifiedName</code> has a prefix and the
            <code>namespaceURI</code> is <code>null</code>, or if the
            <code>qualifiedName</code> has a prefix that is "xml" and the
            <code>namespaceURI</code> is different from
            "<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/XML/1998/namespace" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/XML/1998/namespace</loc>"
            <bibref ref="Namespaces"/>. Also raised, when the node being
            renamed is an attribute, if the <code>qualifiedName</code>, or
            its prefix, is "xmlns" and the <code>namespaceURI</code> is
            different from "<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/2000/xmlns/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/2000/xmlns/</loc>".</p>
        </descr>
      </exception>
    </raises>
  </method>
</interface>
 
<!-- $Date: 2004/03/15 20:03:11 $ $Revision: 1.81 $ -->
<!--[ Node object description ]-->
<interface name="Node" id="ID-1950641247"> 
  <descr>
    <p>The <code>Node</code> interface is the primary datatype for the entire
      Document Object Model. It represents a single node in the document
      tree. While all objects implementing the <code>Node</code> interface
      expose methods for dealing with children, not all objects implementing
      the <code>Node</code> interface may have children. For example,
      <code>Text</code> nodes may not have children, and adding children to
      such nodes results in a <code>DOMException</code> being raised.</p>
    <p>The attributes <code>nodeName</code>, <code>nodeValue</code> and
      <code>attributes</code> are included as a mechanism to get at node
      information without casting down to the specific derived interface. In
      cases where there is no obvious mapping of these attributes for a
      specific <code>nodeType</code> (e.g., <code>nodeValue</code> for an
      <code>Element</code> or <code>attributes</code> for a
      <code>Comment</code>), this returns <code>null</code>. Note that the
      specialized interfaces may contain additional and more convenient
      mechanisms to get and set the relevant information.</p>
  </descr> 
  <group id="ID-1841493061" name="NodeType"> 
    <descr>
      <p>An integer indicating which type of node this is.</p> 
      <note>
       <p>Numeric codes up to 200 are reserved to W3C for possible future
          use.</p>
      </note> 
    </descr> 
    <constant id="Node-ELEMENT_NODE" name="ELEMENT_NODE" type="unsigned short" value="1"> 
      <descr>
        <p>The node is an <code>Element</code>.</p>
      </descr> 
    </constant> 
    <constant id="Node-ATTRIBUTE_NODE" name="ATTRIBUTE_NODE" type="unsigned short" value="2"> 
      <descr>
        <p>The node is an <code>Attr</code>.</p>
      </descr> 
    </constant> 
    <constant id="Node-TEXT_NODE" name="TEXT_NODE" type="unsigned short" value="3"> 
      <descr>
        <p>The node is a <code>Text</code> node.</p>
      </descr> 
    </constant> 
    <constant id="Node-CDATA_SECTION_NODE" name="CDATA_SECTION_NODE" type="unsigned short" value="4"> 
      <descr>
        <p>The node is a <code>CDATASection</code>.</p>
      </descr> 
    </constant> 
    <constant id="Node-ENTITY_REFERENCE_NODE" name="ENTITY_REFERENCE_NODE" type="unsigned short" value="5"> 
      <descr>
        <p>The node is an <code>EntityReference</code>.</p>
      </descr> 
    </constant> 
    <constant id="Node-ENTITY_NODE" name="ENTITY_NODE" type="unsigned short" value="6"> 
      <descr>
        <p>The node is an <code>Entity</code>.</p>
      </descr> 
    </constant> 
    <constant id="Node-PROCESSING_INSTRUCTION_NODE" name="PROCESSING_INSTRUCTION_NODE" type="unsigned short" value="7"> 
      <descr>
        <p>The node is a <code>ProcessingInstruction</code>.</p>
      </descr> 
    </constant> 
    <constant id="Node-COMMENT_NODE" name="COMMENT_NODE" type="unsigned short" value="8"> 
      <descr>
        <p>The node is a <code>Comment</code>.</p>
      </descr> 
    </constant> 
    <constant id="Node-DOCUMENT_NODE" name="DOCUMENT_NODE" type="unsigned short" value="9"> 
      <descr>
        <p>The node is a <code>Document</code>.</p>
      </descr> 
    </constant> 
    <constant id="Node-DOCUMENT_TYPE_NODE" name="DOCUMENT_TYPE_NODE" type="unsigned short" value="10"> 
      <descr>
        <p>The node is a <code>DocumentType</code>.</p>
      </descr> 
    </constant> 
    <constant id="Node-DOCUMENT_FRAGMENT_NODE" name="DOCUMENT_FRAGMENT_NODE" type="unsigned short" value="11"> 
      <descr>
        <p>The node is a <code>DocumentFragment</code>.</p>
      </descr> 
    </constant> 
    <constant id="Node-NOTATION_NODE" name="NOTATION_NODE" type="unsigned short" value="12"> 
      <descr>
        <p>The node is a <code>Notation</code>.</p>
      </descr> 
    </constant> 
  </group> 
  <p>The values of <code>nodeName</code>, <code>nodeValue</code>, and
    <code>attributes</code> vary according to the node type as follows:
    <table cellpadding="3" summary="Layout table: the first cell contains the name of the            interface, the second contains the value of the nodeName attribute            for this interface, the third contains the value of the nodeValue            attribute for this interface and the fourth contains the value of            the attributes attribute for this interface" border="1">
      <tbody>	
        <tr> 
          <th rowspan="1" colspan="1">Interface</th> 
          <th rowspan="1" colspan="1">nodeName</th> 
          <th rowspan="1" colspan="1">nodeValue</th> 
          <th rowspan="1" colspan="1">attributes</th>	
        </tr>	
        <tr> 
          <td rowspan="1" colspan="1"><code>Attr</code></td> 
          <td rowspan="1" colspan="1">same as <code>Attr.name</code></td> 
          <td rowspan="1" colspan="1">same as <code>Attr.value</code></td> 
          <td rowspan="1" colspan="1"><code>null</code></td>	
        </tr>	
        <tr> 
          <td rowspan="1" colspan="1"><code>CDATASection</code></td> 
          <td rowspan="1" colspan="1"><code>"#cdata-section"</code></td> 
          <td rowspan="1" colspan="1">same as <code>CharacterData.data</code>, the content of
	    the CDATA Section</td> 
          <td rowspan="1" colspan="1"><code>null</code></td>	
        </tr>	
        <tr> 
          <td rowspan="1" colspan="1"><code>Comment</code></td> 
          <td rowspan="1" colspan="1"><code>"#comment"</code></td> 
          <td rowspan="1" colspan="1">same as <code>CharacterData.data</code>, the content of the comment</td> 
          <td rowspan="1" colspan="1"><code>null</code></td>	
        </tr>	
        <tr> 
          <td rowspan="1" colspan="1"><code>Document</code></td> 
          <td rowspan="1" colspan="1"><code>"#document"</code></td> 
          <td rowspan="1" colspan="1"><code>null</code></td> 
          <td rowspan="1" colspan="1"><code>null</code></td>	
        </tr>	
        <tr> 
          <td rowspan="1" colspan="1"><code>DocumentFragment</code></td> 
          <td rowspan="1" colspan="1"><code>"#document-fragment"</code></td> 
          <td rowspan="1" colspan="1"><code>null</code></td> 
          <td rowspan="1" colspan="1"><code>null</code></td>	
        </tr>	
        <tr> 
          <td rowspan="1" colspan="1"><code>DocumentType</code></td> 
          <td rowspan="1" colspan="1">same as <code>DocumentType.name</code></td> 
          <td rowspan="1" colspan="1"><code>null</code></td> 
          <td rowspan="1" colspan="1"><code>null</code></td>	
        </tr>	
        <tr> 
          <td rowspan="1" colspan="1"><code>Element</code></td> 
          <td rowspan="1" colspan="1">same as <code>Element.tagName</code></td> 
          <td rowspan="1" colspan="1"><code>null</code></td> 
          <td rowspan="1" colspan="1"><code>NamedNodeMap</code></td>	
        </tr>	
        <tr> 
          <td rowspan="1" colspan="1"><code>Entity</code></td> 
          <td rowspan="1" colspan="1">entity name</td> 
          <td rowspan="1" colspan="1"><code>null</code></td> 
          <td rowspan="1" colspan="1"><code>null</code></td>	
        </tr>	
        <tr> 
          <td rowspan="1" colspan="1"><code>EntityReference</code></td> 
          <td rowspan="1" colspan="1">name of entity referenced</td> 
          <td rowspan="1" colspan="1"><code>null</code></td> 
          <td rowspan="1" colspan="1"><code>null</code></td> 
        </tr>	
        <tr> 
          <td rowspan="1" colspan="1"><code>Notation</code></td> 
          <td rowspan="1" colspan="1">notation name</td> 
          <td rowspan="1" colspan="1"><code>null</code></td> 
          <td rowspan="1" colspan="1"><code>null</code></td>	
        </tr>	
        <tr> 
          <td rowspan="1" colspan="1"><code>ProcessingInstruction</code></td> 
          <td rowspan="1" colspan="1">same as <code>ProcessingInstruction.target</code></td> 
          <td rowspan="1" colspan="1">same as <code>ProcessingInstruction.data</code></td> 
          <td rowspan="1" colspan="1"><code>null</code></td>	
        </tr>
        <tr> 
          <td rowspan="1" colspan="1"><code>Text</code></td> 
          <td rowspan="1" colspan="1"><code>"#text"</code></td> 
          <td rowspan="1" colspan="1">same as <code>CharacterData.data</code>, the content of the text node</td> 
          <td rowspan="1" colspan="1"><code>null</code></td>	
        </tr> 
      </tbody> 
    </table>
  </p>

  <attribute type="DOMString" readonly="yes" name="nodeName" id="ID-F68D095"> 
    <descr> 
      <p>The name of this node, depending on its type; see the table above.</p>
    </descr> 
  </attribute> 

  <attribute type="DOMString" name="nodeValue" id="ID-F68D080" readonly="no"> 
    <descr> 
      <p>The value of this node, depending on its type; see the table
        above. When it is defined to be <code>null</code>, setting it has no effect,
	  including if the node is <termref def="dt-readonly-node">read-only</termref>.</p>
    </descr> 
    <setraises> 
      <exception name="DOMException">	
        <descr>
          <p>NO_MODIFICATION_ALLOWED_ERR: Raised when the node is
	    readonly and if it is not defined to be <code>null</code>.</p>
        </descr> 
      </exception> 
    </setraises> 
    <getraises> 
      <exception name="DOMException">	
        <descr>
          <p>DOMSTRING_SIZE_ERR: Raised when it would return more characters
            than fit in a <code>DOMString</code> variable on the implementation
            platform.</p>
        </descr> 
      </exception> 
    </getraises> 
  </attribute> 

  <attribute type="unsigned short" name="nodeType" readonly="yes" id="ID-111237558"> 
    <descr>
      <p>A code representing the type of the underlying object, as defined
        above.</p>
    </descr> 
  </attribute> 

  <attribute type="Node" readonly="yes" name="parentNode" id="ID-1060184317"> 
    <descr>
      <p>The <termref def="dt-parent">parent</termref> of this node. All nodes,
        except <code>Attr</code>, <code>Document</code>,
        <code>DocumentFragment</code>, <code>Entity</code>, and
        <code>Notation</code> may have a parent. However, if a node has just
        been created and not yet added to the tree, or if it has been removed
        from the tree, this is <code>null</code>.
      </p>
    </descr> 
  </attribute> 

  <attribute type="NodeList" readonly="yes" name="childNodes" id="ID-1451460987"> 
    <descr>
      <p>A <code>NodeList</code> that contains all children of this node. If
        there are no children, this is a <code>NodeList</code> containing no
        nodes.</p>
    </descr> 
  </attribute> 

  <attribute readonly="yes" type="Node" name="firstChild" id="ID-169727388"> 
    <descr>
      <p>The first child of this node. If there is no such node, this returns
        <code>null</code>.</p>
    </descr> 
  </attribute> 

  <attribute readonly="yes" type="Node" name="lastChild" id="ID-61AD09FB"> 
    <descr>
      <p>The last child of this node. If there is no such node, this returns
        <code>null</code>.</p>
    </descr> 
  </attribute> 

  <attribute readonly="yes" type="Node" name="previousSibling" id="ID-640FB3C8"> 
    <descr>
      <p>The node immediately preceding this node. If there is no such node,
        this returns <code>null</code>.</p>
    </descr> 
  </attribute> 

  <attribute readonly="yes" type="Node" name="nextSibling" id="ID-6AC54C2F"> 
    <descr>
      <p>The node immediately following this node. If there is no such node,
        this returns <code>null</code>.</p>
    </descr> 
  </attribute> 

  <attribute readonly="yes" type="NamedNodeMap" name="attributes" id="ID-84CF096"> 
    <descr>
      <p>A <code>NamedNodeMap</code> containing the attributes of this node (if
        it is an <code>Element</code>) or <code>null</code> otherwise.</p>
    </descr> 
  </attribute> 

  <attribute readonly="yes" type="Document" name="ownerDocument" id="node-ownerDoc" version="DOM Level 2"> 
    <descr>
      <p>The <code>Document</code> object associated with this node. This is
        also the <code>Document</code> object used to create new nodes. When
        this node is a <code>Document</code> or a <code>DocumentType</code>
        which is not used with any <code>Document</code> yet, this is
        <code>null</code>.</p>
    </descr> 
  </attribute> 

  <method name="insertBefore" id="ID-952280727" version="DOM Level 3"> 
    <descr>
      <p>Inserts the node <code>newChild</code> before the existing child node
        <code>refChild</code>. If <code>refChild</code> is <code>null</code>,
        insert <code>newChild</code> at the end of the list of children.</p>
      <p>If <code>newChild</code> is a <code>DocumentFragment</code> object,
        all of its children are inserted, in the same order, before
        <code>refChild</code>. If the <code>newChild</code> is already in the
        tree, it is first removed.</p>
      <note>
	<p>
	  Inserting a node before itself is implementation dependent.
	</p>
      </note>
    </descr> 
    <parameters> 
      <param name="newChild" type="Node" attr="in">	
        <descr>
          <p>The node to insert.</p>
        </descr> 
      </param> 
      <param name="refChild" type="Node" attr="in">	
        <descr>
          <p>The reference node, i.e., the node before which the new node must
            be inserted.</p>
        </descr> 
      </param> 
    </parameters> 
    <returns type="Node"> 
      <descr>
        <p>The node being inserted.</p>
      </descr> 
    </returns> 
    <raises>
      <exception name="DOMException">	
        <descr>

          <p>HIERARCHY_REQUEST_ERR: Raised if this node is of a type that does
	    not allow children of the type of the <code>newChild</code> node, or
	    if the node to insert is one of this node's <termref def="dt-ancestor">ancestors</termref> or this node itself, or if this
	    node is of type <code>Document</code> and the DOM application
	    attempts to insert a second <code>DocumentType</code> or
	    <code>Element</code> node.</p>
          <p>WRONG_DOCUMENT_ERR: Raised if <code>newChild</code> was created
            from a different document than the one that created this node.</p>
          <p>NO_MODIFICATION_ALLOWED_ERR: Raised if this node is readonly or if
            the parent of the node being inserted is readonly.</p>
          <p>NOT_FOUND_ERR: Raised if <code>refChild</code> is not a child of
            this node.</p>
          <p>NOT_SUPPORTED_ERR: if this node is of type <code>Document</code>,
          this exception might be raised if the DOM implementation doesn't
          support the insertion of a <code>DocumentType</code> or
          <code>Element</code> node.</p>
        </descr> 
      </exception> 
    </raises> 
  </method> 

  <method name="replaceChild" id="ID-785887307" version="DOM Level 3"> 
    <descr>
      <p>Replaces the child node <code>oldChild</code> with
        <code>newChild</code> in the list of children, and returns the
        <code>oldChild</code> node.</p>
      <p>If <code>newChild</code> is a <code>DocumentFragment</code> object,
        <code>oldChild</code> is replaced by all of the
        <code>DocumentFragment</code> children, which are inserted in the same
        order. If the <code>newChild</code> is already in the tree, it is first
        removed.</p>
      <note>
	<p>
	  Replacing a node with itself is implementation dependent.
	</p>
      </note>
    </descr> 
    <parameters> 
      <param name="newChild" type="Node" attr="in">	
        <descr>
          <p>The new node to put in the child list.</p>
        </descr> 
      </param> 
      <param name="oldChild" type="Node" attr="in">	
        <descr>
          <p>The node being replaced in the list.</p>
        </descr> 
      </param> 
    </parameters> 
    <returns type="Node"> 
      <descr>
        <p>The node replaced.</p>
      </descr> 
    </returns> 
    <raises> 
      <exception name="DOMException">	
        <descr>
          <p>HIERARCHY_REQUEST_ERR: Raised if this node is of a type that does
            not allow children of the type of the <code>newChild</code> node,
            or if the node to put in is one of this node's
            <termref def="dt-ancestor">ancestors</termref> or this node
            itself, or if this
	    node is of type <code>Document</code> and the result of the
	    replacement operation would add a second <code>DocumentType</code> or
	    <code>Element</code> on the <code>Document</code> node.</p>
          <p>WRONG_DOCUMENT_ERR: Raised if <code>newChild</code> was created
            from a different document than the one that created this node.</p>
          <p>NO_MODIFICATION_ALLOWED_ERR: Raised if this node or the parent of
            the new node is readonly.</p>
          <p>NOT_FOUND_ERR: Raised if <code>oldChild</code> is not a child of
            this node.</p>
          <p>NOT_SUPPORTED_ERR: if this node is of type <code>Document</code>,
          this exception might be raised if the DOM implementation doesn't
          support the replacement of the <code>DocumentType</code> child or
          <code>Element</code> child.</p>
        </descr> 
      </exception> 
    </raises> 
  </method> 

  <method name="removeChild" id="ID-1734834066" version="DOM Level 3"> 
    <descr>
      <p>Removes the child node indicated by <code>oldChild</code> from the
        list of children, and returns it.</p>
    </descr> 
    <parameters> 
      <param name="oldChild" type="Node" attr="in">	
        <descr>
          <p>The node being removed.</p>
        </descr> 
      </param> 
    </parameters> 
    <returns type="Node"> 
      <descr>
        <p>The node removed.</p>
      </descr> 
    </returns> 
    <raises> 
      <exception name="DOMException"> 
        <descr>
          <p>NO_MODIFICATION_ALLOWED_ERR: Raised if this node is readonly.</p>
          <p>NOT_FOUND_ERR: Raised if <code>oldChild</code> is not a child of
            this node.</p>
          <p>NOT_SUPPORTED_ERR: if this node is of type <code>Document</code>,
          this exception might be raised if the DOM implementation doesn't
          support the removal of the <code>DocumentType</code> child or the
          <code>Element</code> child.</p>
        </descr> 
      </exception> 
    </raises> 
  </method> 

  <method name="appendChild" id="ID-184E7107" version="DOM Level 3"> 
    <descr>
      <p>Adds the node <code>newChild</code> to the end of the list of children
        of this node. If the <code>newChild</code> is already in the tree, it
        is first removed.</p>
    </descr> 
    <parameters> 
      <param name="newChild" type="Node" attr="in">	
        <descr>
          <p>The node to add.</p> 
          <p>If it is a <code>DocumentFragment</code> object, the entire
            contents of the document fragment are moved into the child list of
            this node</p>
        </descr> 
      </param> 
    </parameters> 
    <returns type="Node"> 
      <descr>
        <p>The node added.</p>
      </descr> 
    </returns> 
    <raises> 
      <exception name="DOMException">	
        <descr>
          <p>HIERARCHY_REQUEST_ERR: Raised if this node is of a type that does
            not allow children of the type of the <code>newChild</code> node,
            or if the node to append is one of this node's
            <termref def="dt-ancestor">ancestors</termref> or this node itself, or if this
	    node is of type <code>Document</code> and the DOM application
	    attempts to append a second <code>DocumentType</code> or
	    <code>Element</code> node.</p>
          <p>WRONG_DOCUMENT_ERR: Raised if <code>newChild</code> was created
            from a different document than the one that created this node.</p>
          <p>NO_MODIFICATION_ALLOWED_ERR: Raised if this node is readonly or if
            the previous parent of the node being inserted is readonly.</p>
          <p>NOT_SUPPORTED_ERR: if the <code>newChild</code> node is a
          child of the <code>Document</code> node, this exception might
          be raised if the DOM implementation doesn't support the
          removal of the <code>DocumentType</code> child or
          <code>Element</code> child.</p>
        </descr> 
      </exception> 
    </raises> 
  </method> 

  <method name="hasChildNodes" id="ID-810594187"> 
    <descr>
      <p>Returns whether this node has any children.</p> 
    </descr> 
    <parameters>      <!-- No parameters -->
    </parameters> 
    <returns type="boolean"> 
      <descr>
        <p>Returns <code>true</code> if this node has any children,
          <code>false</code> otherwise.</p>
      </descr> 
    </returns> 
    <raises>      <!-- No exceptions -->
    </raises> 
  </method>

  <method name="cloneNode" id="ID-3A0ED0A4"> 
    <descr>
      <p>Returns a duplicate of this node, i.e., serves as a generic copy
        constructor for nodes. The duplicate node has no parent
        (<code>parentNode</code> is <code>null</code>) and no user data. User
        data associated to the imported node is not carried over. However,
        if any <code>UserDataHandlers</code> has been specified along with the
        associated data these handlers will be called with the appropriate
        parameters before this method returns.</p>
      <p>Cloning an <code>Element</code> copies all attributes and their
        values, including those generated by the XML processor to represent
        defaulted attributes, but this method does not copy any children it
        contains unless it is a deep clone. This includes text contained in an
        the <code>Element</code> since the text is contained in a child
        <code>Text</code> node. Cloning an <code>Attr</code> directly, as
        opposed to be cloned as part of an <code>Element</code> cloning
        operation, returns a specified attribute (<code>specified</code> is
        <code>true</code>). Cloning an <code>Attr</code> always clones its
        children, since they represent its value, no matter whether this is a
        deep clone or not. Cloning an <code>EntityReference</code>
        automatically constructs its subtree if a corresponding
        <code>Entity</code> is available, no matter whether this is a deep
        clone or not. Cloning any other type of node simply returns a copy of
        this node.</p>
      <p>Note that cloning an immutable subtree results in a mutable copy, but
        the children of an <code>EntityReference</code> clone are
        <termref def="dt-readonly-node">readonly</termref>. In addition, clones
        of unspecified <code>Attr</code> nodes are specified. And, cloning
        <code>Document</code>, <code>DocumentType</code>, <code>Entity</code>,
        and <code>Notation</code> nodes is implementation dependent.</p>
    </descr> 
    <parameters> 
      <param name="deep" type="boolean" attr="in">	
        <descr>
          <p>If <code>true</code>, recursively clone the subtree under the
            specified node; if <code>false</code>, clone only the node itself
            (and its attributes, if it is an <code>Element</code>).</p>
        </descr> 
      </param> 
    </parameters> 
    <returns type="Node"> 
      <descr>
        <p>The duplicate node.</p>
      </descr> 
    </returns> 
    <raises>      <!-- No exceptions -->
    </raises> 
  </method>

  <!-- ****** DOM Level 2 additions ****** -->
  <method id="ID-normalize" name="normalize" version="DOM Level 3"> 
    <descr>
      <p>
	Puts all <code>Text</code> nodes in the full depth of the
	sub-tree underneath this <code>Node</code>, including attribute
	nodes, into a "normal" form where only structure (e.g.,
	elements, comments, processing instructions, CDATA sections, and
	entity references) separates <code>Text</code> nodes, i.e.,
	there are neither adjacent <code>Text</code> nodes nor empty
	<code>Text</code> nodes. This can be used to ensure that the DOM
	view of a document is the same as if it were saved and
	re-loaded, and is useful when operations (such as XPointer
	<bibref role="informative" ref="XPointer"/> lookups) that depend
	on a particular document tree structure are to be used. If the
	parameter "<termref def="parameter-normalize-characters">normalize-characters</termref>"
	of the <code>DOMConfiguration</code> object attached to the
	<code>Node.ownerDocument</code> is <code>true</code>, this
	method will also fully normalize the characters of the
	<code>Text</code> nodes.
      </p>
      <note>
        <p>In cases where the document contains <code>CDATASections</code>, the
          normalize operation alone may not be sufficient, since XPointers do
          not differentiate between <code>Text</code> nodes and
          <code>CDATASection</code> nodes.</p>
      </note> 
    </descr> 
    <parameters>      <!-- No parameters -->
    </parameters> 
    <returns type="void"> 
      <descr>
        <p><!--empty paragraph--></p>
      </descr> 
    </returns> 
    <raises>      <!-- No exceptions -->
    </raises> 
  </method> 

  <method name="isSupported" id="Level-2-Core-Node-supports" since="DOM Level 2"> 
    <descr>
      <p>
	Tests whether the DOM implementation implements a specific feature and
        that feature is supported by this node, as specified in <specref ref="DOMFeatures"/>.
      </p> 
    </descr> 
    <parameters> 
      <param name="feature" type="DOMString" attr="in">	
        <descr>
          <p>
	    The name of the feature to test.
	  </p>
        </descr> 
      </param> 
      <param name="version" type="DOMString" attr="in">	
        <descr>
          <p>
	    This is the version number of the feature to test.
	  </p>
        </descr> 
      </param> 
    </parameters> 
    <returns type="boolean"> 
      <descr>
        <p>Returns <code>true</code> if the specified feature is supported on
          this node, <code>false</code> otherwise.</p>
      </descr> 
    </returns> 
    <raises>      <!-- No exceptions -->
    </raises> 
  </method> 

  <attribute readonly="yes" type="DOMString" name="namespaceURI" id="ID-NodeNSname" since="DOM Level 2"> 
    <descr>
      <p>The <termref def="dt-namespaceURI">namespace URI</termref> of this
        node, or <code>null</code> if it is unspecified (see <specref ref="Namespaces-Considerations"/>).</p> 

      <p>This is not a computed value that is the result of a namespace lookup
        based on an examination of the namespace declarations in scope. It is
        merely the namespace URI given at creation time.</p> 

      <p>For nodes of any type other than <code>ELEMENT_NODE</code> and
        <code>ATTRIBUTE_NODE</code> and nodes created with a DOM Level 1
        method, such as <code>Document.createElement()</code>, this is
	always <code>null</code>.</p>
      <note>
        <p>Per the <emph>Namespaces in XML</emph> Specification
          <bibref ref="Namespaces"/> an attribute does not inherit its
            namespace from the element it is attached to. If an attribute is
            not explicitly given a namespace, it simply has no namespace.</p> 
      </note> 
    </descr> 
  </attribute> 

  <attribute type="DOMString" name="prefix" id="ID-NodeNSPrefix" since="DOM Level 2" readonly="no"> 
    <descr>
      <p>The <termref def="dt-namespaceprefix">namespace
      prefix</termref> of this node, or <code>null</code> if it is
      unspecified. When it is defined to be <code>null</code>, setting
      it has no effect, including if the node is <termref def="dt-readonly-node">read-only</termref>.</p>
      
      <p>Note that setting this attribute, when permitted, changes the
        <code>nodeName</code> attribute, which holds the
        <termref def="dt-qualifiedname">qualified name</termref>, as well as
        the <code>tagName</code> and <code>name</code> attributes of the
        <code>Element</code> and <code>Attr</code> interfaces, when
        applicable.</p>
      <p>Setting the prefix to <code>null</code> makes it unspecified, setting
        it to an empty string is implementation dependent.</p>
      <p>Note also that changing the prefix of an attribute that is known to
        have a default value, does not make a new attribute with the default
        value and the original prefix appear, since the
        <code>namespaceURI</code> and <code>localName</code> do not change.</p>
      <p>For nodes of any type other than <code>ELEMENT_NODE</code> and
        <code>ATTRIBUTE_NODE</code> and nodes created with a DOM Level 1
        method, such as <code>createElement</code> from the
        <code>Document</code> interface, this is always <code>null</code>.</p>
    </descr> 
    <setraises> 
      <exception name="DOMException">	
        <descr>
          <p>INVALID_CHARACTER_ERR: Raised if the specified
            prefix contains an illegal character according to the XML version in use
	    specified in the <code>Document.xmlVersion</code> attribute.</p> 
          <p>NO_MODIFICATION_ALLOWED_ERR: Raised if this node is
            readonly.</p>
          <p>NAMESPACE_ERR: Raised if the specified
            <code>prefix</code> is malformed per the Namespaces in XML
            specification, if the <code>namespaceURI</code> of this node is
            <code>null</code>, if the specified prefix is "xml" and the
            <code>namespaceURI</code> of this node is different from
            "<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/XML/1998/namespace" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/XML/1998/namespace</loc>", if this node is an attribute
            and the specified prefix is "xmlns" and the
            <code>namespaceURI</code> of this node is different from
            "<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/2000/xmlns/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/2000/xmlns/</loc>", or if this node is an
            attribute and the <code>qualifiedName</code> of this node is
            "xmlns" <bibref ref="Namespaces"/>.</p>
        </descr> 
      </exception> 
    </setraises> 
  </attribute> 

  <attribute readonly="yes" type="DOMString" name="localName" id="ID-NodeNSLocalN" since="DOM Level 2"> 
    <descr>
      <p>Returns the local part of the
        <termref def="dt-qualifiedname">qualified name</termref> of this
        node.</p>

      <p>For nodes of any type other than <code>ELEMENT_NODE</code> and
        <code>ATTRIBUTE_NODE</code> and nodes created with a DOM Level 1
        method, such as <code>Document.createElement()</code>,
	this is always <code>null</code>.</p>
    </descr> 
  </attribute> 

  <method name="hasAttributes" id="ID-NodeHasAttrs" since="DOM Level 2"> 
    <descr>
      <p>Returns whether this node (if it is an element) has any
        attributes.</p> 
    </descr> 
    <parameters>      <!-- No parameters -->
    </parameters> 
    <returns type="boolean"> 
      <descr>
        <p>Returns <code>true</code> if this node has any attributes,
          <code>false</code> otherwise.</p>
      </descr> 
    </returns> 
    <raises>      <!-- No exceptions -->
    </raises> 
  </method>

  <!-- ****** DOM Level 3 additions ****** -->
  <attribute readonly="yes" type="DOMString" name="baseURI" id="Node3-baseURI" since="DOM Level 3">
    <descr>
      <p>The absolute base URI of this node or <code>null</code> if the
      implementation wasn't able to obtain an absolute URI. This value
      is computed as described in <specref ref="baseURIs-Considerations"/>.  However, when the
      <code>Document</code> supports the feature "HTML" <bibref role="informative" ref="DOM2HTML"/>, the base URI is computed
      using first the value of the href attribute of the HTML BASE
      element if any, and the value of the <code>documentURI</code>
      attribute from the <code>Document</code> interface otherwise.</p>

    </descr>
  </attribute>

  <group id="DocumentPosition" name="DocumentPosition" since="DOM Level 3">
    <descr>
      <p>A bitmask indicating the relative document position of a node with
        respect to another node.</p>

      <p>If the two nodes being compared are the same node, then no
        flags are set on the return.</p>

      <p>Otherwise, the order of two nodes is determined by looking
        for common containers -- containers which contain both.  A node
        directly contains any child nodes.  A node also directly
        contains any other nodes attached to it such as attributes
        contained in an element or entities and notations contained in a
        document type.  Nodes contained in contained nodes are also
        contained, but less-directly as the number of intervening
        containers increases.</p>

      <p>If there is no common container node,
        then the order is based upon order between the root container of
        each node that is in no container.  In this case, the result is
        disconnected and implementation-specific.  This result is
        stable as long as these outer-most containing nodes remain in
        memory and are not inserted into some other containing node.
        This would be the case when the nodes belong to different
        documents or fragments, and cloning the document or inserting a
        fragment might change the order.</p>

      <p>If one of the nodes being compared contains the other node,
        then the container precedes the contained node, and reversely the
        contained node follows the container. For example, when comparing
        an element against its own attribute or child, the element node
        precedes its attribute node and its child node, which both follow
        it.</p>

      <p>If neither of the previous cases apply, then there exists a
        most-direct container common to both nodes being compared. In
        this case, the order is determined based upon the two
        determining nodes directly contained in this most-direct common
        container that either are or contain the corresponding nodes
        being compared.</p>

      <p>If these two determining nodes are both child nodes, then the
        natural DOM order of these determining nodes within the
        containing node is returned as the order of the corresponding
        nodes. This would be the case, for example, when comparing two
        child elements of the same element.</p>

      <p>If one of the two determining nodes is a child node and the
        other is not, then the corresponding node of the child node
        follows the corresponding node of the non-child node. This
        would be the case, for example, when comparing an attribute of
        an element with a child element of the same element.</p>

      <p>If neither of the two determining node is a child node and
        one determining node has a greater value of
        <code>nodeType</code> than the other, then the corresponding
        node precedes the other. This would be the case, for example,
        when comparing an entity of a document type against a notation
        of the same document type.</p>

      <p>If neither of the two determining node is a child node and
        <code>nodeType</code> is the same for both determining nodes,
        then an implementation-dependent order between the determining
        nodes is returned. This order is stable as long as no nodes of
        the same nodeType are inserted into or removed from the direct
        container. This would be the case, for example, when comparing
        two attributes of the same element, and inserting or removing
        additional attributes might change the order between existing
        attributes.</p>

    </descr>

    <constant id="Node-DOCUMENT_POSITION_DISCONNECTED" name="DOCUMENT_POSITION_DISCONNECTED" type="unsigned short" value="0x01">
      <descr><p>The two nodes are disconnected. Order between disconnected
               nodes is always implementation-specific.</p>
      </descr>
    </constant>
    <constant id="Node-DOCUMENT_POSITION_PRECEDING" name="DOCUMENT_POSITION_PRECEDING" type="unsigned short" value="0x02">
      <descr><p>The second node precedes the reference node.</p></descr>
    </constant>
    <constant id="Node-DOCUMENT_POSITION_FOLLOWING" name="DOCUMENT_POSITION_FOLLOWING" type="unsigned short" value="0x04">
      <descr><p>The node follows the reference node.</p></descr>
    </constant>
    <constant id="Node-DOCUMENT_POSITION_CONTAINS" name="DOCUMENT_POSITION_CONTAINS" type="unsigned short" value="0x08">
      <descr><p>The node contains the reference node.
               A node which contains is always preceding, too.</p></descr>
    </constant>
    <constant id="Node-DOCUMENT_POSITION_CONTAINED_BY" name="DOCUMENT_POSITION_CONTAINED_BY" type="unsigned short" value="0x10">
      <descr><p>The node is contained by the reference node.
               A node which is contained is always following, too.</p></descr>
    </constant>
    <constant id="Node-DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC" name="DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC" type="unsigned short" value="0x20">
      <descr><p>The determination of preceding versus following is
               implementation-specific.</p>
      </descr>
    </constant>
  </group> 

  <method name="compareDocumentPosition" id="Node3-compareDocumentPosition" since="DOM Level 3">
    <descr>
      <p>Compares the reference node, i.e. the node on which this method
      is being called, with a node, i.e. the one passed as a parameter, with
      regard to their position in the document and according to the
      <termref def="dt-document-order">document order</termref>.</p>
    </descr>
    <parameters>
      <param attr="in" type="Node" name="other">
        <descr>
          <p>The node to compare against the reference node.</p>
        </descr>
      </param>
    </parameters>
    <returns type="unsigned short">
      <descr>
        <p>Returns how the node is positioned relatively to the
	  reference node.</p>
      </descr>
    </returns>
    <raises>
      <exception name="DOMException"> 
        <descr>
          <p>NOT_SUPPORTED_ERR: when the compared nodes are from different
            DOM implementations that do not coordinate to return
            consistent implementation-specific results.</p>
        </descr> 
      </exception> 
    </raises>
  </method>

  <attribute name="textContent" id="Node3-textContent" type="DOMString" readonly="no" since="DOM Level 3">
    <descr>

      <p>This attribute returns the text content of this node and its
      descendants. When it is defined to be <code>null</code>, setting it
      has no effect. On setting, any possible children this node may have are
      removed and, if it the new string is not empty or <code>null</code>,
      replaced by a single <code>Text</code> node containing the string
      this attribute is set to.
      </p>
      <p>
	On getting, no serialization is performed, the returned string
	does not contain any markup. No whitespace normalization is
	performed and the returned string does not contain the white
	spaces in element content (see the attribute
	<code>Text.isElementContentWhitespace</code>). Similarly, on
	setting, no parsing is performed either, the input string is
	taken as pure textual content.
      </p>
      <p>The string returned is
	made of the text content of this node depending on its type, as
	defined below:
      </p>
        <table cellpadding="3" summary="The string returned is made of the text content of the                node. The first cell of this table contains the type of the                Node, the second cell indicates the string returned by                textContent." border="1">

          <tbody>
            <tr>
              <th rowspan="1" colspan="1">Node type</th><th rowspan="1" colspan="1">Content</th>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">ELEMENT_NODE, ATTRIBUTE_NODE, ENTITY_NODE, ENTITY_REFERENCE_NODE,
                DOCUMENT_FRAGMENT_NODE</td>
              <td rowspan="1" colspan="1">concatenation of the <code>textContent</code> attribute value
                of every child node, excluding COMMENT_NODE and
                PROCESSING_INSTRUCTION_NODE nodes. This is the empty string if
                the node has no children.</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">TEXT_NODE, CDATA_SECTION_NODE,
                COMMENT_NODE, PROCESSING_INSTRUCTION_NODE</td>
              <td rowspan="1" colspan="1"><code>nodeValue</code></td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">DOCUMENT_NODE, DOCUMENT_TYPE_NODE, NOTATION_NODE</td>
              <td rowspan="1" colspan="1"><emph>null</emph></td>
            </tr>
          </tbody>
        </table>

    </descr>
    <setraises> 
      <exception name="DOMException">	
        <descr>
          <p>NO_MODIFICATION_ALLOWED_ERR: Raised when the node is readonly.</p>
        </descr> 
      </exception> 
    </setraises> 
    <getraises> 
      <exception name="DOMException">	
        <descr>
          <p>DOMSTRING_SIZE_ERR: Raised when it would return more characters
            than fit in a <code>DOMString</code> variable on the implementation
            platform.</p>
        </descr> 
      </exception> 
    </getraises> 
  </attribute>

  <method name="isSameNode" id="Node3-isSameNode" since="DOM Level 3">
    <descr>
      <p>Returns whether this node is the same node as the given one.</p>
      <p>This method provides a way to determine whether two <code>Node</code>
        references returned by the implementation reference the same
        object. When two <code>Node</code> references are references to the
        same object, even if through a proxy, the references may be used
        completely interchangeably, such that all attributes have the same
        values and calling the same DOM method on either reference always has
        exactly the same effect.</p>
    </descr>
    <parameters>
      <param attr="in" type="Node" name="other">
        <descr>
          <p>The node to test against.</p>
        </descr>
      </param>
    </parameters>
    <returns type="boolean">
      <descr>
        <p>Returns <code>true</code> if the nodes are the same,
          <code>false</code> otherwise.</p>
      </descr>
    </returns>
    <raises>
    </raises>
  </method>

  <method name="lookupPrefix" id="Node3-lookupNamespacePrefix" since="DOM Level 3">
    <descr>
      <p>Look up the prefix associated to the given namespace URI, starting
        from this node. The default namespace declarations are ignored by this method.</p>
      <p>See <specref ref="lookupNamespacePrefixAlgo"/> for details on the
          algorithm used by this method.</p>
    </descr>
    <parameters>
      <param attr="in" type="DOMString" name="namespaceURI">
        <descr>
          <p>The namespace URI to look for.</p>
        </descr>
      </param>
    </parameters>
    <returns type="DOMString">
      <descr>
        <p>Returns an associated namespace prefix if found or <code>null</code>
        if none is found. If more than one prefix are associated to the namespace 
        prefix, the returned namespace prefix is implementation dependent.</p>
      </descr>
    </returns>
    <raises>
    </raises>
  </method>

  <method name="isDefaultNamespace" id="Node3-isDefaultNamespace" since="DOM Level 3">
    <descr>
      <p>
	This method checks if the specified <code>namespaceURI</code> is the
	default namespace or not.
      </p>
    </descr>
    <parameters>
      <param name="namespaceURI" type="DOMString" attr="in">
	<descr>
          <p>The namespace URI to look for.</p>
	</descr>
      </param>
    </parameters>
    <returns type="boolean">
      <descr>
	<p>Returns <code>true</code> if the specified <code>namespaceURI</code>
	  is the default namespace, <code>false</code> otherwise.
	</p>
      </descr>
    </returns>
    <raises>
    </raises>
  </method>

  <method name="lookupNamespaceURI" id="Node3-lookupNamespaceURI" since="DOM Level 3">
    <descr>
      <p>Look up the namespace URI associated to the given prefix, starting
        from this node.</p>
      <p>See <specref ref="lookupNamespaceURIAlgo"/> for details on the
          algorithm used by this method.</p>
    </descr>
    <parameters>
      <param attr="in" type="DOMString" name="prefix">
        <descr>
          <p>The prefix to look for. If this parameter is <code>null</code>,
	    the method will return the default namespace URI if any.</p>
        </descr>
      </param>
    </parameters>
    <returns type="DOMString">
      <descr>
        <p>Returns the associated namespace URI or <code>null</code> if none is
          found.</p>
      </descr>
    </returns>
    <raises>
    </raises>
  </method>

  <method name="isEqualNode" id="Node3-isEqualNode" since="DOM Level 3">
    <descr>
      <p>Tests whether two nodes are equal.</p>
      <p>This method tests for equality of nodes, not sameness (i.e., whether
        the two nodes are references to the same object) which can be tested
        with <code>Node.isSameNode()</code>. All nodes that are the same will
        also be equal, though the reverse may not be true.</p>
      <p>Two nodes are equal if and only if the following conditions are
        satisfied:
        <ulist>
          <item><p>The two nodes are of the same type.</p></item>
          <item><p>The following string attributes are equal:
              <code>nodeName</code>, <code>localName</code>,
              <code>namespaceURI</code>, <code>prefix</code>,
              <code>nodeValue</code>. This is: they are
              both <code>null</code>, or they have the same length and are
              character for character identical.</p></item>
          <item><p>The <code>attributes</code> <code>NamedNodeMaps</code> are
              equal. This is: they are both <code>null</code>, or they have the
              same length and for each node that exists in one map there is a
              node that exists in the other map and is equal, although not
              necessarily at the same index.</p></item>
          <item><p>The <code>childNodes</code> <code>NodeLists</code> are
              equal. This is: they are both <code>null</code>, or they
              have the same length and contain equal nodes at the same index.
              Note that normalization can affect equality; to avoid this, nodes
              should be normalized before being compared.</p></item>
        </ulist>
      </p>
      <p>For two <code>DocumentType</code> nodes to be equal, the following
        conditions must also be satisfied:
        <ulist>
          <item><p>The following string attributes are equal:
              <code>publicId</code>, <code>systemId</code>,
              <code>internalSubset</code>.</p></item>
          <item><p>The <code>entities</code> <code>NamedNodeMaps</code> are
            equal.</p></item>
          <item><p>The <code>notations</code> <code>NamedNodeMaps</code> are
            equal.</p></item>
        </ulist>
      </p>
      <p>On the other hand, the following do not affect equality:
        the <code>ownerDocument</code>, <code>baseURI</code>, and
        <code>parentNode</code> attributes, the <code>specified</code>
	attribute for <code>Attr</code> nodes, the <code>schemaTypeInfo</code>
        attribute for <code>Attr</code> and <code>Element</code> nodes, the
        <code>Text.isElementContentWhitespace</code> attribute for
        <code>Text</code> nodes, as well as any user data or event listeners
        registered on the nodes.
      </p>
      <note>
	<p>
	  As a general rule, anything not mentioned in the description
	  above is not significant in consideration of equality
	  checking. Note that future versions of this specification may
	  take into account more attributes and implementations conform
	  to this specification are expected to be updated accordingly.
	</p>
      </note>
    </descr>
    <parameters>
      <param name="arg" type="Node" attr="in">
        <descr>
          <p>The node to compare equality with.</p>
        </descr>
      </param>
    </parameters>
    <returns type="boolean">
      <descr>
        <p>Returns <code>true</code> if the nodes are equal, <code>false</code>
          otherwise.</p>
      </descr>
    </returns>
    <raises>
      <!-- No exceptions -->
    </raises>
  </method>

  <method name="getFeature" id="Node3-getFeature" since="DOM Level 3">
    <descr>
      <p>
	This method returns a specialized object which implements the
	specialized APIs of the specified feature and version, as
	specified in <specref ref="DOMFeatures"/>. The specialized object
	may also be obtained by using binding-specific casting methods
	but is not necessarily expected to, as discussed in <specref ref="Embedded-DOM"/>. This method also allow the implementation
	to provide specialized objects which do not support the
	<code>Node</code> interface.
      </p>
    </descr>
    <parameters>
      <param name="feature" type="DOMString" attr="in">
        <descr>
          <p>
	    The name of the feature requested. Note that any plus sign
	    "+" prepended to the name of the feature will be ignored
	    since it is not significant in the context of this method.
	  </p>
        </descr>
      </param>
      <param name="version" type="DOMString" attr="in">
        <descr>
          <p>
	    This is the version number of the feature to test.
	  </p>
        </descr>
      </param>
    </parameters>
    <returns type="DOMObject">
      <descr>
        <p>
	  Returns an object which implements the specialized APIs of the
	  specified feature and version, if any, or <code>null</code> if
	  there is no object which implements interfaces associated with
	  that feature. If the <code>DOMObject</code> returned by this
	  method implements the <code>Node</code> interface, it must
	  delegate to the primary core <code>Node</code> and not return
	  results inconsistent with the primary core <code>Node</code>
	  such as attributes, childNodes, etc.
	</p>
      </descr>
    </returns>
    <raises>
    </raises>
  </method>

  <method name="setUserData" id="Node3-setUserData" since="DOM Level 3">
    <descr>
      <p>Associate an object to a key on this node. The object can later be
        retrieved from this node by calling <code>getUserData</code> with the
        same key.</p>
    </descr>
    <parameters>
      <param name="key" type="DOMString" attr="in">
        <descr>
          <p>The key to associate the object to.</p>
        </descr>
      </param>
      <param name="data" type="DOMUserData" attr="in">
        <descr>
          <p>The object to associate to the given key, or <code>null</code> to
            remove any existing association to that key.</p>
        </descr>
      </param>
      <param name="handler" type="UserDataHandler" attr="in">
        <descr>
          <p>The handler to associate to that key, or <code>null</code>.</p>
        </descr>
      </param>
    </parameters>
    <returns type="DOMUserData">
      <descr>
        <p>Returns the <code>DOMUserData</code> previously associated to
	  the given key on this node, or <code>null</code> if there was none.</p>
      </descr>
    </returns>
    <raises>
    </raises>
  </method>

  <method name="getUserData" id="Node3-getUserData" since="DOM Level 3">
    <descr>
      <p>Retrieves the object associated to a key on a this node. The object
        must first have been set to this node by calling
        <code>setUserData</code> with the same key.</p>
    </descr>
    <parameters>
      <param name="key" type="DOMString" attr="in">
        <descr>
          <p>The key the object is associated to.</p>
        </descr>
      </param>
    </parameters>
    <returns type="DOMUserData">
      <descr>
        <p>Returns the <code>DOMUserData</code> associated to the given
	  key on this node, or <code>null</code> if there was none.</p>
      </descr>
    </returns>
    <raises>
    </raises>
  </method>
</interface>
 
<!-- $Date: 2001/05/15 21:07:53 $ $Revision: 1.1 $ -->
<!--[ NodeList object description ]-->
<interface name="NodeList" id="ID-536297177">
  <descr>
    <p>The <code>NodeList</code> interface provides the abstraction of an
      ordered collection of nodes, without defining or constraining how this
      collection is implemented. <code>NodeList</code> objects in the DOM are
      <termref def="td-live">live</termref>.</p>
    <p>The items in the <code>NodeList</code> are accessible via an
      integral index, starting from 0.</p>
  </descr>

  <method name="item" id="ID-844377136">
    <descr>
      <p>Returns the <code>index</code>th item in the collection. If
        <code>index</code> is greater than or equal to the number of nodes in
        the list, this returns <code>null</code>.</p>
    </descr>
    <parameters>
      <param name="index" type="unsigned long" attr="in">
	<descr>
          <p>Index into the collection.</p>
        </descr>
      </param>
    </parameters>
    <returns type="Node">
      <descr>
        <p>The node at the <code>index</code>th position in the
          <code>NodeList</code>, or <code>null</code> if that is not a valid
          index.</p>
      </descr>
    </returns>
    <raises>
      <!-- No exceptions -->
    </raises>
  </method>

  <attribute type="unsigned long" readonly="yes" name="length" id="ID-203510337">
    <descr>
      <p>The number of nodes in the list. The range of valid child node indices
        is 0 to <code>length-1</code> inclusive.</p>
    </descr>
  </attribute>
</interface>
      

      
<!-- $Date: 2003/06/04 22:37:28 $ $Revision: 1.5 $ -->
<!--[ NamedNodeMap object description ]-->
<interface name="NamedNodeMap" id="ID-1780488922">
  <descr>
    <p>Objects implementing the <code>NamedNodeMap</code> interface are used to
      represent collections of nodes that can be accessed by name. Note that
      <code>NamedNodeMap</code> does not inherit from <code>NodeList</code>;
      <code>NamedNodeMaps</code> are not maintained in any particular
      order. Objects contained in an object implementing
      <code>NamedNodeMap</code> may also be accessed by an ordinal index, but
      this is simply to allow convenient enumeration of the contents of a
      <code>NamedNodeMap</code>, and does not imply that the DOM specifies an
      order to these Nodes. </p>
    <p><code>NamedNodeMap</code> objects in the DOM are
      <termref def="td-live">live</termref>.</p>
  </descr>

  <method name="getNamedItem" id="ID-1074577549">
    <descr>
      <p>Retrieves a node specified by name.</p>
    </descr>
    <parameters>
      <param name="name" type="DOMString" attr="in">
	<descr>
          <p>The <code>nodeName</code> of a node to retrieve.</p>
        </descr>
      </param>
    </parameters>
    <returns type="Node">
      <descr>
        <p>A <code>Node</code> (of any type) with the specified
          <code>nodeName</code>, or <code>null</code> if it does not identify
          any node in this map.</p>
      </descr>
    </returns>
    <raises>
      <!-- No exceptions -->
    </raises>
  </method>

  <method name="setNamedItem" id="ID-1025163788">
    <descr>
      <p>Adds a node using its <code>nodeName</code> attribute. If a node with
	that name is already present in this map, it is replaced by the new
	one. Replacing a node by itself has no effect.</p>
      <p>As the <code>nodeName</code> attribute is used to derive the name
        which the node must be stored under, multiple nodes of certain types
        (those that have a "special" string value) cannot be stored as the
        names would clash. This is seen as preferable to allowing nodes to be
        aliased.</p>
    </descr>
    <parameters>
      <param name="arg" type="Node" attr="in">
	<descr>
          <p>A node to store in this map. The node will later be accessible
            using the value of its <code>nodeName</code> attribute.</p>
        </descr>
      </param>
    </parameters>
    <returns type="Node">
      <descr>
        <p>If the new <code>Node</code> replaces an existing node the replaced
          <code>Node</code> is returned, otherwise <code>null</code> is
          returned.</p>
      </descr>
    </returns>
    <raises>
      <exception name="DOMException">
        <descr>
          <p>WRONG_DOCUMENT_ERR: Raised if <code>arg</code> was created from a
            different document than the one that created this map.</p>
          <p>NO_MODIFICATION_ALLOWED_ERR: Raised if this map is readonly.</p>
          <p>INUSE_ATTRIBUTE_ERR: Raised if <code>arg</code> is an
            <code>Attr</code> that is already an attribute of another
            <code>Element</code> object. The DOM user must explicitly clone
            <code>Attr</code> nodes to re-use them in other elements.</p>
          <p>HIERARCHY_REQUEST_ERR: Raised if an attempt is made to add a node
            doesn't belong in this NamedNodeMap. Examples would include trying
            to insert something other than an Attr node into an Element's map
            of attributes, or a non-Entity node into the DocumentType's map of
            Entities.</p>
        </descr>
      </exception>
    </raises>
  </method>

  <method name="removeNamedItem" id="ID-D58B193">
    <descr>
      <p>Removes a node specified by name. When this map contains the
        attributes attached to an element, if the removed attribute is known to
        have a default value, an attribute immediately appears containing the
        default value as well as the corresponding namespace URI, local name,
        and prefix when applicable.</p>
    </descr>
    <parameters>
      <param name="name" type="DOMString" attr="in">
	<descr>
          <p>The <code>nodeName</code> of the node to remove.</p>
        </descr>
      </param>
    </parameters>
    <returns type="Node">
       <descr>
        <p>The node removed from this map if a node with such a name
          exists.</p>
      </descr>
    </returns>
    <raises>
      <exception name="DOMException">
        <descr>
          <p>NOT_FOUND_ERR: Raised if there is no node named <code>name</code>
            in this map.</p>
          <p>NO_MODIFICATION_ALLOWED_ERR: Raised if this map is readonly.</p>
	</descr>
      </exception>
    </raises>
  </method>

  <method name="item" id="ID-349467F9">
    <descr>
      <p>Returns the <code>index</code>th item in the map. If
        <code>index</code> is greater than or equal to the number of nodes in
        this map, this returns <code>null</code>.</p>
    </descr> 
    <parameters>
      <param name="index" type="unsigned long" attr="in">
	<descr><p>Index into this map.</p></descr>
      </param>
    </parameters>
    <returns type="Node">
      <descr>
        <p>The node at the <code>index</code>th position in the map, or
          <code>null</code> if that is not a valid index.</p>
      </descr>
    </returns>
    <raises>
      <!-- No exceptions -->
    </raises>
  </method>

  <attribute type="unsigned long" readonly="yes" name="length" id="ID-6D0FB19E">
    <descr>
      <p>The number of nodes in this map. The range of valid child node indices
        is <code>0</code> to <code>length-1</code> inclusive.</p>
    </descr>
  </attribute>

  <method name="getNamedItemNS" id="ID-getNamedItemNS" since="DOM Level 2">
    <descr>
      <p>Retrieves a node specified by local name and namespace URI.</p>
      <p>Per <bibref ref="Namespaces"/>, applications must use the value null
      as the namespaceURI parameter for methods if they wish to have no
      namespace.</p>
    </descr>
    <parameters>
      <param name="namespaceURI" type="DOMString" attr="in">
	<descr>
          <p>The <termref def="dt-namespaceURI">namespace URI</termref> of the
            node to retrieve.</p>
	</descr>
      </param>
      <param name="localName" type="DOMString" attr="in">
	<descr>
          <p>The <termref def="dt-localname">local name</termref> of the node
            to retrieve.</p></descr>
      </param>
    </parameters>
    <returns type="Node">
      <descr>
        <p>A <code>Node</code> (of any type) with the specified local name and
          namespace URI, or <code>null</code> if they do not identify any node
          in this map.</p>
      </descr>
    </returns>
    <raises>
      <exception name="DOMException">
        <descr>
          <p>NOT_SUPPORTED_ERR: May be raised if the implementation does
	    not support the feature "XML" and the language exposed
	    through the Document does not support XML Namespaces (such
	    as <bibref role="informative" ref="HTML40"/>).
	    </p>
	</descr>
      </exception>
    </raises>
  </method>

  <method name="setNamedItemNS" id="ID-setNamedItemNS" since="DOM Level 2">
    <descr>
      <p>Adds a node using its <code>namespaceURI</code> and
        <code>localName</code>. If a node with that namespace URI and that
        local name is already present in this map, it is replaced by the new
        one. Replacing a node by itself has no effect.</p>
      <p>Per <bibref ref="Namespaces"/>, applications must use the value null
      as the namespaceURI parameter for methods if they wish to have no
      namespace.</p>
    </descr>
    <parameters>
      <param name="arg" type="Node" attr="in">
	<descr>
          <p>A node to store in this map. The node will later be accessible
            using the value of its <code>namespaceURI</code> and
            <code>localName</code> attributes.</p>
        </descr>
      </param>
    </parameters>
    <returns type="Node">
      <descr>
        <p>If the new <code>Node</code> replaces an existing node the replaced
          <code>Node</code> is returned, otherwise <code>null</code> is
          returned.</p>
      </descr>
    </returns>
    <raises>
      <exception name="DOMException">
        <descr>
          <p>WRONG_DOCUMENT_ERR: Raised if <code>arg</code> was created from a
            different document than the one that created this map.</p>
          <p>NO_MODIFICATION_ALLOWED_ERR: Raised if this map is readonly.</p>
          <p>INUSE_ATTRIBUTE_ERR: Raised if <code>arg</code> is an
            <code>Attr</code> that is already an attribute of another
            <code>Element</code> object. The DOM user must explicitly clone
            <code>Attr</code> nodes to re-use them in other elements.</p>
          <p>HIERARCHY_REQUEST_ERR: Raised if an attempt is made to add a node
            doesn't belong in this NamedNodeMap. Examples would include trying
            to insert something other than an Attr node into an Element's map
            of attributes, or a non-Entity node into the DocumentType's map of
            Entities.</p>
          <p>NOT_SUPPORTED_ERR: May be raised if the implementation does
	    not support the feature "XML" and the language exposed
	    through the Document does not support XML Namespaces (such
	    as <bibref role="informative" ref="HTML40"/>).
	    </p>
        </descr>
      </exception>
    </raises>
  </method>
  <method name="removeNamedItemNS" id="ID-removeNamedItemNS" since="DOM Level 2">
    <descr>
      <p>Removes a node specified by local name and namespace URI. A removed
        attribute may be known to have a default value when this map contains
        the attributes attached to an element, as returned by the attributes
        attribute of the <code>Node</code> interface. If so, an attribute
        immediately appears containing the default value as well as the
        corresponding namespace URI, local name, and prefix when
        applicable.</p>
      <p>Per <bibref ref="Namespaces"/>, applications must use the value null
      as the namespaceURI parameter for methods if they wish to have no
      namespace.</p>
    </descr>
    <parameters>
      <param name="namespaceURI" type="DOMString" attr="in">
	<descr>
          <p>The <termref def="dt-namespaceURI">namespace URI</termref> of the
            node to remove.</p>
	</descr>
      </param>
      <param name="localName" type="DOMString" attr="in">
	<descr>
          <p>The <termref def="dt-localname">local name</termref> of the node
            to remove.</p>
        </descr>
      </param>
    </parameters>
    <returns type="Node">
       <descr>
        <p>The node removed from this map if a node with such a local name and
          namespace URI exists.</p>
      </descr>
    </returns>
    <raises>
      <exception name="DOMException">
        <descr>
          <p>NOT_FOUND_ERR: Raised if there is no node with the specified
	    <code>namespaceURI</code> and <code>localName</code> in this
            map.</p>
	  <p>NO_MODIFICATION_ALLOWED_ERR: Raised if this map is readonly.</p>
          <p>NOT_SUPPORTED_ERR: May be raised if the implementation does
	    not support the feature "XML" and the language exposed
	    through the Document does not support XML Namespaces (such
	    as <bibref role="informative" ref="HTML40"/>).
	    </p>
	</descr>
      </exception>
    </raises>
  </method>
</interface>
      
 
<!--[ Data interface description ]-->
<!-- $Date: 2003/05/28 13:08:38 $ $Revision: 1.3 $ -->
<interface name="CharacterData" inherits="Node" id="ID-FF21A306">
  <descr>
    <p>The <code>CharacterData</code> interface extends Node with a set of
      attributes and methods for accessing character data in the DOM. For
      clarity this set is defined here rather than on each object that uses
      these attributes and methods. No DOM objects correspond directly to
      <code>CharacterData</code>, though <code>Text</code> and others do
      inherit the interface from it. All <code>offsets</code> in this
      interface start from <code>0</code>.</p>
    <p>As explained in the <code>DOMString</code> interface, text strings
      in the DOM are represented in UTF-16, i.e. as a sequence of 16-bit
      units. In the following, the term <termref def="dt-16-bit-unit">16-bit
        units</termref> is used whenever necessary to indicate that indexing on
      CharacterData is done in 16-bit units.</p>
  </descr> 

  <attribute type="DOMString" name="data" id="ID-72AB8359" readonly="no">
    <descr>
      <p>The character data of the node that implements this interface. The DOM
        implementation may not put arbitrary limits on the amount of data that
        may be stored in a <code>CharacterData</code> node. However,
        implementation limits may mean that the entirety of a node's data may
        not fit into a single <code>DOMString</code>. In such cases, the user
        may call <code>substringData</code> to retrieve the data in
        appropriately sized pieces.</p>
    </descr>
    <setraises>
      <exception name="DOMException">
	<descr>
          <p>NO_MODIFICATION_ALLOWED_ERR: Raised when the node is readonly.</p>
        </descr>
      </exception>
    </setraises>
    <getraises>
      <exception name="DOMException">
	<descr>
          <p>DOMSTRING_SIZE_ERR: Raised when it would return more characters
            than fit in a <code>DOMString</code> variable on the implementation
            platform.</p>
        </descr>
      </exception>
    </getraises>
  </attribute>

  <attribute type="unsigned long" name="length" readonly="yes" id="ID-7D61178C">
    <descr>
      <p>The number of <termref def="dt-16-bit-unit">16-bit units</termref>
        that are available through <code>data</code> and the
        <code>substringData</code> method below.  This may have the value zero,
        i.e., <code>CharacterData</code> nodes may be empty.</p>
    </descr>
  </attribute>

  <method name="substringData" id="ID-6531BCCF">
    <descr>
      <p>Extracts a range of data from the node.</p>
    </descr> 
    <parameters>
      <param name="offset" type="unsigned long" attr="in">
	<descr>
          <p>Start offset of substring to extract.</p>
        </descr>
      </param>
      <param name="count" type="unsigned long" attr="in">
	<descr>
          <p>The number of 16-bit units to extract.</p>
        </descr>
      </param>
    </parameters>
    <returns type="DOMString">
      <descr>
        <p>The specified substring. If the sum of <code>offset</code> and
	  <code>count</code> exceeds the <code>length</code>, then all 16-bit
	  units to the end of the data are returned.</p>
      </descr>
    </returns>
    <raises>
      <exception name="DOMException">
        <descr>
          <p>INDEX_SIZE_ERR: Raised if the specified <code>offset</code> is
            negative or greater than the number of 16-bit units in
            <code>data</code>, or if the specified <code>count</code> is
            negative.</p>
          <p>DOMSTRING_SIZE_ERR: Raised if the specified range of text does not
            fit into a <code>DOMString</code>.</p>
	</descr>
      </exception>
    </raises>
  </method>

  <method name="appendData" id="ID-32791A2F">
    <descr>
      <p>Append the string to the end of the character data of the node. Upon
        success, <code>data</code> provides access to the concatenation of
        <code>data</code> and the <code>DOMString</code> specified.</p>
    </descr> 
    <parameters>
      <param name="arg" type="DOMString" attr="in">
	<descr>
          <p>The <code>DOMString</code> to append.</p>
        </descr>
      </param>
    </parameters>
    <returns type="void">
      <descr><p><!--empty paragraph--></p></descr>
    </returns>
    <raises>
      <exception name="DOMException">
        <descr>
          <p>NO_MODIFICATION_ALLOWED_ERR: Raised if this node is readonly.</p>
        </descr>
      </exception>
    </raises>
  </method>

  <method name="insertData" id="ID-3EDB695F">
    <descr>
      <p>Insert a string at the specified <termref def="dt-16-bit-unit">16-bit
          unit</termref> offset.</p>
    </descr> 
    <parameters>
      <param name="offset" type="unsigned long" attr="in">
	<descr>
          <p>The character offset at which to insert.</p>
        </descr>
      </param>
      <param name="arg" type="DOMString" attr="in">
	<descr>
          <p>The <code>DOMString</code> to insert.</p>
        </descr>
      </param>
    </parameters>
    <returns type="void">
      <descr><p><!--empty paragraph--></p></descr>
    </returns>
    <raises>
      <exception name="DOMException">
        <descr>
          <p>INDEX_SIZE_ERR: Raised if the specified <code>offset</code> is
            negative or greater than the number of 16-bit units in
            <code>data</code>.</p>
          <p>NO_MODIFICATION_ALLOWED_ERR: Raised if this node is readonly.</p>
	</descr>
      </exception>
    </raises>
  </method>

  <method name="deleteData" id="ID-7C603781">
    <descr>
      <p>Remove a range of <termref def="dt-16-bit-unit">16-bit units</termref>
        from the node. Upon success, <code>data</code> and <code>length</code>
        reflect the change.</p>
    </descr> 
    <parameters>
      <param name="offset" type="unsigned long" attr="in">
	<descr>
          <p>The offset from which to start removing.</p>
	</descr>
      </param>
      <param name="count" type="unsigned long" attr="in">
	<descr>
          <p>The number of 16-bit units to delete. If the sum of
            <code>offset</code> and <code>count</code> exceeds
            <code>length</code> then all 16-bit units from <code>offset</code>
            to the end of the data are deleted.</p>
        </descr>
      </param>
    </parameters>
    <returns type="void">
      <descr><p><!--empty paragraph--></p></descr>
    </returns>
    <raises>
      <exception name="DOMException">
        <descr>
          <p>INDEX_SIZE_ERR: Raised if the specified <code>offset</code> is
            negative or greater than the number of 16-bit units in
            <code>data</code>, or if the specified <code>count</code> is
            negative.</p>
          <p>NO_MODIFICATION_ALLOWED_ERR: Raised if this node is readonly.</p>
	</descr>
      </exception>
    </raises>
  </method>

  <method name="replaceData" id="ID-E5CBA7FB">
    <descr>
      <p>Replace the characters starting at the specified
        <termref def="dt-16-bit-unit">16-bit unit</termref> offset with the
        specified string.</p>
    </descr> 
    <parameters>
      <param name="offset" type="unsigned long" attr="in">
	<descr>
          <p>The offset from which to start replacing.</p>
        </descr>
      </param>
      <param name="count" type="unsigned long" attr="in">
	<descr>
          <p>The number of 16-bit units to replace. If the sum of
            <code>offset</code> and <code>count</code> exceeds
            <code>length</code>, then all 16-bit units to the end of the data
            are replaced; (i.e., the effect is the same as a
            <code>remove</code> method call with the same range, followed by an
            <code>append</code> method invocation).</p>
        </descr>
      </param>
      <param name="arg" type="DOMString" attr="in">
	<descr>
          <p>The <code>DOMString</code> with which the range must be
            replaced.</p>
        </descr>
      </param>
    </parameters>
    <returns type="void">
      <descr><p><!--empty paragraph--></p></descr>
    </returns>
    <raises>
      <exception name="DOMException">
        <descr>
          <p>INDEX_SIZE_ERR: Raised if the specified <code>offset</code> is
            negative or greater than the number of 16-bit units in
            <code>data</code>, or if the specified <code>count</code> is
            negative.</p>
          <p>NO_MODIFICATION_ALLOWED_ERR: Raised if this node is readonly.</p>
	</descr>
      </exception>
    </raises>
  </method>
</interface>
 
<!-- $Date: 2004/03/15 20:03:11 $ $Revision: 1.33 $ -->
<!--[ Attr object description ]-->
<interface name="Attr" inherits="Node" id="ID-637646024">
  <descr>
    <p>The <code>Attr</code> interface represents an attribute in an
      <code>Element</code> object. Typically the allowable values for the
      attribute are defined in a schema associated with the document.</p>

    <p><code>Attr</code> objects inherit the <code>Node</code> interface, but
      since they are not actually child nodes of the element they describe, the
      DOM does not consider them part of the document tree.  Thus, the
      <code>Node</code> attributes <code>parentNode</code>,
      <code>previousSibling</code>, and <code>nextSibling</code> have a
      <code>null</code> value for <code>Attr</code> objects. The DOM takes the
      view that attributes are properties of elements rather than having a
      separate identity from the elements they are associated with; this should
      make it more efficient to implement such features as default attributes
      associated with all elements of a given type.  Furthermore,
      <code>Attr</code> nodes may not be immediate children of a
      <code>DocumentFragment</code>. However, they can be associated with
      <code>Element</code> nodes contained within a
      <code>DocumentFragment</code>. In short, users and implementors of the
      DOM need to be aware that <code>Attr</code> nodes have some things in
      common with other objects inheriting the <code>Node</code> interface, but
      they also are quite distinct.</p>

    <p>The attribute's effective value is determined as follows: if this
      attribute has been explicitly assigned any value, that value is the
      attribute's effective value; otherwise, if there is a declaration for
      this attribute, and that declaration includes a default value, then that
      default value is the attribute's effective value; otherwise, the
      attribute does not exist on this element in the structure model until it
      has been explicitly added.  Note that the <code>Node.nodeValue</code>
      attribute on the <code>Attr</code> instance can also be used to retrieve
      the string version of the attribute's value(s).</p>
 
    <p>
      If the attribute was not explicitly given a value in the instance
      document but has a default value provided by the schema associated
      with the document, an attribute node will be created with
      <code>specified</code> set to <code>false</code>. Removing
      attribute nodes for which a default value is defined in the schema
      generates a new attribute node with the default value and
      <code>specified</code> set to <code>false</code>. If validation
      occurred while invoking <code>Document.normalizeDocument()</code>,
      attribute nodes with <code>specified</code> equals to
      <code>false</code> are recomputed according to the default
      attribute values provided by the schema. If no default value is
      associate with this attribute in the schema, the attribute node is
      discarded.
    </p>

    <p>In XML, where the value of an attribute can contain entity references,
      the child nodes of the <code>Attr</code> node may be either
      <code>Text</code> or <code>EntityReference</code> nodes (when these are
      in use; see the description of <code>EntityReference</code> for
      discussion).
    </p>
    <p>The DOM Core represents all attribute values as simple strings,
    even if the DTD or schema associated with the document declares
    them of some specific type such as <termref def="dt-tokenized">tokenized</termref>.
    </p>
    <p>The way attribute value normalization is performed by the DOM
    implementation depends on how much the implementation knows about
    the schema in use. Typically, the <code>value</code> and
    <code>nodeValue</code> attributes of an <code>Attr</code> node
    initially returns the normalized value given by the parser. It is
    also the case after <code>Document.normalizeDocument()</code> is
    called (assuming the right options have been set). But this may not
    be the case after mutation, independently of whether the mutation is
    performed by setting the string value directly or by changing the
    <code>Attr</code> child nodes. In particular, this is true when
    <xspecref xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/2004/REC-xml-20040204#dt-charref" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">character
	references</xspecref> are involved,
    given that they are not represented in the DOM and they impact
    attribute value normalization. On the other hand, if the
    implementation knows about the schema in use when the attribute
    value is changed, and it is of a different type than CDATA, it may
    normalize it again at that time. This is especially true of
    specialized DOM implementations, such as SVG DOM implementations,
    which store attribute values in an internal form different from a
    string.</p>

    <p>The following table gives some examples of
    the relations between the attribute value in the original document
    (parsed attribute), the value as exposed in the DOM, and the
    serialization of the value:
    </p>
    <table cellpadding="3" border="1" summary="Examples of differences between a parsed attribute,     its DOM representation, and its serialization">
      <tbody>
	<tr>
	  <th rowspan="1" colspan="1">Examples</th>
	  <th rowspan="1" colspan="1">Parsed attribute value</th>
	  <th rowspan="1" colspan="1">Initial <code>Attr.value</code></th>
	  <th rowspan="1" colspan="1">Serialized attribute value</th>
	</tr>
	<tr>
	  <td rowspan="1" colspan="1">Character reference</td>
	  <td rowspan="1" colspan="1"><eg xml:space="preserve">"x&amp;#178;=5"</eg></td>
	  <td rowspan="1" colspan="1"><eg xml:space="preserve">"x&#178;=5"</eg></td>
	  <td rowspan="1" colspan="1"><eg xml:space="preserve">"x&amp;#178;=5"</eg></td>
	</tr>
	<tr>
	  <td rowspan="1" colspan="1">Built-in character entity</td>
	  <td rowspan="1" colspan="1"><eg xml:space="preserve">"y&amp;lt;6"</eg></td>
	  <td rowspan="1" colspan="1"><eg xml:space="preserve">"y&lt;6"</eg></td>
	  <td rowspan="1" colspan="1"><eg xml:space="preserve">"y&amp;lt;6"</eg></td>
	</tr>
	<tr>
	  <td rowspan="1" colspan="1">Literal newline between</td>
	  <td rowspan="1" colspan="1"><eg xml:space="preserve">"x=5&amp;#10;y=6"</eg></td>
	  <td rowspan="1" colspan="1"><eg xml:space="preserve">"x=5
y=6"</eg></td>
	  <td rowspan="1" colspan="1"><eg xml:space="preserve">"x=5&amp;#10;y=6"</eg></td>
	</tr>
	<tr>
	  <td rowspan="1" colspan="1">Normalized newline between</td>
	  <td rowspan="1" colspan="1"><eg xml:space="preserve">"x=5
y=6"</eg></td>
      <td rowspan="1" colspan="1"><eg xml:space="preserve">"x=5 y=6"</eg></td>
      <td rowspan="1" colspan="1"><eg xml:space="preserve">"x=5 y=6"</eg></td>
    </tr>
    <tr>
	  <td rowspan="1" colspan="1">Entity <code>e</code> with literal newline</td>
	  <td rowspan="1" colspan="1"><eg xml:space="preserve">&lt;!ENTITY e
'...&amp;#10;...'&gt;
[...]&gt;
"x=5&amp;e;y=6"</eg></td>
	  <td rowspan="1" colspan="1"><emph>Dependent on Implementation and Load Options</emph></td>
	  <td rowspan="1" colspan="1"><emph>Dependent on Implementation and Load/Save Options</emph></td>
	</tr>
      </tbody>
    </table>
  </descr>

  <attribute type="DOMString" readonly="yes" name="name" id="ID-1112119403">
    <descr>
      <p>Returns the name of this attribute. If
	<code>Node.localName</code> is different from <code>null</code>, this
      attribute is a <termref def="dt-qualifiedname">qualified name</termref>.</p>
    </descr>
  </attribute>

  <attribute type="boolean" readonly="yes" name="specified" id="ID-862529273">
    <descr>
      <p>
	<code>True</code> if this attribute was explicitly given a value
	in the instance document, <code>false</code> otherwise. If the
	application changed the value of this attribute node (even if it
	ends up having the same value as the default value) then it is
	set to <code>true</code>. The implementation may handle
	attributes with default values from other schemas similarly but
	applications should use <code>Document.normalizeDocument()</code>
	to guarantee this information is up-to-date.
      </p>
    </descr>
  </attribute>

  <attribute type="DOMString" name="value" id="ID-221662474" readonly="no">
    <descr>
      <p>On retrieval, the value of the attribute is returned as a
	string. Character and general entity references are replaced with their
	values. See also the method <code>getAttribute</code> on the 
        <code>Element</code> interface.</p>
      <p>On setting, this creates a <code>Text</code> node with the unparsed
	contents of the string, i.e. any characters that an XML processor would
        recognize as markup are instead treated as literal text.
	See also the method <code>Element.setAttribute()</code>.</p>
      <p>
	Some specialized implementations, such as some <bibref ref="SVG1" role="informative"/> implementations, may do
	normalization automatically, even after mutation; in such case,
	the value on retrieval may differ from the value on setting.
      </p>
    </descr>
    <setraises>
      <exception name="DOMException">
	<descr>
          <p>NO_MODIFICATION_ALLOWED_ERR: Raised when the node is readonly.</p>
        </descr>
      </exception>
    </setraises>
  </attribute>

  <!-- ****** DOM Level 2 additions ****** -->
  <attribute name="ownerElement" type="Element" readonly="yes" id="Attr-ownerElement" since="DOM Level 2">
    <descr>
      <p>The <code>Element</code> node this attribute is attached to or
	<code>null</code> if this attribute is not in use.</p>
    </descr>
  </attribute>

  <!-- ****** DOM Level 3 additions ****** -->
  <attribute name="schemaTypeInfo" type="TypeInfo" id="Attr-schemaTypeInfo" since="DOM Level 3" readonly="yes">
    <descr>
      <p>
	The type information associated with this attribute. While the
	type information contained in this attribute is guarantee to be
	correct after loading the document or invoking
	<code>Document.normalizeDocument()</code>,
	<code>schemaTypeInfo</code> may not be reliable if the node was
	moved.
      </p>
    </descr>
  </attribute>

  <attribute name="isId" id="Attr-isId" since="DOM Level 3" readonly="yes" type="boolean">
    <descr>
      <p>
	Returns whether this attribute is known to be of type ID
	(i.e. to contain an identifier for its owner element) or not.
	When it is and its value is unique, the
	<code>ownerElement</code> of this attribute can be retrieved
	using the method <code>Document.getElementById</code>. The
	implementation could use several ways to determine if an
	attribute node is known to contain an identifier:
      </p>
      <ulist>
	<item>
	  <p>
	    If validation occurred using an XML Schema <bibref ref="XMLSchema1"/> while loading the document or while
	    invoking <code>Document.normalizeDocument()</code>, the
	    post-schema-validation infoset contributions (PSVI
	    contributions) values are used to determine if this
	    attribute is a <term>schema-determined ID attribute</term>
	    using the <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/2003/REC-xptr-framework-20030325/#term-sdi" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">schema-determined
	    ID</loc> definition in <bibref ref="XPointer"/>.
	  </p>
	</item>
	<item>
	  <p>
	    If validation occurred using a DTD while loading the document
	    or while invoking <code>Document.normalizeDocument()</code>,
	    the infoset <b>[type definition]</b> value is used to determine if this
	    attribute is a <term>DTD-determined ID attribute</term>
	    using the <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/2003/REC-xptr-framework-20030325/#term-ddi" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">DTD-determined
	    ID</loc> definition in <bibref ref="XPointer"/>.
	  </p>
	</item>
	<item>
	  <p>
	    from the use of the methods
	    <code>Element.setIdAttribute()</code>,
	    <code>Element.setIdAttributeNS()</code>, or
	    <code>Element.setIdAttributeNode()</code>, i.e. it is an
	    <term>user-determined ID attribute</term>;
	  </p>
	  <note>
	    <p>
	      XPointer framework (see section 3.2 in <bibref role="informative" ref="XPointer"/>) consider the DOM
	      <term>user-determined ID attribute</term> as being part of
	      the XPointer <term>externally-determined ID</term>
	      definition.
	    </p>
	  </note>
	</item>
	<item>
	  <p>
	    using mechanisms that are outside the scope of this
	    specification, it is then an <term>externally-determined
	    ID attribute</term>. This includes using schema
	    languages different from XML schema and DTD.
	  </p>
	</item>
      </ulist>
      <p>
	If validation occurred while invoking
	<code>Document.normalizeDocument()</code>, all
	<term>user-determined ID attributes</term> are reset and all
	attribute nodes ID information are then reevaluated in
	accordance to the schema used. As a consequence, if the
	<code>Attr.schemaTypeInfo</code> attribute contains an ID type,
	<code>isId</code> will always return true.
      </p>

    </descr>
  </attribute>
</interface>
 
<!-- $Date: 2004/02/25 20:37:33 $ $Revision: 1.32 $ -->
<!--[ Element object description ]-->
<interface name="Element" inherits="Node" id="ID-745549614">
  <descr>
    <p>The <code>Element</code> interface represents an
      <termref def="dt-element">element</termref> in an HTML or XML
      document. Elements may have attributes associated with them; since the
      <code>Element</code> interface inherits from <code>Node</code>, the
      generic <code>Node</code> interface attribute <code>attributes</code> may
      be used to retrieve the set of all attributes for an element. There are
      methods on the <code>Element</code> interface to retrieve either an
      <code>Attr</code> object by name or an attribute value by name. In XML,
      where an attribute value may contain entity references, an
      <code>Attr</code> object should be retrieved to examine the possibly
      fairly complex sub-tree representing the attribute value. On the other
      hand, in HTML, where all attributes have simple string values, methods to
      directly access an attribute value can safely be used as a
      <termref def="dt-convenience">convenience</termref>.</p>
    <note>
      <p>In DOM Level 2, the method <code>normalize</code> is inherited from
        the <code>Node</code> interface where it was moved.</p>
    </note>
  </descr>

  <attribute type="DOMString" name="tagName" readonly="yes" id="ID-104682815">
    <descr>
      <p>The name of the element. If <code>Node.localName</code> is
	different from <code>null</code>, this
      attribute is a <termref def="dt-qualifiedname">qualified
	  name</termref>. For example, in:  
        <eg role="code" xml:space="preserve">
          &lt;elementExample id="demo"&gt; 
          ... 
          &lt;/elementExample&gt; ,
        </eg>
        <code>tagName</code> has the value <code>"elementExample"</code>. Note
        that this is case-preserving in XML, as are all of the operations of
        the DOM. The HTML DOM returns the <code>tagName</code> of an HTML
        element in the canonical uppercase form, regardless of the case in the
        source HTML document.</p>
    </descr>
  </attribute>

  <method name="getAttribute" id="ID-666EE0F9">
    <descr>
      <p>Retrieves an attribute value by name.</p>
    </descr>
    <parameters>
      <param name="name" type="DOMString" attr="in">
	<descr>
          <p>The name of the attribute to retrieve.</p>
        </descr>
      </param>
    </parameters>
    <returns type="DOMString">
      <descr>
        <p>The <code>Attr</code> value as a string, or the empty string if that
          attribute does not have a specified or default value.</p>
      </descr>
    </returns>
    <raises>
      <!-- No exceptions -->
    </raises>
  </method>

  <method name="setAttribute" id="ID-F68F082">
    <descr>
      <p>Adds a new attribute. If an attribute with that name is already
        present in the element, its value is changed to be that of the value
        parameter. This value is a simple string; it is not parsed as it is
        being set. So any markup (such as syntax to be recognized as an entity
        reference) is treated as literal text, and needs to be appropriately
        escaped by the implementation when it is written out. In order to
        assign an attribute value that contains entity references, the user
        must create an <code>Attr</code> node plus any <code>Text</code> and
        <code>EntityReference</code> nodes, build the appropriate subtree, and
        use <code>setAttributeNode</code> to assign it as the value of an
        attribute.</p>
      <p>To set an attribute with a qualified name and namespace URI, use the
        <code>setAttributeNS</code> method.</p>
    </descr>
    <parameters>
      <param name="name" type="DOMString" attr="in">
	<descr>
          <p>The name of the attribute to create or alter.</p>
        </descr>
      </param>
      <param name="value" type="DOMString" attr="in">
	<descr>
          <p>Value to set in string form.</p>
        </descr>
      </param>
    </parameters>
    <returns type="void">
      <descr><p><!--empty paragraph--></p></descr>      
    </returns>
    <raises>
      <exception name="DOMException">
        <descr>
          <p>INVALID_CHARACTER_ERR: Raised if the specified name is not
            an XML name according to the XML version in use
	    specified in the <code>Document.xmlVersion</code> attribute.</p>
          <p>NO_MODIFICATION_ALLOWED_ERR: Raised if this node is readonly.</p>
	</descr>
      </exception>
    </raises>
  </method>

  <method name="removeAttribute" id="ID-6D6AC0F9">
    <descr>
      <p>Removes an attribute by name. If a default value for the removed
        attribute is defined in the DTD, a new attribute immediately appears
        with the default value as well as the corresponding namespace URI,
        local name, and prefix when applicable. The implementation may handle
        default values from other schemas similarly but applications should use
        <code>Document.normalizeDocument()</code> to guarantee this information is up-to-date.</p>
      <p>If no attribute with this name is found, this method has no
        effect.</p>
      <p>To remove an attribute by local name and namespace URI, use the
        <code>removeAttributeNS</code> method.</p>
    </descr>
    <parameters>
      <param name="name" type="DOMString" attr="in">
	<descr>
          <p>The name of the attribute to remove.</p>
        </descr>
      </param>
    </parameters>
    <returns type="void">
      <descr><p><!--empty paragraph--></p></descr>
    </returns>
    <raises>
      <exception name="DOMException">
        <descr>
          <p>NO_MODIFICATION_ALLOWED_ERR: Raised if this node is readonly.</p>
	</descr>
      </exception>
    </raises>
  </method>

  <method name="getAttributeNode" id="ID-217A91B8">
    <descr>
      <p>Retrieves an attribute node by name.</p>
      <p>To retrieve an attribute node by qualified name and namespace URI, use
	the <code>getAttributeNodeNS</code> method.</p>
    </descr>
    <parameters>
      <param name="name" type="DOMString" attr="in">
	<descr>
          <p>The name (<code>nodeName</code>) of the attribute to retrieve.</p>
        </descr>
      </param>
    </parameters>
    <returns type="Attr">
      <descr>
        <p>The <code>Attr</code> node with the specified name
          (<code>nodeName</code>) or <code>null</code> if there is no such
          attribute.</p>
      </descr> 
    </returns>
    <raises>
      <!-- No exceptions -->
    </raises>
  </method>
  <method name="setAttributeNode" id="ID-887236154">
    <descr>
      <p>Adds a new attribute node. If an attribute with that name
        (<code>nodeName</code>) is already present in the element, it is
        replaced by the new one. Replacing an attribute node by itself has no
        effect.</p>
      <p>To add a new attribute node with a qualified name and namespace URI,
	use the <code>setAttributeNodeNS</code> method.</p>
    </descr>
    <parameters>
      <param name="newAttr" type="Attr" attr="in">
	<descr>
          <p>The <code>Attr</code> node to add to the attribute list.</p>
        </descr>
      </param>
    </parameters>
    <returns type="Attr">
      <descr>
        <p>If the <code>newAttr</code> attribute replaces an existing
          attribute, the replaced <code>Attr</code> node is returned, otherwise
          <code>null</code> is returned.</p>
      </descr>
    </returns>
    <raises>
      <exception name="DOMException">
        <descr>
          <p>WRONG_DOCUMENT_ERR: Raised if <code>newAttr</code> was created
            from a different document than the one that created the
            element.</p>
          <p>NO_MODIFICATION_ALLOWED_ERR: Raised if this node is readonly.</p>
          <p>INUSE_ATTRIBUTE_ERR: Raised if <code>newAttr</code> is already an
            attribute of another <code>Element</code> object. The DOM user must
            explicitly clone <code>Attr</code> nodes to re-use them in other
            elements.</p>
        </descr>
      </exception>
    </raises>
  </method>

  <method name="removeAttributeNode" id="ID-D589198">
    <descr>
      <p>Removes the specified attribute node. If a default value for the
        removed <code>Attr</code> node is defined in the DTD, a new node
        immediately appears with the default value as well as the corresponding
        namespace URI, local name, and prefix when applicable. The
        implementation may handle default values from other schemas similarly
        but applications should use <code>Document.normalizeDocument()</code> to guarantee this
        information is up-to-date.</p>
    </descr>
    <parameters>
      <param name="oldAttr" type="Attr" attr="in">
	<descr>
          <p>The <code>Attr</code> node to remove from the attribute list.</p>
        </descr>
      </param>
    </parameters>
    <returns type="Attr">
      <descr>
        <p>The <code>Attr</code> node that was removed.</p>
      </descr>
    </returns>
    <raises>
      <exception name="DOMException">
        <descr>
          <p>NO_MODIFICATION_ALLOWED_ERR: Raised if this node is readonly.</p>
          <p>NOT_FOUND_ERR: Raised if <code>oldAttr</code> is not an attribute
            of the element.</p>
	</descr>
      </exception>
    </raises>
  </method>

  <method name="getElementsByTagName" id="ID-1938918D">
    <descr>
      <p>Returns a <code>NodeList</code> of all
        <termref def="dt-descendant">descendant</termref> <code>Elements</code>
        with a given tag name, in <termref def="dt-document-order">document
          order</termref>.</p>
    </descr>
    <parameters>
      <param name="name" type="DOMString" attr="in">
	<descr>
          <p>The name of the tag to match on. The special value "*" matches all
            tags.</p>
        </descr>
      </param>
    </parameters>
    <returns type="NodeList">
      <descr>
        <p>A list of matching <code>Element</code> nodes.</p>
      </descr>
    </returns>
    <raises>
      <!-- No exceptions -->
    </raises>
  </method>

  <!-- ****** DOM Level 2 additions ****** -->
  <method name="getAttributeNS" id="ID-ElGetAttrNS" since="DOM Level 2">
    <descr>
      <p>Retrieves an attribute value by local name and namespace URI.</p>
      <p>Per <bibref ref="Namespaces"/>, applications must use the value <code>null</code>
      as the <code>namespaceURI</code> parameter for methods if they wish to have no
      namespace.</p>
    </descr>
    <parameters>
      <param name="namespaceURI" type="DOMString" attr="in">
	<descr>
          <p>The <termref def="dt-namespaceURI">namespace URI</termref> of the
            attribute to retrieve.</p>
	</descr>
      </param>
      <param name="localName" type="DOMString" attr="in">
	<descr>
          <p>The <termref def="dt-localname">local name</termref> of the
            attribute to retrieve.</p>
	</descr>
      </param>
    </parameters>
    <returns type="DOMString">
      <descr>
        <p>The <code>Attr</code> value as a string, or the empty string if that
          attribute does not have a specified or default value.</p>
      </descr>
    </returns>
    <raises>
      <exception name="DOMException">
        <descr>
          <p>NOT_SUPPORTED_ERR: May be raised if the implementation does
	    not support the feature <code>"XML"</code> and the language exposed
	    through the Document does not support XML Namespaces (such
	    as <bibref role="informative" ref="HTML40"/>).
	    </p>
	</descr>
      </exception>
    </raises>
  </method>

  <method name="setAttributeNS" id="ID-ElSetAttrNS" since="DOM Level 2">
    <descr>
      <p>Adds a new attribute. If an attribute with the same local name
	and namespace URI is already present on the element, its prefix is
	changed to be the prefix part of the <code>qualifiedName</code>, and
	its value is changed to be the <code>value</code> parameter. This value
	is a simple string; it is not parsed as it is being set. So any markup
	(such as syntax to be recognized as an entity reference) is treated as
	literal text, and needs to be appropriately escaped by the
	implementation when it is written out. In order to assign an attribute
	value that contains entity references, the user must create an
	<code>Attr</code> node plus any <code>Text</code> and
	<code>EntityReference</code> nodes, build the appropriate subtree, and
	use <code>setAttributeNodeNS</code> or <code>setAttributeNode</code> to
	assign it as the value of an attribute.</p>
      <p>Per <bibref ref="Namespaces"/>, applications must use the value <code>null</code>
      as the <code>namespaceURI</code> parameter for methods if they wish to have no
      namespace.</p>
    </descr>
    <parameters>
      <param name="namespaceURI" type="DOMString" attr="in">
	<descr>
          <p>The <termref def="dt-namespaceURI">namespace URI</termref> of the
            attribute to create or alter.</p>
	</descr>
      </param>
      <param name="qualifiedName" type="DOMString" attr="in">
	<descr>
          <p>The <termref def="dt-qualifiedname">qualified name</termref> of
            the attribute to create or alter.</p>
	</descr>
      </param>
      <param name="value" type="DOMString" attr="in">
	<descr>
          <p>The value to set in string form.</p>
        </descr>
      </param>
    </parameters>
    <returns type="void">
      <descr><p><!--empty paragraph--></p></descr>      
    </returns>
    <raises>
      <exception name="DOMException">
	<descr>
          <p>INVALID_CHARACTER_ERR: Raised if the specified qualified name
	    is not an XML name according to the XML version in use
	    specified in the <code>Document.xmlVersion</code> attribute.</p>
	  <p>NO_MODIFICATION_ALLOWED_ERR: Raised if this node is readonly.</p>
	  <p>NAMESPACE_ERR: Raised if the <code>qualifiedName</code> is
            malformed per the Namespaces in XML specification, if the
            <code>qualifiedName</code> has a prefix and the
            <code>namespaceURI</code> is <code>null</code>, if the
            <code>qualifiedName</code> has a prefix that is "xml" and the
            <code>namespaceURI</code> is different from
            "<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/XML/1998/namespace" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/XML/1998/namespace</loc>", if the
            <code>qualifiedName</code> or its prefix is "xmlns" and the
            <code>namespaceURI</code> is different from
            "<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/2000/xmlns/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/2000/xmlns/</loc>", or if the
            <code>namespaceURI</code> is
            "<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/2000/xmlns/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/2000/xmlns/</loc>" and neither the
            <code>qualifiedName</code> nor its prefix is "xmlns".</p>
          <p>NOT_SUPPORTED_ERR: May be raised if the implementation does
	    not support the feature <code>"XML"</code> and the language exposed
	    through the Document does not support XML Namespaces (such
	    as <bibref role="informative" ref="HTML40"/>).
	  </p>
	</descr>
      </exception>
    </raises>
  </method>

  <method name="removeAttributeNS" id="ID-ElRemAtNS" since="DOM Level 2">
    <descr>
      <p>Removes an attribute by local name and namespace URI. If a default
        value for the removed attribute is defined in the DTD, a new attribute
        immediately appears with the default value as well as the corresponding
        namespace URI, local name, and prefix when applicable. The
        implementation may handle default values from other schemas similarly
        but applications should use <code>Document.normalizeDocument()</code> to guarantee this
        information is up-to-date.</p>
      <p>If no attribute with this local name and namespace URI is found, this
        method has no effect.</p>
      <p>Per <bibref ref="Namespaces"/>, applications must use the value <code>null</code>
      as the <code>namespaceURI</code> parameter for methods if they wish to have no
      namespace.</p>
    </descr>
    <parameters>
      <param name="namespaceURI" type="DOMString" attr="in">
	<descr>
          <p>The <termref def="dt-namespaceURI">namespace URI</termref> of the
            attribute to remove.</p>
	</descr>
      </param>
      <param name="localName" type="DOMString" attr="in">
	<descr>
          <p>The <termref def="dt-localname">local name</termref> of the
            attribute to remove.</p>
	</descr>
      </param>
    </parameters>
    <returns type="void">
      <descr><p><!--empty paragraph--></p></descr>
    </returns>
    <raises>
      <exception name="DOMException">
	<descr>
          <p>NO_MODIFICATION_ALLOWED_ERR: Raised if this node is readonly.</p>
          <p>NOT_SUPPORTED_ERR: May be raised if the implementation does
	    not support the feature <code>"XML"</code> and the language exposed
	    through the Document does not support XML Namespaces (such
	    as <bibref role="informative" ref="HTML40"/>).
	    </p>
	</descr>
      </exception>
    </raises>
  </method>
  <method name="getAttributeNodeNS" id="ID-ElGetAtNodeNS" since="DOM Level 2">
    <descr><p>Retrieves an <code>Attr</code> node by local name and namespace
	URI.</p>
      <p>Per <bibref ref="Namespaces"/>, applications must use the value <code>null</code>
      as the <code>namespaceURI</code> parameter for methods if they wish to have no
      namespace.</p>
    </descr>
    <parameters>
      <param name="namespaceURI" type="DOMString" attr="in">
	<descr>
          <p>The <termref def="dt-namespaceURI">namespace URI</termref> of the
            attribute to retrieve.</p>
	</descr>
      </param>
      <param name="localName" type="DOMString" attr="in">
	<descr>
          <p>The <termref def="dt-localname">local name</termref> of the
	    attribute to retrieve.</p>
	</descr>
      </param>
    </parameters>
    <returns type="Attr">
      <descr>
        <p>The <code>Attr</code> node with the specified attribute local name
          and namespace URI or <code>null</code> if there is no such
          attribute.</p>
      </descr>
    </returns>
    <raises>
      <exception name="DOMException">
        <descr>
          <p>NOT_SUPPORTED_ERR: May be raised if the implementation does
	    not support the feature <code>"XML"</code> and the language exposed
	    through the Document does not support XML Namespaces (such
	    as <bibref role="informative" ref="HTML40"/>).
	    </p>
	</descr>
      </exception>
    </raises>
  </method>

  <method name="setAttributeNodeNS" id="ID-ElSetAtNodeNS" since="DOM Level 2">
    <descr>
      <p>Adds a new attribute. If an attribute with that local name and that
        namespace URI is already present in the element, it is replaced by the
        new one. Replacing an attribute node by itself has no effect.</p>
      <p>Per <bibref ref="Namespaces"/>, applications must use the value <code>null</code>
      as the <code>namespaceURI</code> parameter for methods if they wish to have no
      namespace.</p>
    </descr>
    <parameters>
      <param name="newAttr" type="Attr" attr="in">
	<descr>
          <p>The <code>Attr</code> node to add to the attribute list.</p>
	</descr>
      </param>
    </parameters>
    <returns type="Attr">
      <descr>
        <p>If the <code>newAttr</code> attribute replaces an existing attribute
          with the same <termref def="dt-localname">local name</termref> and
          <termref def="dt-namespaceURI">namespace URI</termref>, the replaced
          <code>Attr</code> node is returned, otherwise <code>null</code> is
          returned.</p>
      </descr>
    </returns>
    <raises>
      <exception name="DOMException">
	<descr>
          <p>WRONG_DOCUMENT_ERR: Raised if <code>newAttr</code> was created
            from a different document than the one that created the
            element.</p>
	  <p>NO_MODIFICATION_ALLOWED_ERR: Raised if this node is readonly.</p>
	  <p>INUSE_ATTRIBUTE_ERR: Raised if <code>newAttr</code> is already an
	    attribute of another <code>Element</code> object. The DOM user
	    must explicitly clone <code>Attr</code> nodes to re-use them in
	    other elements.</p>
          <p>NOT_SUPPORTED_ERR: May be raised if the implementation does
	    not support the feature <code>"XML"</code> and the language exposed
	    through the Document does not support XML Namespaces (such
	    as <bibref role="informative" ref="HTML40"/>).
	  </p>
	</descr>
      </exception>
    </raises>
  </method>

  <method name="getElementsByTagNameNS" id="ID-A6C90942" since="DOM Level 2">
    <descr>
      <p>Returns a <code>NodeList</code> of all the
        <termref def="dt-descendant">descendant</termref> <code>Elements</code>
        with a given local name and namespace URI in
        <termref def="dt-document-order">document order</termref>.</p>
    </descr>
    <parameters>
      <param name="namespaceURI" type="DOMString" attr="in">
	<descr>
          <p>The <termref def="dt-namespaceURI">namespace URI</termref> of the
            elements to match on. The special value "*" matches all
            namespaces.</p>
	</descr>
      </param>
      <param name="localName" type="DOMString" attr="in">
	<descr>
          <p>The <termref def="dt-localname">local name</termref> of the
            elements to match on. The special value "*" matches all local
            names.</p>
        </descr>
      </param>
    </parameters>
    <returns type="NodeList">
      <descr>
        <p>A new <code>NodeList</code> object containing all the matched
          <code>Elements</code>.</p>
      </descr>
    </returns>
    <raises>
      <exception name="DOMException">
        <descr>
          <p>NOT_SUPPORTED_ERR: May be raised if the implementation does
	    not support the feature <code>"XML"</code> and the language exposed
	    through the Document does not support XML Namespaces (such
	    as <bibref role="informative" ref="HTML40"/>).
	    </p>
	</descr>
      </exception>
    </raises>
  </method>

  <method name="hasAttribute" id="ID-ElHasAttr" since="DOM Level 2">
    <descr>
      <p>Returns <code>true</code> when an attribute with a given name is
        specified on this element or has a default value, <code>false</code>
        otherwise.</p>
    </descr>
    <parameters>
      <param name="name" type="DOMString" attr="in">
	<descr>
          <p>The name of the attribute to look for.</p>
        </descr>
      </param>
    </parameters>
    <returns type="boolean">
      <descr>
        <p><code>true</code> if an attribute with the given name is specified
          on this element or has a default value, <code>false</code>
          otherwise.</p>
      </descr>
    </returns>
    <raises>
      <!-- No exceptions -->
    </raises>
  </method>

  <method name="hasAttributeNS" id="ID-ElHasAttrNS" since="DOM Level 2">
    <descr>
      <p>Returns <code>true</code> when an attribute with a given local name
        and namespace URI is specified on this element or has a default value,
        <code>false</code> otherwise.</p>
      <p>Per <bibref ref="Namespaces"/>, applications must use the value <code>null</code>
      as the <code>namespaceURI</code> parameter for methods if they wish to have no
      namespace.</p>
    </descr>
    <parameters>
      <param name="namespaceURI" type="DOMString" attr="in">
	<descr>
          <p>The <termref def="dt-namespaceURI">namespace URI</termref> of the
            attribute to look for.</p>
	</descr>
      </param>
      <param name="localName" type="DOMString" attr="in">
	<descr>
          <p>The <termref def="dt-localname">local name</termref> of the
            attribute to look for.</p>
	</descr>
      </param>
    </parameters>
    <returns type="boolean">
      <descr>
        <p><code>true</code> if an attribute with the given local name and
          namespace URI is specified or has a default value on this element,
          <code>false</code> otherwise.</p>
      </descr>
    </returns>
    <raises>
      <exception name="DOMException">
        <descr>
          <p>NOT_SUPPORTED_ERR: May be raised if the implementation does
	    not support the feature <code>"XML"</code> and the language exposed
	    through the Document does not support XML Namespaces (such
	    as <bibref role="informative" ref="HTML40"/>).
	    </p>
	</descr>
      </exception>
    </raises>
  </method>

  <!-- ****** DOM Level 3 additions ****** -->
  <attribute name="schemaTypeInfo" type="TypeInfo" id="Element-schemaTypeInfo" since="DOM Level 3" readonly="yes">
    <descr>
      <p>
	The type information associated with this element.
      </p>
    </descr>
  </attribute>

  <method name="setIdAttribute" id="ID-ElSetIdAttr" since="DOM Level 3">
    <descr>
      <p>
	If the parameter <code>isId</code> is <code>true</code>, this
	method declares the specified attribute to be a
	<term>user-determined ID attribute</term>. This affects the
	value of <code>Attr.isId</code> and the behavior of
	<code>Document.getElementById</code>, but does not change any
	schema that may be in use, in particular this does not affect
	the <code>Attr.schemaTypeInfo</code> of the specified
	<code>Attr</code> node. Use the value <code>false</code> for the
	parameter <code>isId</code> to undeclare an attribute for being
	a <term>user-determined ID attribute</term>.
      </p>
      <p>
	To specify an attribute by local name and namespace URI, use the
	<code>setIdAttributeNS</code> method.
      </p>
    </descr>
    <parameters>
      <param name="name" type="DOMString" attr="in">
	<descr>
          <p>The name of the attribute.</p>
	</descr>
      </param>
      <param name="isId" type="boolean" attr="in">
	<descr>
          <p>Whether the attribute is a of type ID.</p>
	</descr>
      </param>
    </parameters>
    <returns type="void">
      <descr><p><!--empty paragraph--></p></descr>      
    </returns>
    <raises>
      <exception name="DOMException">
	<descr>
	  <p>NO_MODIFICATION_ALLOWED_ERR: Raised if this node is readonly.</p>
          <p>NOT_FOUND_ERR: Raised if the specified node is not an attribute
            of this element.</p>
	</descr>
      </exception>
    </raises>
  </method>

  <method name="setIdAttributeNS" id="ID-ElSetIdAttrNS" since="DOM Level 3">
    <descr>
      <p>
	If the parameter <code>isId</code> is <code>true</code>, this
	method declares the specified attribute to be a
	<term>user-determined ID attribute</term>. This affects the
	value of <code>Attr.isId</code> and the behavior of
	<code>Document.getElementById</code>, but does not change any
	schema that may be in use, in particular this does not affect
	the <code>Attr.schemaTypeInfo</code> of the specified
	<code>Attr</code> node. Use the value <code>false</code> for the
	parameter <code>isId</code> to undeclare an attribute for being
	a <term>user-determined ID attribute</term>.
      </p>
    </descr>
    <parameters>
      <param name="namespaceURI" type="DOMString" attr="in">
	<descr>
          <p>The <termref def="dt-namespaceURI">namespace URI</termref> of the
            attribute.</p>
	</descr>
      </param>
      <param name="localName" type="DOMString" attr="in">
	<descr>
          <p>The <termref def="dt-localname">local name</termref> of the
            attribute.</p>
	</descr>
      </param>
      <param name="isId" type="boolean" attr="in">
	<descr>
          <p>Whether the attribute is a of type ID.</p>
	</descr>
      </param>
    </parameters>
    <returns type="void">
      <descr><p><!--empty paragraph--></p></descr>      
    </returns>
    <raises>
      <exception name="DOMException">
	<descr>
	  <p>NO_MODIFICATION_ALLOWED_ERR: Raised if this node is readonly.</p>
          <p>NOT_FOUND_ERR: Raised if the specified node is not an attribute
            of this element.</p>
	</descr>
      </exception>
    </raises>
  </method>

  <method name="setIdAttributeNode" id="ID-ElSetIdAttrNode" since="DOM Level 3">
    <descr>
      <p>
	If the parameter <code>isId</code> is <code>true</code>, this
	method declares the specified attribute to be a
	<term>user-determined ID attribute</term>. This affects the
	value of <code>Attr.isId</code> and the behavior of
	<code>Document.getElementById</code>, but does not change any
	schema that may be in use, in particular this does not affect
	the <code>Attr.schemaTypeInfo</code> of the specified
	<code>Attr</code> node. Use the value <code>false</code> for the
	parameter <code>isId</code> to undeclare an attribute for being
	a <term>user-determined ID attribute</term>.
      </p>
    </descr>
    <parameters>
      <param name="idAttr" type="Attr" attr="in">
	<descr>
          <p>The attribute node.</p>
	</descr>
      </param>
      <param name="isId" type="boolean" attr="in">
	<descr>
          <p>Whether the attribute is a of type ID.</p>
	</descr>
      </param>
    </parameters>
    <returns type="void">
      <descr><p><!--empty paragraph--></p></descr>      
    </returns>
    <raises>
      <exception name="DOMException">
	<descr>
	  <p>NO_MODIFICATION_ALLOWED_ERR: Raised if this node is readonly.</p>
          <p>NOT_FOUND_ERR: Raised if the specified node is not an attribute
            of this element.</p>
	</descr>
      </exception>
    </raises>
  </method>

</interface>

      
<!--[ Text object description ]-->
<!-- $Date: 2003/09/18 14:55:31 $ $Revision: 1.26 $ -->
<interface name="Text" inherits="CharacterData" id="ID-1312295772"> 
  <descr>
    <p>The <code>Text</code> interface inherits from <code>CharacterData</code>
      and represents the textual content (termed
      <xspecref xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/2004/REC-xml-20040204#syntax" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">character data</xspecref> in XML) of
      an <code>Element</code> or <code>Attr</code>. If there is no markup
      inside an element's content, the text is contained in a single object
      implementing the <code>Text</code> interface that is the only child of
      the element. If there is markup, it is parsed into the
      <termref def="dt-infoitem">information items</termref> (elements,
      comments, etc.) and <code>Text</code> nodes that form the list of
      children of the element.</p>
    <p>When a document is first made available via the DOM, there is only one
      <code>Text</code> node for each block of text. Users may create adjacent
      <code>Text</code> nodes that represent the contents of a given element
      without any intervening markup, but should be aware that there is no way
      to represent the separations between these nodes in XML or HTML, so they
      will not (in general) persist between DOM editing sessions. The
      <code>Node.normalize()</code> method merges any such
      adjacent <code>Text</code> objects into a single node for each block of
      text.</p>
    <p>
      No lexical check is done on the content of a <code>Text</code>
      node and, depending on its position in the document, some
      characters must be escaped during serialization using character
      references; e.g. the characters "&lt;&amp;" if
      the textual content is part of an element or of an attribute, the
      character sequence "]]&gt;" when part of an element, the quotation
      mark character " or the apostrophe character ' when part of an
      attribute.
    </p>
  </descr> 

  <method name="splitText" id="ID-38853C1D"> 
    <descr>
      <p>Breaks this node into two nodes at the specified <code>offset</code>,
        keeping both in the tree as
        <termref def="dt-sibling">siblings</termref>. After being split, this
        node will contain all the content up to the <code>offset</code>
        point. A new node of the same type, which contains all the content at
        and after the <code>offset</code> point, is returned. If the original
        node had a parent node, the new node is inserted as the next
        <termref def="dt-sibling">sibling</termref> of the original node. When
        the <code>offset</code> is equal to the length of this node, the new
        node has no data.</p>
    </descr> 
    <parameters> 
      <param name="offset" type="unsigned long" attr="in">	
        <descr>
          <p>The <termref def="dt-16-bit-unit">16-bit unit</termref> offset at
            which to split, starting from <code>0</code>.</p>
        </descr> 
      </param> 
    </parameters> 
    <returns type="Text"> 
      <descr>
        <p>The new node, of the same type as this node.</p>
      </descr> 
    </returns> 
    <raises> 
      <exception name="DOMException"> 
        <descr>
          <p>INDEX_SIZE_ERR: Raised if the specified offset is negative or
            greater than the number of 16-bit units in <code>data</code>.</p>
          <p>NO_MODIFICATION_ALLOWED_ERR: Raised if this node is readonly.</p>
        </descr> 
      </exception> 
    </raises> 
  </method>

  <!-- ****** DOM Level 3 additions ****** -->
  <attribute name="isElementContentWhitespace" id="Text3-isElementContentWhitespace" since="DOM Level 3" readonly="yes" type="boolean">
    <descr>
      <p>Returns whether this text node contains <xspecref xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/2004/REC-xml-infoset-20040204#infoitem.character" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">element
	  content whitespace</xspecref>,
        often abusively called "ignorable whitespace". The text node is
	determined to contain whitespace in element content during the
	load of the document or if validation occurs while using
	<code>Document.normalizeDocument()</code>.</p>
    </descr>
  </attribute>

  <attribute readonly="yes" type="DOMString" name="wholeText" id="Text3-wholeText" since="DOM Level 3">
    <descr>

      <p>Returns all text of <code>Text</code> nodes <termref def="dt-logically-adjacent-text-nodes">logically-adjacent text
       nodes</termref> to this node, concatenated in document order.</p>
      <p>For instance, in the example below <code>wholeText</code> on the
        <code>Text</code> node that contains "bar" returns "barfoo", while on
        the <code>Text</code> node that contains "foo" it returns "barfoo".
      </p>
      <graphic xmlns:xlink="http://www.w3.org/1999/xlink" source="./images/wholeTextExmpl.png" alt="barTextNode.wholeText value is &quot;barfoo&quot;" xlink:type="simple" xlink:show="embed" xlink:actuate="onLoad"/>

    </descr>
  </attribute>

  <method name="replaceWholeText" id="Text3-replaceWholeText" since="DOM Level 3"> 
    <descr>
      <p>Replaces the text of the current node and
      all <termref def="dt-logically-adjacent-text-nodes">logically-adjacent
      text nodes</termref> with the specified text. All <termref def="dt-logically-adjacent-text-nodes">logically-adjacent text
      nodes</termref> are removed including the current node unless it was the
      recipient of the replacement text.</p>

      <p>This method returns the node which received the replacement
      text. The returned node is:
      </p>
      <ulist>
	<item>
	  <p><code>null</code>, when the replacement text is the empty
	  string;</p>
	</item>
	<item>
	  <p>the current node, except when the current node is <termref def="dt-readonly-node">read-only</termref>;</p>
	</item>
	<item>
	  <p>
	    a new <code>Text</code> node of the same type
	    (<code>Text</code> or <code>CDATASection</code>) as the
	    current node inserted at the location of the replacement.</p>
	</item>
      </ulist>

      <p>For instance, in the above example calling
        <code>replaceWholeText</code> on the <code>Text</code> node that
        contains "bar" with "yo" in argument results in the following:
      </p>
      <graphic xmlns:xlink="http://www.w3.org/1999/xlink" source="./images/wholeTextExmpl2.png" alt="barTextNode.replaceWholeText(&quot;yo&quot;) modifies the textual content of barTextNode with &quot;yo&quot;" xlink:type="simple" xlink:show="embed" xlink:actuate="onLoad"/>

      <p>Where the nodes to be removed are read-only descendants of an
      <code>EntityReference</code>, the <code>EntityReference</code> must be
      removed instead of the read-only nodes. If any
      <code>EntityReference</code> to be removed has descendants that are not
      <code>EntityReference</code>, <code>Text</code>, or
      <code>CDATASection</code> nodes, the <code>replaceWholeText</code> method
      must fail before performing any modification of the document, raising a
      <code>DOMException</code> with the code
      <code>NO_MODIFICATION_ALLOWED_ERR</code>.</p>

      <p>For instance, in the example below calling
      <code>replaceWholeText</code> on the <code>Text</code> node that
      contains "bar" fails, because the <code>EntityReference</code>
      node "ent" contains an <code>Element</code> node which cannot be
      removed.</p>
      <graphic xmlns:xlink="http://www.w3.org/1999/xlink" source="./images/wholeTextExmpl3.png" alt="barTextNode.replaceWholeText(&quot;yo&quot;) raises a NO_MODIFICATION_ALLOWED_ERR DOMException" xlink:type="simple" xlink:show="embed" xlink:actuate="onLoad"/>

    </descr>
    <parameters>
      <param name="content" type="DOMString" attr="in">
        <descr>
          <p>The content of the replacing <code>Text</code> node.</p>
        </descr>
      </param>
    </parameters>
    <returns type="Text">
      <descr>
        <p>The <code>Text</code> node created with the specified content.</p>
      </descr>
    </returns>
    <raises>
      <exception name="DOMException">
        <descr>
          <p>NO_MODIFICATION_ALLOWED_ERR: Raised if one of the
            <code>Text</code> nodes being replaced is readonly.</p>
        </descr>
      </exception>
    </raises>
  </method>
</interface>
 
<!--[ Comment object description ]-->
<!-- $Date: 2003/05/05 23:52:40 $ $Revision: 1.2 $ -->
<interface name="Comment" inherits="CharacterData" id="ID-1728279322">
  <descr>
    <p>This interface inherits from <code>CharacterData</code> and represents
      the content of a comment, i.e., all the characters between the starting
      '<code>&lt;!--</code>' and ending '<code>--&gt;</code>'. Note that this
      is the definition of a comment in XML, and, in practice, HTML, although
      some HTML tools may implement the full SGML comment structure.
    </p>
    <p>
      No lexical check is done on the content of a comment and
      it is therefore possible to have the character sequence
      <code>"--"</code> (double-hyphen) in the content, which is illegal
      in a comment per section 2.5 of <bibref ref="XML"/>. The presence
      of this character sequence must generate a fatal error during
      serialization.
    </p>
  </descr>
</interface>
 
<!-- $Id: typeinfo.xml,v 1.18 2004/03/18 19:32:14 plehegar Exp $: -->
<interface name="TypeInfo" id="TypeInfo" since="DOM Level 3">
  <descr>
    <p>
      The <code>TypeInfo</code> interface represents a type referenced
      from <code>Element</code> or <code>Attr</code> nodes, specified in
      the <termref def="dt-schema">schemas</termref> associated with the
      document. The type is a pair of a <termref def="dt-namespaceURI">namespace URI</termref> and name properties,
      and depends on the document's schema.
    </p>
    <p>
      If the document's schema is an XML DTD <bibref ref="XML"/>, the
      values are computed as follows:
    </p>
    <ulist>
      <item>
	<p>
	  If this type is referenced from an <code>Attr</code> node,
	  <code>typeNamespace</code> is
	  <code>"http://www.w3.org/TR/REC-xml"</code> and
	  <code>typeName</code> represents the <b>[attribute type]</b>
	  property in the <bibref ref="InfoSet"/>. If there is no
	  declaration for the attribute, <code>typeNamespace</code> and
	  <code>typeName</code> are <code>null</code>.
	</p>
      </item>
      <item>
	<p>
	  If this type is referenced from an <code>Element</code> node,
	  <code>typeNamespace</code> and <code>typeName</code> are
	  <code>null</code>.
	</p>
      </item>
    </ulist>
    <p>
      If the document's schema is an XML Schema <bibref ref="XMLSchema1"/>, the values are computed as follows using the
      post-schema-validation infoset contributions (also called PSVI
      contributions):
    </p>
    <ulist>
      <item>
	<p>
	  If the <b>[validity]</b> property exists AND is
	  <emph>"invalid"</emph> or <emph>"notKnown"</emph>: the {target
	  namespace} and {name} properties of the declared type if
	  available, otherwise <code>null</code>.
	</p>
	<note>
	  <p>
	    At the time of writing, the XML Schema specification does
	    not require exposing the declared type. Thus, DOM
	    implementations might choose not to provide type information
	    if validity is not valid.
	  </p>
	</note>
      </item>
      <item>
	<p>
	  If the <b>[validity]</b> property exists and is <emph>"valid"</emph>:
	</p>
	<olist>
	  <item>
	    <p>
	      If <b>[member type definition]</b> exists: </p> 
            <olist>
             <item><p>If {name} is not absent, then expose {name} and {target namespace} properties of the 
                      <b>[member type definition]</b> property;</p></item>
             <item><p>Otherwise, expose the namespace and local name of the corresponding
             <termref def="dt-anonymous">anonymous type name</termref>.</p></item>
            </olist>
	  </item>
 	  <item>
	    <p>
	      If the <b>[type definition]</b> property exists:
            <olist>
             <item><p>If {name} is not absent, then expose {name} and {target namespace} properties of the 
                      <b>[type definition]</b> property;</p></item>
             <item><p>Otherwise, expose the namespace and local name of the corresponding
             <termref def="dt-anonymous">anonymous type name</termref>.</p></item>
            </olist>
	    </p>
	  </item>
	  <item>
	    <p>
	      If the <b>[member type definition anonymous]</b> exists:
            <olist>
             <item><p>If it is false, then expose 
                      <b>[member type definition name]</b> and <b>[member type definition namespace]</b> properties;</p></item>
             <item><p>Otherwise, expose the namespace and local name of the corresponding 
             <termref def="dt-anonymous">anonymous type name</termref>.</p></item>
            </olist>  
	    </p>
	  </item>
	  <item>
	    <p>
	      If the <b>[type definition anonymous]</b> exists:
            <olist>
             <item><p>If it is false, then expose 
                      <b>[type definition name]</b> and <b>[type definition namespace]</b> properties;</p></item>
             <item><p>Otherwise, expose the namespace and local name of the corresponding 
                    <termref def="dt-anonymous">anonymous type name</termref>.</p></item>
            </olist>
	    </p>
	  </item>
	</olist>
      </item>
    </ulist>

    <note>
      <p>
	Other schema languages are outside the scope of the W3C and
	therefore should define how to represent their type systems using
	<code>TypeInfo</code>.
      </p>
    </note>    
  </descr>

  <attribute name="typeName" type="DOMString" id="TypeInfo-typeName" readonly="yes">
    <descr>
      <p>
	The name of a type declared for the associated element or
	attribute, or <code>null</code> if unknown.
      </p>
    </descr> 
  </attribute>

  <attribute name="typeNamespace" type="DOMString" id="TypeInfo-typeNamespace" readonly="yes"> 
    <descr>
      <p>
	The namespace of the type declared for the associated element or
	attribute or <code>null</code> if the element does not have
	declaration or if no namespace information is
	available. 
      </p>
    </descr>
  </attribute>

  <group name="DerivationMethods" id="TypeInfo-DerivationMethods">
    <descr>
      <p>
	These are the available values for the
	<code>derivationMethod</code> parameter used by the method
	<code>TypeInfo.isDerivedFrom()</code>. It is a set of possible
	types of derivation, and the values represent bit positions. If
	a bit in the <code>derivationMethod</code> parameter is set to
	<code>1</code>, the corresponding type of derivation will be
	taken into account when evaluating the derivation between the
	reference type definition and the other type definition. When
	using the <code>isDerivedFrom</code> method, combining all of
	them in the <code>derivationMethod</code> parameter is
	equivalent to invoking the method for each of them separately
	and combining the results with the OR boolean function. This
	specification only defines the type of derivation for XML
	Schema.
      </p>
	<p>
	  In addition to the types of derivation listed below, please
	  note that:
	</p>
	<ulist>
	  <item>
	    <p>
	      any type derives from <code>xsd:anyType</code>.
	    </p>
	  </item>
	  <item>
	    <p>
	      any simple type derives from
	      <code>xsd:anySimpleType</code> by
	      <term>restriction</term>.
	    </p>
	  </item>
	  <item>
	    <p>
	      any complex type does not derive from
	      <code>xsd:anySimpleType</code> by
	      <term>restriction</term>.
	    </p>
	  </item>
	</ulist>
    </descr>
    <constant id="TypeInfo-DERIVATION_RESTRICTION" name="DERIVATION_RESTRICTION" type="unsigned long" value="0x00000001">
      <descr>
	<p>
	  If the document's schema is an XML Schema <bibref ref="XMLSchema1"/>, this constant represents the derivation by
	  <xspecref xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/2001/REC-xmlschema-1-20010502/#key-typeRestriction" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">restriction</xspecref>
	  if complex types are involved, or a <xspecref xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/2001/REC-xmlschema-1-20010502/#element-restriction" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">restriction</xspecref>
	  if simple types are involved.
	</p>
	<p>
	  <termdef id="id-restriction" term="restriction">
	    The reference type definition is derived by
	    <term>restriction</term> from the other type definition if
	    the other type definition is the same as the reference type
	    definition, or if the other type definition can be reached
	    recursively following the {base type definition} property
	    from the reference type definition, and all the
	    <emph>derivation methods</emph> involved are
	    <term>restriction</term>.</termdef>
	</p>
      </descr>
    </constant>
    <constant id="TypeInfo-DERIVATION_EXTENSION" name="DERIVATION_EXTENSION" type="unsigned long" value="0x00000002">
      <descr>
	<p>
	  If the document's schema is an XML Schema <bibref ref="XMLSchema1"/>, this constant represents the derivation by
	  <xspecref xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/2001/REC-xmlschema-1-20010502/#key-typeExtension" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">extension</xspecref>.
	</p>
	<p>
	  <termdef id="id-extension" term="extension"> The reference
	  type definition is derived by <term>extension</term> from the
	  other type definition if the other type definition can be
	  reached recursively following the {base type definition}
	  property from the reference type definition, and at least one
	  of the <emph>derivation methods</emph> involved is an
	  <term>extension</term>.</termdef>
	</p>
      </descr>
    </constant>
    <constant id="TypeInfo-DERIVATION_UNION" name="DERIVATION_UNION" type="unsigned long" value="0x00000004">
      <descr>
	<p>
	  If the document's schema is an XML Schema <bibref ref="XMLSchema1"/>, this constant represents the <xspecref xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/2001/REC-xmlschema-1-20010502/#element-union" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">union</xspecref> if
	  simple types are involved.
	</p>
	<p>
	  <termdef id="id-union" term="union">The reference type
	  definition is derived by <term>union</term> from the other
	  type definition if there exists two type definitions T1 and T2
	  such as the reference type definition is derived from T1 by
	  <code>DERIVATION_RESTRICTION</code> or
	  <code>DERIVATION_EXTENSION</code>, T2 is derived from the
	  other type definition by <code>DERIVATION_RESTRICTION</code>,
	  T1 has {variety} <emph>union</emph>, and one of the {member
	  type definitions} is T2. Note that T1 could be the same as the
	  reference type definition, and T2 could be the same as the
	  other type definition.</termdef>
	</p>
      </descr>
    </constant>
    <constant id="TypeInfo-DERIVATION_LIST" name="DERIVATION_LIST" type="unsigned long" value="0x00000008">
      <descr>
	<p>
	  If the document's schema is an XML Schema <bibref ref="XMLSchema1"/>, this constant represents the <xspecref xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/2001/REC-xmlschema-1-20010502/#element-list" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">list</xspecref>.
	</p>
	<p>
	  <termdef id="id-list" term="list">The reference type
	  definition is derived by <term>list</term> from the other type
	  definition if there exists two type definitions T1 and T2 such
	  as the reference type definition is derived from T1 by
	  <code>DERIVATION_RESTRICTION</code> or
	  <code>DERIVATION_EXTENSION</code>, T2 is derived from the
	  other type definition by <code>DERIVATION_RESTRICTION</code>,
	  T1 has {variety} <emph>list</emph>, and T2 is the {item type
	  definition}. Note that T1 could be the same as the reference
	  type definition, and T2 could be the same as the other type
	  definition.</termdef>
	</p>
      </descr>
    </constant>
  </group>

  <method name="isDerivedFrom" id="TypeInfo-isDerivedFrom">
    <descr>
      <p>
	This method returns if there is a derivation between the
	reference type definition, i.e. the <code>TypeInfo</code> on
	which the method is being called, and the other type definition,
	i.e. the one passed as parameters.
      </p>
    </descr>
    <parameters>
      <param name="typeNamespaceArg" type="DOMString" attr="in">
	<descr>
	  <p>
	    the namespace of the other type definition.
	  </p>
	</descr>
      </param>
      <param name="typeNameArg" type="DOMString" attr="in">
	<descr>
	  <p>
	    the name of the other type definition.
	  </p>
	</descr>
      </param>
      <param name="derivationMethod" type="unsigned long" attr="in">
	<descr>
	  <p>
	    the type of derivation and conditions applied between two
	    types, as described in the list of constants provided in
	    this interface.
	  </p>
	</descr>
      </param>
    </parameters>
    <returns type="boolean">
      <descr>
	<p>
	  If the document's schema is a DTD or no schema is associated
	  with the document, this method will always return
	  <code>false</code>.
	</p>
	<p>
	  If the document's schema is an XML Schema, the method will
	  <code>true</code> if the reference type definition is derived
	  from the other type definition according to the derivation
	  parameter.  If the value of the parameter is <code>0</code>
	  (no bit is set to <code>1</code> for the
	  <code>derivationMethod</code> parameter), the method will
	  return <code>true</code> if the other type definition can be
	  reached by recursing any combination of {base type
	  definition}, {item type definition}, or {member type
	  definitions} from the reference type definition.
	</p>
      </descr>
    </returns>
    <raises>
    </raises>
  </method>
</interface>

      
<!-- $Id: userdata-handler.xml,v 1.16 2004/03/18 17:28:43 plehegar Exp $ -->
<interface name="UserDataHandler" id="UserDataHandler" since="DOM Level 3" role="ecmascript-function">
  <descr>
    <p>When associating an object to a key on a node using
      <code>Node.setUserData()</code> the application can provide a handler that gets
      called when the node the object is associated to is being cloned,
      imported, or renamed. This can be used by the application to implement
      various behaviors regarding the data it associates to the DOM nodes.
      This interface defines that handler.
    </p>
  </descr>
  <group id="ID-UserDataOperation" name="OperationType"> 
    <descr>
      <p>An integer indicating the type of operation being performed
        on a node.</p>
    </descr>
    <constant id="UserDataHandler-CLONED" name="NODE_CLONED" type="unsigned short" value="1"> 
      <descr>
        <p>The node is cloned, using <code>Node.cloneNode()</code>.</p>
      </descr>
    </constant>
    <constant id="UserDataHandler-IMPORTED" name="NODE_IMPORTED" type="unsigned short" value="2"> 
      <descr>
        <p>The node is imported, using <code>Document.importNode()</code>.</p>
      </descr>
    </constant>
    <constant id="UserDataHandler-DELETED" name="NODE_DELETED" type="unsigned short" value="3"> 
      <descr>
        <p>The node is deleted.</p>
        <note>
          <p>This may not be supported or may not be reliable in certain
            environments, such as Java, where the implementation has no real
            control over when objects are actually deleted.</p>
        </note>
      </descr>
    </constant>
    <constant id="UserDataHandler-RENAMED" name="NODE_RENAMED" type="unsigned short" value="4"> 
      <descr>
        <p>The node is renamed, using <code>Document.renameNode()</code>.</p>
      </descr>
    </constant>
    <constant id="UserDataHandler-ADOPTED" name="NODE_ADOPTED" type="unsigned short" value="5"> 
      <descr>
        <p>The node is adopted, using <code>Document.adoptNode()</code>.</p>
      </descr>
    </constant>
  </group>
  <method name="handle" id="ID-handleUserDataEvent">
    <descr>
      <p>This method is called whenever the node for which this handler is
        registered is imported or cloned.</p>
      <p>
	DOM applications must not raise exceptions in a
	<code>UserDataHandler</code>. The effect of throwing exceptions
	from the handler is DOM implementation dependent.
      </p>
    </descr>
    <parameters>
      <param name="operation" type="unsigned short" attr="in">
        <descr>
          <p>Specifies the type of operation that is being performed on the
            node.</p>
        </descr>
      </param>
      <param name="key" type="DOMString" attr="in">
        <descr>
          <p>Specifies the key for which this handler is being called.
          </p>
        </descr>
      </param>
      <param name="data" type="DOMUserData" attr="in">
        <descr>
          <p>Specifies the data for which this handler is being called.
          </p>
        </descr>
      </param>
      <param name="src" type="Node" attr="in">
        <descr>
          <p>Specifies the node being cloned, adopted, imported, or
	    renamed. This is <code>null</code> when the node is being
	    deleted.</p>
        </descr>
      </param>
      <param name="dst" type="Node" attr="in">
        <descr>
          <p>Specifies the node newly created if any, or <code>null</code>.</p>
        </descr>
      </param>
    </parameters>
    <returns type="void">
      <descr><p><!--empty paragraph--></p></descr>
    </returns>
    <raises>
      <!-- Throws no exceptions -->
    </raises>
  </method>
</interface>
 
<!-- $Id: error.xml,v 1.16 2004/02/25 18:53:32 plehegar Exp $ -->
<!--=====================================================================
=                                                                       =
=      DOMError                                                         =
=                                                                       =
======================================================================-->
<interface name="DOMError" id="ERROR-Interfaces-DOMError" since="DOM Level 3">
  <descr>
    <p><code>DOMError</code> is an interface that describes an error.</p>
  </descr>

  <group id="DOMError-errorSeverityCodes" name="ErrorSeverity">
    <descr>
      <p>
	An integer indicating the severity of the error.
      </p>
    </descr>
    <constant name="SEVERITY_WARNING" id="ERROR-DOMError-severity-warning" type="unsigned short" value="1">
      <descr>
	<p>The severity of the error described by the
	<code>DOMError</code> is warning. A
	<code>SEVERITY_WARNING</code> will not cause the processing to
	stop, unless <code>DOMErrorHandler.handleError()</code> returns
	<code>false</code>.</p>
      </descr>
    </constant>
    
    <constant name="SEVERITY_ERROR" id="ERROR-DOMError-severity-error" type="unsigned short" value="2">
      <descr>
	<p>The severity of the error described by the
	<code>DOMError</code> is error. A <code>SEVERITY_ERROR</code>
	may not cause the processing to stop if the error can be
	recovered, unless <code>DOMErrorHandler.handleError()</code>
	returns <code>false</code>.</p>
      </descr>
    </constant>
    
    <constant name="SEVERITY_FATAL_ERROR" id="ERROR-DOMError-severity-fatal-error" type="unsigned short" value="3">
      <descr>
	<p>The severity of the error described by the
	<code>DOMError</code> is fatal error. A
	<code>SEVERITY_FATAL_ERROR</code> will cause the normal
	processing to stop. The return value of
	<code>DOMErrorHandler.handleError()</code> is ignored unless the
	implementation chooses to continue, in which case the behavior
	becomes undefined.</p>
      </descr>
    </constant>
  </group>

  <attribute type="unsigned short" readonly="yes" name="severity" id="ERROR-DOMError-severity">
    <descr>
      <p>The severity of the error, either
        <code>SEVERITY_WARNING</code>, <code>SEVERITY_ERROR</code>,
        or <code>SEVERITY_FATAL_ERROR</code>.</p>
    </descr>
  </attribute>

  <attribute type="DOMString" readonly="yes" name="message" id="ERROR-DOMError-message">
    <descr>
      <p>An implementation specific string describing the error that
        occurred.</p>
    </descr>
  </attribute>

  <attribute name="type" type="DOMString" readonly="yes" id="ERROR-DOMError-type">
    <descr>
      <p>
	A <code>DOMString</code> indicating which related data is
	expected in <code>relatedData</code>. Users should refer to the
	specification of the error in order to find its
	<code>DOMString</code> type and <code>relatedData</code>
	definitions if any.
      </p>
      <note>
	<p>
	  As an example, <code>Document.normalizeDocument()</code> does
	  generate warnings when the "<termref def="parameter-split-cdata-sections">split-cdata-sections</termref>"
	  parameter is in use. Therefore, the method generates a
	  <code>SEVERITY_WARNING</code> with <code>type</code>
	  <code>"cdata-sections-splitted"</code> and the first
	  <code>CDATASection</code> node in document order resulting
	  from the split is returned by the <code>relatedData</code>
	  attribute.
	</p>
      </note>
    </descr>
  </attribute>

  <attribute type="DOMObject" readonly="yes" name="relatedException" id="ERROR-DOMError-relatedException">
    <descr>
      <p>The related platform dependent exception if any.</p>
    </descr>
  </attribute>

  <attribute type="DOMObject" readonly="yes" name="relatedData" id="ERROR-DOMError-relatedData">
    <descr>
      <p>
	The related <code>DOMError.type</code> dependent data if any.
      </p>
    </descr>
  </attribute>

  <attribute type="DOMLocator" readonly="yes" name="location" id="ERROR-DOMError-location">
    <descr>
      <p>The location of the error.</p>
    </descr>
  </attribute>
</interface>
 
<!-- $Id: error-handler.xml,v 1.12 2004/03/18 17:28:55 plehegar Exp $ -->
<!--=====================================================================
=                                                                       =
=      DOMErrorHandler                                                  =
=                                                                       =
======================================================================-->
<interface name="DOMErrorHandler" id="ERROR-Interfaces-DOMErrorHandler" since="DOM Level 3" role="ecmascript-function">
  <descr>
    <p>
      <code>DOMErrorHandler</code> is a callback interface that the DOM
      implementation can call when reporting errors that happens while
      processing XML data, or when doing some other processing
      (e.g. validating a document). A <code>DOMErrorHandler</code>
      object can be attached to a <code>Document</code> using the
      "<termref def="parameter-error-handler">error-handler</termref>"
      on the <code>DOMConfiguration</code> interface. If more than one
      error needs to be reported during an operation, the sequence and
      numbers of the errors passed to the error handler are
      implementation dependent.
    </p>
    <p>
      The application that is using the DOM implementation is expected
      to implement this interface.
    </p>
  </descr>

  <method name="handleError" id="ID-ERRORS-DOMErrorHandler-handleError">
    <descr>
      <p>This method is called on the error handler when an error occurs.</p>
      <p>
	If an exception is thrown from this method, it is considered to
	be equivalent of returning <code>true</code>.
      </p>
    </descr>

    <parameters>
      <param name="error" type="DOMError" attr="in">
        <descr>
          <p>
	    The error object that describes the error. This object may
	    be reused by the DOM implementation across multiple calls to
	    the <code>handleError</code> method.
	  </p>
        </descr>
      </param>
    </parameters>

    <returns type="boolean">
      <descr>
        <p>
	  If the <code>handleError</code> method returns
	  <code>false</code>, the DOM implementation should stop the
	  current processing when possible. If the method returns
	  <code>true</code>, the processing may continue depending on
	  <code>DOMError.severity</code>.
	</p>
      </descr>
    </returns>

    <raises>
      <!-- no exceptions -->
    </raises>
  </method>
</interface>

      
<!-- $Id: locator.xml,v 1.7 2003/08/16 01:51:19 plehegar Exp $ -->
<!--=====================================================================
=                                                                       =
=      DOMLocator                                                       =
=                                                                       =
======================================================================-->
<interface name="DOMLocator" id="Interfaces-DOMLocator" since="DOM Level 3">
  <descr>
    <p><code>DOMLocator</code> is an interface that describes a location
      (e.g. where an error occurred).</p>
  </descr>

  <attribute type="long" readonly="yes" name="lineNumber" id="DOMLocator-line-number">
    <descr>
      <p>The line number this locator is pointing to, or <code>-1</code> if
        there is no column number available.</p>
    </descr>
  </attribute>

  <attribute type="long" readonly="yes" name="columnNumber" id="DOMLocator-column-number">
    <descr>
      <p>The column number this locator is pointing to, or <code>-1</code> if
        there is no column number available.</p>
    </descr>
  </attribute>

  <attribute type="long" readonly="yes" name="byteOffset" id="DOMLocator-byteOffset">
    <descr>
      <p>The byte offset into the input source this locator is pointing
      to or <code>-1</code> if there is no byte offset available.</p>
    </descr>
  </attribute>

  <attribute type="long" readonly="yes" name="utf16Offset" id="DOMLocator-utf16Offset">
    <descr>
      <p>The UTF-16, as defined in <bibref ref="Unicode"/> and Amendment
      1 of <bibref ref="ISO10646"/>, offset into the input source this
      locator is pointing to or <code>-1</code> if there is no UTF-16
      offset available.</p>
    </descr>
  </attribute>

  <attribute type="Node" readonly="yes" name="relatedNode" id="DOMLocator-node">
    <descr>
      <p>The node this locator is pointing to, or <code>null</code> if no node
        is available.</p>
    </descr>
  </attribute>

  <attribute type="DOMString" readonly="yes" name="uri" id="DOMLocator-uri">
    <descr>
      <p>The URI this locator is pointing to, or <code>null</code> if no URI
        is available.</p>
    </descr>
  </attribute>
</interface>
 
<!-- $Id: configuration.xml,v 1.58 2004/04/07 17:10:05 plehegar Exp $: -->
<interface name="DOMConfiguration" id="DOMConfiguration" since="DOM Level 3">
  <descr>
    <p>
      The <code>DOMConfiguration</code> interface represents the
      configuration of a document and maintains a table of recognized
      parameters. Using the configuration, it is possible to change
      <code>Document.normalizeDocument()</code> behavior, such as
      replacing the <code>CDATASection</code> nodes with
      <code>Text</code> nodes or specifying the type of the <termref def="dt-schema">schema</termref> that must be used when the
      validation of the <code>Document</code> is
      requested. <code>DOMConfiguration</code> objects are also used in
      <bibref role="informative" ref="DOMLS"/> in the
      <code>DOMParser</code> and <code>DOMSerializer</code> interfaces.
    </p>
    <p>
      The parameter names used by the <code>DOMConfiguration</code>
      object are defined throughout the DOM Level 3
      specifications. Names are case-insensitive. To avoid possible
      conflicts, as a convention, names referring to parameters defined
      outside the DOM specification should be made unique. Because
      parameters are exposed as properties in the <specref ref="ecma-binding"/>, names are recommended to follow the section
      <quote>5.16 Identifiers</quote> of <bibref role="informative" ref="Unicode"/> with the addition of the character '-'
      (HYPHEN-MINUS) but it is not enforced by the DOM
      implementation. DOM Level 3 Core Implementations are required to
      recognize all parameters defined in this specification. Some
      parameter values may also be required to be supported by
      the implementation. Refer to the definition of the parameter to
      know if a value must be supported or not.
    </p>
    <note>
      <p>
	Parameters are similar to features and properties used in SAX2
	<bibref role="informative" ref="SAX"/>.
      </p>
    </note>

    <p>
      The following list of parameters defined in the DOM:
    </p>    
    <glist>
      
      <gitem>
	<label id="parameter-canonical-form"><code>"canonical-form"</code></label>
	<def>
	  <glist>
	    <gitem>
	      <label><code>true</code></label>
	      <def>
		<p>[<emph>optional</emph>]</p>
		<p>
		  Canonicalize the document according to the rules
		  specified in <bibref role="informative" ref="c14n"/>,
		  such as removing the <code>DocumentType</code> node (if
		  any) from the tree, or removing superfluous namespace
		  declarations from each element. Note that this is
		  limited to what can be represented in the DOM; in
		  particular, there is no way to specify the order of
		  the attributes in the DOM. In addition,
		</p>
		<p>
		  Setting this parameter to <code>true</code> will also
		  set the state of the parameters listed below. Later
		  changes to the state of one of those parameters will
		  revert "<termref def="parameter-canonical-form">canonical-form</termref>"
		  back to <code>false</code>.
		</p>
		<p>Parameters set to
		  <code>false</code>:
		  "<termref def="parameter-entities">entities</termref>",
		  "<termref def="parameter-normalize-characters">normalize-characters</termref>",
		  "<termref def="parameter-cdata-sections">cdata-sections</termref>".
		</p>
		<p>Parameters set to
		  <code>true</code>:
		  "<termref def="parameter-namespaces">namespaces</termref>",
		  "<termref def="parameter-namespace-declarations">namespace-declarations</termref>",
		  "<termref def="parameter-well-formed">well-formed</termref>",
		  "<termref def="parameter-element-content-whitespace">element-content-whitespace</termref>".
		</p>
		<p>Other parameters are not changed unless explicitly specified
		  in the description of the parameters.</p>
	      </def>
	    </gitem>
	    <gitem>
	      <label><code>false</code></label>
	      <def>
		<p>[<emph>required</emph>] (<emph>default</emph>)</p>
		<p>Do not canonicalize the document.</p>
	      </def>
	    </gitem>
	  </glist>
	</def>
      </gitem>
        <gitem>
          <label id="parameter-cdata-sections"><code>"cdata-sections"</code></label>
          <def>
            <glist>
              <gitem>
                <label><code>true</code></label>
                <def>
                  <p>[<emph>required</emph>] (<emph>default</emph>)</p>
                  <p>Keep <code>CDATASection</code> nodes in the document.</p>
                </def>
              </gitem>
              <gitem>
                <label><code>false</code></label>
                <def>
                  <p>[<emph>required</emph>]</p>
                  <p>Transform <code>CDATASection</code> nodes in the document
                    into <code>Text</code> nodes. The new <code>Text</code>
                    node is then combined with any adjacent <code>Text</code>
                    node.</p>
                </def>
              </gitem>
            </glist>
          </def>
        </gitem>
        <gitem>
          <label id="parameter-check-character-normalization"><code>"check-character-normalization"</code></label>
          <def>
            <glist>
              <gitem>
                <label><code>true</code></label>
                <def>
                  <p>[<emph>optional</emph>]</p>
		<p>
		  Check if the characters in the document are <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/2004/REC-xml11-20040204/#dt-fullnorm" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">fully
		  normalized</loc>, as defined in appendix B of <bibref ref="XML11"/>.  When a sequence of characters is
		  encountered that fails normalization checking, an
		  error with the <code>DOMError.type</code> equals to
		  "check-character-normalization-failure" is issued.
		</p>
                </def>
              </gitem>
              <gitem>
                <label><code>false</code></label>
                <def>
                  <p>[<emph>required</emph>] (<emph>default</emph>)</p>
                  <p>Do not check if characters are normalized.</p>
                </def>
              </gitem>
            </glist>
          </def>
        </gitem>
        <gitem>
          <label id="parameter-comments"><code>"comments"</code></label>
          <def>
            <glist>
              <gitem>
                <label><code>true</code></label>
                <def>
                  <p>[<emph>required</emph>] (<emph>default</emph>)</p>
                  <p>Keep <code>Comment</code> nodes in the document.</p>
                </def>
              </gitem>
              <gitem>
                <label><code>false</code></label>
                <def>
                  <p>[<emph>required</emph>]</p>
                  <p>Discard <code>Comment</code> nodes in the document.</p>
                </def>
              </gitem>
            </glist>
          </def>
        </gitem>
        <gitem>
          <label id="parameter-datatype-normalization"><code>"datatype-normalization"</code></label>
          <def>
            <glist>
              <gitem>
                <label><code>true</code></label>
                <def>
                  <p>[<emph>optional</emph>]</p>
		<p>
		  Expose schema normalized values in the tree, such as
		  <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/2001/REC-xmlschema-1-20010502/#key-nv" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">XML Schema
		  normalized values</loc> in the case of XML
		  Schema. Since this parameter requires to have <termref def="dt-schema">schema</termref> information, the
		  "<termref def="parameter-validate">validate</termref>"
		  parameter will also be set to
		  <code>true</code>. Having this parameter activated
		  when "validate" is <code>false</code> has no effect
		  and no schema-normalization will happen.
		</p>
		<note>
		  <p>
		    Since the document contains the result of the XML
		    1.0 processing, this parameter does not apply to
		    attribute value normalization as defined in section
		    3.3.3 of <bibref ref="XML"/> and is only meant for
		    <termref def="dt-schema">schema</termref> languages
		    other than Document Type Definition (DTD).
		  </p>
		</note>
	        </def>
              </gitem>
              <gitem>
                <label><code>false</code></label>
                <def>
                  <p>[<emph>required</emph>] (<emph>default</emph>)</p>
		<p>
		  Do not perform schema normalization on the tree.
		</p>
                </def>
              </gitem>
            </glist>
          </def>
        </gitem>
        <gitem>
          <label id="parameter-element-content-whitespace"><code>"element-content-whitespace"</code></label>
          <def>
            <glist>
              <gitem>
                <label><code>true</code></label>
                <def>
                  <p>[<emph>required</emph>] (<emph>default</emph>)</p>
                  <p>Keep all whitespaces in the document.</p>
                </def>
              </gitem>
              <gitem>
                <label><code>false</code></label>
                <def>
                  <p>[<emph>optional</emph>]</p>
                  <p>
		    Discard all <code>Text</code> nodes that contain
		    whitespaces in element content, as described in
		    <xspecref xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/2004/REC-xml-infoset-20040204#infoitem.character" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">[element content
		    whitespace]</xspecref>.  The implementation is
		    expected to use the attribute
		    <code>Text.isElementContentWhitespace</code> to
		    determine if a <code>Text</code> node should be
		    discarded or not.</p>
                </def>
              </gitem>
            </glist>
          </def>
        </gitem>
        <gitem>
          <label id="parameter-entities"><code>"entities"</code></label>
	  <def>
            <glist>
              <gitem>
                <label><code>true</code></label>
                <def>
                  <p>[<emph>required</emph>] (<emph>default</emph>)</p>
                  <p>Keep <code>EntityReference</code> nodes in the
                  document.</p>
                </def>
              </gitem>
              <gitem>
                <label><code>false</code></label>
                <def>
                  <p>[<emph>required</emph>]</p>
                  <p>
		  Remove all <code>EntityReference</code> nodes from the
		  document, putting the entity expansions directly in
		  their place.  <code>Text</code> nodes are normalized,
		  as defined in <code>Node.normalize</code>. Only <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/2004/REC-xml-infoset-20040204/#infoitem.rse" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">unexpanded entity
		  references</loc> are kept in the document.
		</p>
                </def>
              </gitem>
  	      </glist>
	  <note>
	    <p>
	      This parameter does not affect <code>Entity</code> nodes.
	    </p>
	  </note>
          </def>
        </gitem>
      <gitem>
	<label id="parameter-error-handler"><code>"error-handler"</code></label>
	<def>
	  <p>[<emph>required</emph>]</p>
	  <p>
	    Contains a <code>DOMErrorHandler</code> object. If an error
	    is encountered in the document, the implementation will call
	    back the <code>DOMErrorHandler</code> registered using this
	    parameter. The implementation may provide a default
	    <code>DOMErrorHandler</code> object.
	  </p>
	  <p>
	    When called, <code>DOMError.relatedData</code> will contain
	    the closest node to where the error occurred. If the
	    implementation is unable to determine the node where the
	    error occurs, <code>DOMError.relatedData</code> will contain
	    the <code>Document</code> node. Mutations to the document
	    from within an error handler will result in implementation
	    dependent behavior.
	  </p>
	</def>
      </gitem>
        <gitem>
          <label id="parameter-infoset"><code>"infoset"</code></label>
          <def>
            <glist>
              <gitem>
                <label><code>true</code></label>
                <def>
                  <p>[<emph>required</emph>]</p>
                  <p>Keep in the document the information defined in the
                    XML Information Set <bibref ref="InfoSet"/>.</p>
                  <p>This forces the following parameters to
                    <code>false</code>:
                    "<termref def="parameter-validate-if-schema">validate-if-schema</termref>",
                    "<termref def="parameter-entities">entities</termref>",
                    "<termref def="parameter-datatype-normalization">datatype-normalization</termref>",
                    "<termref def="parameter-cdata-sections">cdata-sections</termref>".</p>
                  <p>This forces the following parameters to
                    <code>true</code>:
                    "<termref def="parameter-namespace-declarations">namespace-declarations</termref>",
                    "<termref def="parameter-well-formed">well-formed</termref>",
                    "<termref def="parameter-element-content-whitespace">element-content-whitespace</termref>",
                    "<termref def="parameter-comments">comments</termref>", "<termref def="parameter-namespaces">namespaces</termref>".</p>
                  <p>Other parameters are not changed unless explicitly specified
                    in the description of the parameters.</p>
                  <p> Note that querying this parameter with
                    <code>getParameter</code> returns <code>true</code> only if
                    the individual parameters specified above are appropriately
                    set.</p>
                </def>
              </gitem>
              <gitem>
                <label><code>false</code></label>
                <def>
                  <p>Setting <code>infoset</code> to <code>false</code>
                    has no effect.</p>
                </def>
              </gitem>
            </glist>
          </def>
        </gitem>
      <gitem>
	<label id="parameter-namespaces"><code>"namespaces"</code></label>
	<def>
	  <glist>
	    <gitem>
	      <label><code>true</code></label>
	      <def>
		<p>[<emph>required</emph>] (<emph>default</emph>)</p>
		<p>
		  Perform the namespace processing as defined in
		  <specref ref="normalizeDocumentAlgo"/>.
		</p>
	      </def>
	    </gitem>
	    <gitem>
	      <label><code>false</code></label>
	      <def>
		<p>[<emph>optional</emph>]</p>
		<p>
		  Do not perform the namespace processing.
		</p>
	      </def>
	    </gitem>
	  </glist>
	</def>
      </gitem>
        <gitem>
          <label id="parameter-namespace-declarations"><code>"namespace-declarations"</code></label>
          <def>
	  <p>
	    This parameter has no effect if the parameter "<termref def="parameter-namespaces">namespaces</termref>" is set to
	    <code>false</code>.
	  </p>
            <glist>
              <gitem>
                <label><code>true</code></label>
                <def>
                  <p>[<emph>required</emph>] (<emph>default</emph>)</p>
                  <p>
		  Include namespace declaration attributes, specified or
		  defaulted from the <termref def="dt-schema">schema</termref>, in the document. See
		  also the sections "Declaring Namespaces" in <bibref ref="Namespaces"/> and <bibref ref="Namespaces11"/>.</p>
                </def>
              </gitem>
              <gitem>
                <label><code>false</code></label>
                <def>
                  <p>[<emph>required</emph>]</p>
                  <p>Discard all namespace declaration attributes. The
		  namespace prefixes (<code>Node.prefix</code>) are
		  retained even if this parameter is set
                    to <code>false</code>.</p>
                </def>
              </gitem>
            </glist>
          </def>
        </gitem>
        <gitem>
          <label id="parameter-normalize-characters"><code>"normalize-characters"</code></label>
          <def>
            <glist>
              <gitem>
                <label><code>true</code></label>
                <def>
                  <p>[<emph>optional</emph>]</p>
		<p>
		  <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/2004/REC-xml11-20040204/#dt-fullnorm" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Fully
		  normalized</loc> the characters in the document as
		  defined in appendix B of <bibref ref="XML11"/>.
		</p>
                </def>
              </gitem>
              <gitem>
                <label><code>false</code></label>
                <def>
                  <p>[<emph>required</emph>] (<emph>default</emph>)</p>
                  <p>Do not perform character normalization.</p>
                </def>
              </gitem>
            </glist>
          </def>
        </gitem>
      <gitem>
	<label id="parameter-schema-location"><code>"schema-location"</code></label>
	<def>
	  <p>[<emph>optional</emph>]</p>
	  <p>
	    Represent a <code>DOMString</code> object containing a list
	    of URIs, separated by whitespaces (characters matching the
	    <xspecref xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/2004/REC-xml-20040204#NT-S" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">nonterminal production
	    S</xspecref> defined in section 2.3 <bibref ref="XML"/>),
	    that represents the <termref def="dt-schema">schemas</termref> against which validation
	    should occur, i.e. the current schema. The types of schemas
	    referenced in this list must match the type specified with
	    <code>schema-type</code>, otherwise the behavior of an
	    implementation is undefined.
	  </p>
	  <p>
	    The schemas specified using this property take precedence to
	    the schema information specified in the document itself. For
	    namespace aware schema, if a schema specified using this
	    property and a schema specified in the document instance
	    (i.e. using the <code>schemaLocation</code> attribute) in a
	    schema document (i.e. using schema <code>import</code>
	    mechanisms) share the same <code>targetNamespace</code>, the
	    schema specified by the user using this property will be
	    used. If two schemas specified using this property share the
	    same <code>targetNamespace</code> or have no namespace, the
	    behavior is implementation dependent.
	  </p>
	  <p>
	    If no location has been provided, this parameter is
	    <code>null</code>.
	  </p>
	  <note>
	    <p>
	      The <code>"schema-location"</code> parameter is ignored
	      unless the "<termref def="parameter-schema-type">schema-type</termref>"
	      parameter value is set. It is strongly recommended that
	      <code>Document.documentURI</code> will be set so that an
	      implementation can successfully resolve any external
	      entities referenced.
	    </p>
	  </note>
	</def>
      </gitem>
      <gitem>
	<label id="parameter-schema-type"><code>"schema-type"</code></label>
	<def>
	  <p>[<emph>optional</emph>]</p>
	  <p>
	    Represent a <code>DOMString</code> object containing an
	    absolute URI and representing the type of the <termref def="dt-schema">schema</termref> language used to validate a
	    document against. Note that no lexical checking is done on
	    the absolute URI.
	  </p>
	  <p>
	    If this parameter is not set, a default value may be
	    provided by the implementation, based on the schema
	    languages supported and on the schema language used at load
	    time. If no value is provided, this parameter is
	    <code>null</code>.
          </p>
	  <note>
	    <p>
	      For XML Schema <bibref ref="XMLSchema1"/>, applications
	      must use the value
	      <code>"http://www.w3.org/2001/XMLSchema"</code>. For XML
	      DTD <bibref ref="XML"/>, applications must use the value
	      <code>"http://www.w3.org/TR/REC-xml"</code>. Other schema
	      languages are outside the scope of the W3C and therefore
	      should recommend an absolute URI in order to use this
	      method.
	    </p>
	  </note>
	</def>
      </gitem>
        <gitem>
          <label id="parameter-split-cdata-sections"><code>"split-cdata-sections"</code></label>
          <def>
            <glist>
              <gitem>
                <label><code>true</code></label>
                <def>
                  <p>[<emph>required</emph>] (<emph>default</emph>)</p>
                  <p>Split CDATA sections containing the CDATA section
                    termination marker ']]&gt;'. When a CDATA section is split
                    a warning is issued with a
		  <code>DOMError.type</code> equals to
		  <code>"cdata-sections-splitted"</code> and
		  <code>DOMError.relatedData</code> equals to the first
		  <code>CDATASection</code> node in document order
		  resulting from the split.</p>
                </def>
              </gitem>
              <gitem>
                <label><code>false</code></label>
                <def>
                  <p>[<emph>required</emph>]</p>
                  <p>Signal an error if a <code>CDATASection</code> contains
                    an unrepresentable character.</p>
                </def>
              </gitem>
            </glist>
          </def>
        </gitem>
      <gitem>
	<label id="parameter-validate"><code>"validate"</code></label>
	<def>
	  <glist>
	    <gitem>
	      <label><code>true</code></label>
	      <def>
		<p>[<emph>optional</emph>]</p>	
		<p>
		  Require the validation against a <termref def="dt-schema">schema</termref> (i.e. XML schema,
		  DTD, any other type or representation of schema) of
		  the document as it is being normalized as defined by
		  <bibref ref="XML"/>. If validation errors are found,
		  or no schema was found, the error handler is
		  notified. Schema-normalized values will not be exposed
		  according to the schema in used unless the parameter
		  "<termref def="parameter-datatype-normalization">datatype-normalization</termref>"
		  is <code>true</code>.
		</p>
		<p>
		  This parameter will reevaluate:
		</p>
		<ulist>
		  <item>
		    <p>
		      Attribute nodes with <code>Attr.specified</code>
		      equals to <code>false</code>, as specified in the
		      description of the <code>Attr</code> interface;
		    </p>
		  </item>
		  <item>
		    <p>
		      The value of the attribute
		      <code>Text.isElementContentWhitespace</code> for
		      all <code>Text</code> nodes;
		    </p>
		  </item>
		  <item>
		    <p>
		      The value of the attribute <code>Attr.isId</code>
		      for all <code>Attr</code> nodes;
		    </p>
		  </item>
		  <item>
		    <p>
		      The attributes <code>Element.schemaTypeInfo</code>
		      and <code>Attr.schemaTypeInfo</code>.
		    </p>
		  </item>
		</ulist>
		<note>
		  <p>
		    "<termref def="parameter-validate-if-schema">validate-if-schema</termref>"
		    and "validate" are mutually exclusive,
		    setting one of them to <code>true</code> will set
		    the other one to <code>false</code>. Applications
		    should also consider setting the parameter
		    "<termref def="parameter-well-formed">well-formed</termref>" to <code>true</code>,
		    which is the default for that option, when
		    validating the document.
		  </p>
		</note>
	      </def>
	    </gitem>
	    <gitem>
	      <label><code>false</code></label>
	      <def>
		<p>[<emph>required</emph>] (<emph>default</emph>)</p>
		<p>
		  Do not accomplish schema processing, including the
		  internal subset processing. Default attribute values
		  information are kept. Note that validation might still
		  happen if "<termref def="parameter-validate-if-schema">validate-if-schema</termref>"
		  is <code>true</code>.
		</p>
	      </def>
	    </gitem>
	  </glist>
	</def>
      </gitem>
        <gitem>
          <label id="parameter-validate-if-schema"><code>"validate-if-schema"</code></label>
          <def>
            <glist>
              <gitem>
                <label><code>true</code></label>
                <def>
                  <p>[<emph>optional</emph>]</p>
                  <p>Enable validation only if a declaration for the
                  document element can be found in a <termref def="dt-schema">schema</termref> (independently of where
                  it is found, i.e. XML schema, DTD, or any other type
                  or representation of schema). If validation is
                  enabled, this parameter has the same behavior as the
                  parameter "<termref def="parameter-validate">validate</termref>" set to
                  <code>true</code>.
		</p>
		  <note>
		    <p>
		      "validate-if-schema" and
		      "<termref def="parameter-validate">validate</termref>" are mutually exclusive,
		      setting one of them to <code>true</code> will
		      set the other one to <code>false</code>.
		    </p>
		  </note>
                </def>
              </gitem>
              <gitem>
                <label><code>false</code></label>
                <def>
                  <p>[<emph>required</emph>] (<emph>default</emph>)</p>
                  <p>
		  No schema processing should be performed if the
		  document has a schema, including internal subset
		  processing. Default attribute values information are
		  kept. Note that validation must still happen if
		  "<termref def="parameter-validate">validate</termref>"
		  is <code>true</code>.
		  </p>
                </def>
              </gitem>
            </glist>
          </def>
        </gitem>
      <gitem>
	<label id="parameter-well-formed"><code>"well-formed"</code></label>
	<def>
	  <glist>
	    <gitem>
	      <label><code>true</code></label>
	      <def>
		<p>[<emph>required</emph>] (<emph>default</emph>)</p>
		<p>
		  Check if all nodes are XML <termref def="dt-well-formed">well formed</termref> according
		  to the XML version in use in
		  <code>Document.xmlVersion</code>:
		</p>
		<ulist>
		  <item>
		    <p>
		      check if the attribute <code>Node.nodeName</code>
		      contains invalid characters according to its node
		      type and generate a <code>DOMError</code> of type
		      <code>"wf-invalid-character-in-node-name"</code>,
		      with a <code>DOMError.SEVERITY_ERROR</code>
		      severity, if necessary;
		    </p>
		  </item>
		  <item>
		    <p>
		      check if the text content inside
		      <code>Attr</code>, <code>Element</code>,
		      <code>Comment</code>, <code>Text</code>,
		      <code>CDATASection</code> nodes for invalid
		      characters and generate a <code>DOMError</code> of
		      type <code>"wf-invalid-character"</code>, with a
		      <code>DOMError.SEVERITY_ERROR</code> severity, if
		      necessary;
		    </p>
		  </item>
		  <item>
		    <p>
		      check if the data inside
		      <code>ProcessingInstruction</code> nodes for
		      invalid characters and generate a
		      <code>DOMError</code> of type
		      <code>"wf-invalid-character"</code>, with a
		      <code>DOMError.SEVERITY_ERROR</code> severity, if
		      necessary;
		    </p>
		  </item>
		</ulist>
	      </def>
	    </gitem>
	    <gitem>
	      <label><code>false</code></label>
	      <def>
		<p>[<emph>optional</emph>]</p>
		<p>
		  Do not check for XML well-formedness.
		</p>
	      </def>
	    </gitem>
	  </glist>
	</def>
      </gitem>
    </glist>

    <p>
      The resolution of the system identifiers associated with entities
      is done using <code>Document.documentURI</code>. However, when the
      feature "LS" defined in <bibref role="informative" ref="DOMLS"/>
      is supported by the DOM implementation, the parameter
      "resource-resolver" can also be used on
      <code>DOMConfiguration</code> objects attached to
      <code>Document</code> nodes. If this parameter is set,
      <code>Document.normalizeDocument()</code> will invoke the resource
      resolver instead of using <code>Document.documentURI</code>.
    </p>

  </descr>

  <method name="setParameter" id="DOMConfiguration-property">
    <descr>
      <p>Set the value of a parameter.</p>
    </descr>
    <parameters>
      <param name="name" type="DOMString" attr="in">
        <descr>
          <p>The name of the parameter to set.</p>
        </descr>
      </param>
      <param name="value" type="DOMUserData" attr="in">
        <descr>
          <p>
	    The new value or <code>null</code> if the user wishes to
	    unset the parameter. While the type of the value parameter
	    is defined as <code>DOMUserData</code>, the object type must
	    match the type defined by the definition of the
	    parameter. For example, if the parameter is <termref def="parameter-error-handler">"error-handler"</termref>, the
	    value must be of type <code>DOMErrorHandler</code>.
	  </p>
        </descr>
      </param>
    </parameters>
    <returns type="void">
      <descr>
      </descr>
    </returns>
    <raises>
      <exception name="DOMException">
        <descr>
	  <p>
	    NOT_FOUND_ERR: Raised when the parameter name is not
	    recognized.
	  </p>
          <p>
	    NOT_SUPPORTED_ERR: Raised when the parameter name is
	    recognized but the requested value cannot be set.
	  </p>
	  <p>
	    TYPE_MISMATCH_ERR: Raised if the value type for this
	    parameter name is incompatible with the expected value type.
	  </p>
        </descr>
      </exception>
    </raises>
  </method>

  <method name="getParameter" id="DOMConfiguration-getParameter">
    <descr>
      <p>
	Return the value of a parameter if known.
      </p>
    </descr>

    <parameters>
      <param name="name" type="DOMString" attr="in">
        <descr>
          <p>
	    The name of the parameter.
	  </p>
        </descr>
      </param>
    </parameters>

    <returns type="DOMUserData">
      <descr>
        <p>
	  The current object associated with the specified parameter or
	  <code>null</code> if no object has been associated or if the
	  parameter is not supported.
	</p>
      </descr>
    </returns>

    <raises>
      <exception name="DOMException">
        <descr>
          <p>
	    NOT_FOUND_ERR: Raised when the parameter name is not
	    recognized.
	  </p>
        </descr>
      </exception>
    </raises>
  </method>

  <method name="canSetParameter" id="DOMConfiguration-canSetParameter">
    <descr>
      <p>Check if setting a parameter to a specific value is supported.</p>
    </descr>
    <parameters>
      <param name="name" type="DOMString" attr="in">
        <descr>
          <p>The name of the parameter to check.</p>
        </descr>
      </param>
      <param name="value" type="DOMUserData" attr="in">
        <descr>
          <p>
	    An object. if <code>null</code>, the returned value is
	    <code>true</code>.
	  </p>
        </descr>
      </param>
    </parameters>
    <returns type="boolean">
      <descr>
        <p>
	  <code>true</code> if the parameter could be successfully set
	  to the specified value, or <code>false</code> if the parameter
	  is not recognized or the requested value is not
	  supported. This does not change the current value of the
	  parameter itself.
	</p>
      </descr>
    </returns>

    <raises>
    </raises>
  </method>

  <attribute name="parameterNames" type="DOMStringList" readonly="yes" id="DOMConfiguration-parameterNames">
    <descr>
      <p>
	The list of the parameters supported by this
	<code>DOMConfiguration</code> object and for which at least one
	value can be set by the application. Note that this list can
	also contain parameter names defined outside this specification.
      </p>
    </descr>
  </attribute>
</interface>

    </definitions>
  </div2>
  <div2 id="ID-E067D597">
    <head>Extended Interfaces: XML Module</head>
    <p>The interfaces defined here form part of the DOM Core specification, but
      objects that expose these interfaces will never be encountered in a DOM
      implementation that deals only with HTML.</p>
    <p>
      The interfaces found within this section are not mandatory. A DOM
      application may use the
      <code>DOMImplementation.hasFeature(feature, version)</code> method
      with parameter values "XML" and "3.0" (respectively) to determine
      whether or not this module is supported by the implementation. In
      order to fully support this module, an implementation must also
      support the "Core" feature defined in <specref ref="ID-BBACDC08"/>
      and the feature "XMLVersion" with version "1.0" defined in
      <code>Document.xmlVersion</code>. Please refer to additional
      information about <specref ref="ID-Conformance"/> in this
      specification. The DOM Level 3 XML module is backward compatible
      with the DOM Level 2 XML <bibref role="informative" ref="DOM2Core"/> and DOM Level 1 XML <bibref role="informative" ref="DOM-Level-1"/> modules, i.e. a DOM Level 3 XML implementation
      who returns <code>true</code> for "XML" with the
      <code>version</code> number <code>"3.0"</code> must also return
      <code>true</code> for this <code>feature</code> when the
      <code>version</code> number is <code>"2.0"</code>,
      <code>"1.0"</code>, <code>""</code> or, <code>null</code>.
    </p>

    <definitions> 
<!--[ CDATA Section ]-->
<!-- $Date: 2003/06/18 16:55:57 $ $Revision: 1.4 $ -->
<interface name="CDATASection" inherits="Text" id="ID-667469212">
  <descr>
    <p>CDATA sections are used to escape blocks of text containing characters
      that would otherwise be regarded as markup. The only delimiter that is
      recognized in a CDATA section is the "]]&gt;" string that ends the CDATA
      section. CDATA sections cannot be nested. Their primary purpose is for
      including material such as XML fragments, without needing to escape all
      the delimiters.</p><p>The <code>CharacterData.data</code> attribute 
      holds the text that is contained by the CDATA
      section. Note that this <emph>may</emph> contain characters that need to
      be escaped outside of CDATA sections and that, depending on the character
      encoding ("charset") chosen for serialization, it may be impossible to
      write out some characters as part of a CDATA section.</p>
    <p>The <code>CDATASection</code> interface inherits from the
      <code>CharacterData</code> interface through the <code>Text</code>
      interface. Adjacent <code>CDATASection</code> nodes are not merged by use
      of the <code>normalize</code> method of the <code>Node</code>
      interface.</p>
    <p>
      No lexical check is done on the content of a CDATA section and it
      is therefore possible to have the character sequence
      <code>"]]&gt;"</code> in the content, which is illegal in a CDATA
      section per section 2.7 of <bibref ref="XML"/>. The presence of
      this character sequence must generate a fatal error during
      serialization or the cdata section must be splitted before the
      serialization (see also the parameter
      <code>"split-cdata-sections"</code> in the
      <code>DOMConfiguration</code> interface).
    </p>
    <note>
      <p>Because no markup is recognized within a <code>CDATASection</code>,
	character numeric references cannot be used as an escape mechanism
	when serializing. Therefore, action needs to be taken when serializing
	a <code>CDATASection</code> with a character encoding where some of
	the contained characters cannot be represented. Failure to do so would
	not produce well-formed XML.</p>
      <p>One potential solution in the serialization process is to end the
	CDATA section before the character, output the character using a 
	character reference or entity reference, and open a new CDATA section 
	for any further characters in the text node. Note, however, that some 
	code conversion libraries at the time of writing do not return an
	error or exception when a character is missing from the encoding, 
	making the task of ensuring that data is not corrupted on serialization
	more difficult.</p> 
    </note>
  </descr>
</interface>
 
<!--[ DocumentType object description ]-->
<interface name="DocumentType" inherits="Node" id="ID-412266927">
  <descr>
    <p>Each <code>Document</code> has a <code>doctype</code> attribute whose
      value is either <code>null</code> or a <code>DocumentType</code>
      object. The <code>DocumentType</code> interface in the DOM Core provides
      an interface to the list of entities that are defined for the document,
      and little else because the effect of namespaces and the various XML
      schema efforts on DTD representation are not clearly understood as of
      this writing.</p>
    <p>DOM Level 3 doesn't support editing <code>DocumentType</code>
      nodes. <code>DocumentType</code> nodes are <termref def="dt-readonly-node">read-only</termref>.</p>
  </descr> 

  <attribute readonly="yes" name="name" type="DOMString" id="ID-1844763134">
    <descr>
      <p>The name of DTD; i.e., the name immediately following the
        <code>DOCTYPE</code> keyword.</p>
    </descr>
  </attribute>

  <attribute readonly="yes" name="entities" type="NamedNodeMap" id="ID-1788794630">
    <descr>
      <p>A <code>NamedNodeMap</code> containing the general entities, both
	external and internal, declared in the DTD. Parameter entities are not 
        contained. Duplicates are discarded. For example in:
        <eg role="code" xml:space="preserve">&lt;!DOCTYPE ex SYSTEM "ex.dtd" [
  &lt;!ENTITY foo "foo"&gt;
  &lt;!ENTITY bar "bar"&gt;
  &lt;!ENTITY bar "bar2"&gt;
  &lt;!ENTITY % baz "baz"&gt;
]&gt;
&lt;ex/&gt;</eg>  
	the interface provides access to <code>foo</code> and the first
        declaration of <code>bar</code> but not the second declaration of
        <code>bar</code> or <code>baz</code>. Every node in this map also
        implements the <code>Entity</code> interface.</p>
      <p>The DOM Level 2 does not support editing entities, therefore
        <code>entities</code> cannot be altered in any way.</p>
    </descr>
  </attribute>

  <attribute readonly="yes" name="notations" type="NamedNodeMap" id="ID-D46829EF">
    <descr>
      <p>A <code>NamedNodeMap</code> containing the notations declared in the
        DTD. Duplicates are discarded. Every node in this map also implements
        the <code>Notation</code> interface.</p>
      <p>The DOM Level 2 does not support editing notations, therefore
        <code>notations</code> cannot be altered in any way.</p>
    </descr>
  </attribute>

  <!-- ****** DOM Level 2 additions ****** -->
  <attribute readonly="yes" name="publicId" type="DOMString" id="ID-Core-DocType-publicId" since="DOM Level 2">
    <descr>
      <p>The public identifier of the external subset.</p>
    </descr>
  </attribute>

  <attribute readonly="yes" name="systemId" type="DOMString" id="ID-Core-DocType-systemId" since="DOM Level 2">
    <descr>
      <p>The system identifier of the external subset. This may be an absolute
        URI or not.</p>
    </descr>
  </attribute>

  <attribute readonly="yes" name="internalSubset" type="DOMString" id="ID-Core-DocType-internalSubset" since="DOM Level 2">
    <descr>
      <p>The internal subset as a string, or <code>null</code> if there is
        none. This is does not contain the delimiting square brackets.</p>
       <note>
        <p>The actual content returned depends on how much information is
          available to the implementation. This may vary depending on various
          parameters, including the XML processor used to build the
          document.</p>
       </note>
    </descr>
  </attribute>

</interface>
 
<interface name="Notation" inherits="Node" id="ID-5431D1B9">
<!-- $Date: 2003/05/28 13:08:38 $ $Revision: 1.7 $ -->
  <descr>
    <p>This interface represents a notation declared in the DTD. A notation
    either declares, by name, the format of an unparsed entity (see  <xspecref xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/2004/REC-xml-20040204#Notations" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">section 4.7</xspecref>
    of the XML 1.0 specification <bibref ref="XML"/>), or is used for formal
      declaration of
    processing instruction targets (see <xspecref xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/2004/REC-xml-20040204#sec-pi" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">section 2.6</xspecref> of the XML 1.0
    specification <bibref ref="XML"/>). The <code>nodeName</code> attribute
      inherited from
    <code>Node</code> is set to the declared name of the notation.</p>
    <p>The DOM Core does not support editing <code>Notation</code>
      nodes; they are therefore
      <termref def="dt-readonly-node">readonly</termref>.</p>
    <p>A <code>Notation</code> node does not have any parent.</p>

  </descr>
  <attribute readonly="yes" name="publicId" type="DOMString" id="ID-54F2B4D0">
    <descr><p>The public identifier of this notation. If the 
	public identifier was not specified, this is <code>null</code>.</p>
    </descr> 
  </attribute>
  <attribute readonly="yes" name="systemId" type="DOMString" id="ID-E8AAB1D0">
    <descr><p>The system identifier of this notation. If the system identifier
        was not specified, this is <code>null</code>. This may be an absolute
        URI or not.</p>
    </descr> 
  </attribute>
</interface>

      
<interface name="Entity" inherits="Node" id="ID-527DCFF2">
  <descr>
    <p>This interface represents a known entity, either parsed or unparsed, in an
      XML document. Note that this models the entity itself <emph>not</emph>
      the entity declaration.</p>
    <p>The <code>nodeName</code> attribute that is inherited from
      <code>Node</code> contains the name of the entity.</p> 
    <p>An XML processor may choose to completely expand entities before the
      structure model is passed to the DOM; in this case there will be no
      <code>EntityReference</code> nodes in the document tree.</p>
    <p>XML does not mandate that a non-validating XML processor read and
      process entity declarations made in the external subset or declared in
      parameter entities. This means that parsed entities declared in
      the external subset need not be expanded by some classes of applications,
      and that the replacement text of the entity may not be available. When the
      <xspecref xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/2004/REC-xml-20040204#intern-replacement" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">replacement text</xspecref> is
      available, the corresponding <code>Entity</code> node's child list
      represents the structure of that replacement value. Otherwise, the child
      list is empty.</p>
    <p>DOM Level 3 does not support editing <code>Entity</code> nodes; if a
      user wants to make changes to the contents of an <code>Entity</code>,
      every related <code>EntityReference</code> node has to be replaced in the
      structure model by a clone of the <code>Entity</code>'s contents, and
      then the desired changes must be made to each of those clones
      instead. <code>Entity</code> nodes and all their
      <termref def="dt-descendant">descendants</termref> are
      <termref def="dt-readonly-node">readonly</termref>.</p>
    <p>An <code>Entity</code> node does not have any parent.</p>
    <note>
      <p>If the entity contains an unbound
        <termref def="dt-namespaceprefix">namespace prefix</termref>, the
        <code>namespaceURI</code> of the corresponding node in the
        <code>Entity</code> node subtree is <code>null</code>. The same is
        true for <code>EntityReference</code> nodes that refer to this entity,
        when they are created using the <code>createEntityReference</code>
        method of the <code>Document</code> interface.</p>
    </note>
  </descr>

  <attribute readonly="yes" name="publicId" type="DOMString" id="ID-D7303025">
    <descr>
      <p>The public identifier associated with the entity if specified, and
        <code>null</code> otherwise.</p>
    </descr>
  </attribute>

  <attribute readonly="yes" name="systemId" type="DOMString" id="ID-D7C29F3E">
    <descr>
      <p>The system identifier associated with the entity if specified, and
        <code>null</code> otherwise. This may be an absolute URI or not.</p>
    </descr>
  </attribute>

  <attribute readonly="yes" name="notationName" type="DOMString" id="ID-6ABAEB38">
    <descr>
      <p>For unparsed entities, the name of the notation for the entity. For
        parsed entities, this is <code>null</code>.</p>
    </descr> 
  </attribute>

  <attribute readonly="yes" type="DOMString" name="inputEncoding" id="Entity3-inputEncoding" since="DOM Level 3">
    <descr>
      <p>An attribute specifying the encoding used for this entity at
	the time of parsing, when it is
        an external parsed entity. This is <code>null</code> if it an
	entity from the internal subset or if it is not known.</p>
    </descr>
  </attribute>

  <attribute readonly="yes" type="DOMString" name="xmlEncoding" id="Entity3-encoding" since="DOM Level 3">
    <descr>
      <p>An attribute specifying, as part of the text declaration, the encoding
        of this entity, when it is an external parsed entity. This is
        <code>null</code> otherwise.</p>
    </descr>
  </attribute>

  <attribute readonly="yes" type="DOMString" name="xmlVersion" id="Entity3-version" since="DOM Level 3">
    <descr>
      <p>An attribute specifying, as part of the text declaration, the version
        number of this entity, when it is an external parsed entity. This is
        <code>null</code> otherwise.</p>
    </descr>
  </attribute>
</interface>
 
<interface name="EntityReference" inherits="Node" id="ID-11C98490">
  <descr>
    <p><code>EntityReference</code> nodes may be used to represent an entity
      reference in the tree. Note that character references
      and references to predefined entities are considered to be expanded by
      the HTML or XML processor so that characters are represented by their
      Unicode equivalent rather than by an entity reference. Moreover, the XML
      processor may completely expand references to entities while building the
      <code>Document</code>, instead of providing <code>EntityReference</code>
      nodes. If it does provide such nodes, then for an
      <code>EntityReference</code> node that represents a reference to a known
      entity an <code>Entity</code> exists, and the subtree of the
      <code>EntityReference</code> node is a copy of the
      <code>Entity</code> node subtree. However, the latter may not be true
      when an entity contains an unbound <termref def="dt-namespaceprefix">namespace prefix</termref>. In such a case, because the namespace prefix
      resolution depends on where the entity reference is, the
      <termref def="dt-descendant">descendants</termref> of the
      <code>EntityReference</code> node may be bound to different
      <termref def="dt-namespaceURI">namespace URIs</termref>. When an
      <code>EntityReference</code> node represents a reference to an unknown
      entity, the node has no children and its
      replacement value, when used by <code>Attr.value</code> for example,
      is empty.</p>
    <p>As for <code>Entity</code> nodes, <code>EntityReference</code> nodes and
      all their <termref def="dt-descendant">descendants</termref> are
      <termref def="dt-readonly-node">readonly</termref>.</p>
    <note>
      <p><code>EntityReference</code> nodes may cause element content and
        attribute value normalization problems when, such as in XML 1.0 and
        XML Schema, the normalization is performed after entity reference
        are expanded.</p>
    </note> 
  </descr>
</interface>
 
<!--[ ProcessingInstruction object description ]-->
<!-- $Date: 2003/05/28 13:08:38 $ $Revision: 1.4 $ -->
<interface name="ProcessingInstruction" inherits="Node" id="ID-1004215813">
  <descr>
    <p>The <code>ProcessingInstruction</code> interface represents a
      "processing instruction", used in XML as a way to keep
      processor-specific information in the text of the document.</p>
    <p>
      No lexical check is done on the content of a processing
      instruction and it is therefore possible to have the character
      sequence <code>"?&gt;"</code> in the content, which is illegal a
      processing instruction per section 2.6 of <bibref ref="XML"/>. The
      presence of this character sequence must generate a fatal error
      during serialization.
    </p>
  </descr>

  <attribute readonly="yes" type="DOMString" name="target" id="ID-1478689192">
    <descr>
      <p>The target of this processing instruction. XML defines this as being
        the first <termref def="dt-token">token</termref> following the markup
        that begins the processing instruction.</p>
    </descr>
  </attribute>

  <attribute type="DOMString" name="data" id="ID-837822393" readonly="no">
    <descr>
      <p>The content of this processing instruction. This is from the first non
        white space character after the target to the character immediately
        preceding the <code>?&gt;</code>.</p>
    </descr>
    <setraises>
      <exception name="DOMException">
	<descr>
          <p>NO_MODIFICATION_ALLOWED_ERR: Raised when the node is readonly.</p>
        </descr>
      </exception>
    </setraises>
  </attribute>
</interface>
    
 
    </definitions>
  </div2>
</div1>
<!--
 *************************************************************************
 * END OF CORE                                                           *
 *************************************************************************
-->

</body>
  <!--
  *************************************************************************
  * BACK MATTER                                                           *
  *************************************************************************
  -->
<back> 
  
<!-- $Id: changes.xml,v 1.11 2004/01/08 19:56:15 plehegar Exp $ -->
<div1 id="Changes">
  <head>Changes</head>
  
  <orglist role="editors">
    <member>
      <name>Philippe Le H&#233;garet</name>
      <affiliation>W3C</affiliation>
    </member>
  </orglist>  
  <?GENERATE-MINI-TOC?>
  <p>
    This section summarizes the changes between <bibref role="informative" ref="DOM2Core"/> and this new version of the Core
    specification.
  </p>

  <div2 id="DOMLevel3Sections">
    <head>New sections</head>

    <p>
      The following new sections have been added:
    </p>
    <ulist>
      <item>
	<p>
	  <specref ref="DOMArchitecture"/>: a global overview of the DOM
	  Level 3 modules;
	</p>
      </item>
      <item>
	<p>
	  <specref ref="domURIs"/>: general considerations on the URI
	  handling in DOM Level 3;
	</p>
      </item>
      <item>
	<p>
	  <specref ref="baseURIs-Considerations"/>: How the <b>[base URI]</b> property defined in <bibref ref="InfoSet"/> has been exposed in DOM Level 3;
	</p>
      </item>
      <item>
	<p>
	  <specref ref="Embedded-DOM"/>: general considerations on DOM
	  implementation extensions;
	</p>
      </item>
      <item>
	<p>
	  <specref ref="DOMFeatures"/>: overview of the DOM features and how
	  they relate to the DOM modules;
	</p>
      </item>
      <item>
	<p>
	  <specref ref="Bootstrap"/>: general introduction to the DOM
	  Level 3 bootstrapping mechanisms;
	</p>
      </item>
      <item>
	<p>
	  <specref ref="Algorithms"/>: how namespace URIs and prefixes
	  are resolved in DOM Level 3;
	</p>
      </item>
      <item>
	<p>
	  <specref ref="InfosetMapping"/>: relation between DOM Level 3
	  and <bibref ref="InfoSet"/>;
	</p>
      </item>
      <item>
	<p>
	  <specref ref="Parameters"/>: relations between parameters as
	  used in <code>DOMConfiguration</code>;
	</p>
      </item>
    </ulist>
  </div2>

  <div2 id="DOMLevel2Changes">
    <head>Changes to DOM Level 2 Core interfaces and exceptions</head>
    
    <glist>
      <gitem>
	<label>Interface <code>Attr</code></label>
	<def>
	  <p>The <code>Attr</code> interface has two new attributes,
	    <code>Attr.schemaTypeInfo</code>, and 
	    <code>Attr.isId</code>.</p>
	</def>
      </gitem>
      <gitem>
	<label>Interface <code>Document</code></label>
	<def>
	  <p>The <code>Document</code> interface has seven new
	    attributes: <code>Document.inputEncoding</code>,
	    <code>Document.xmlEncoding</code>,
	    <code>Document.xmlStandalone</code>,
	    <code>Document.xmlVersion</code>,
	    <code>Document.strictErrorChecking</code>,
	    <code>Document.documentURI</code>, and
	    <code>Document.domConfig</code>. It has three new methods:
	    <code>Document.adoptNode(source)</code>,
	    <code>Document.normalizeDocument()</code>, and
	    <code>Document.renameNode(n, namespaceURI,
	      qualifiedName)</code>. The attribute
	    <code>Document.doctype</code> has been modified.
	  </p>
	</def>
      </gitem>
      <gitem>
	<label>Exception <code>DOMException</code></label>
	<def>
	  <p>
	    The <code>DOMException</code> has two new exception codes:
	    <code>VALIDATION_ERR</code> and
	    <code>TYPE_MISMATCH_ERR</code>.
	  </p>
	</def>
      </gitem>
      <gitem>
	<label>Interface <code>DOMImplementation</code></label>
	<def>
	  <p>The <code>DOMImplementation</code> interface has one new
	    method, <code>DOMImplementation.getFeature(feature,
	      version)</code>.</p>
	</def>
      </gitem>
      <gitem>
	<label>Interface <code>Entity</code></label>
	<def>
	  <p>The <code>Entity</code> interface has three new
	    attributes: <code>Entity.inputEncoding</code>,
	    <code>Entity.xmlEncoding</code>, and
	    <code>Entity.xmlVersion</code>.
	  </p>
	</def>
      </gitem>
      <gitem>
	<label>Interface <code>Element</code></label>
	<def>
	  <p>
	    The <code>Element</code> interface has one new attribute,
	    <code>Element.schemaTypeInfo</code>, and three new methods:
	    <code>Element.setIdAttribute(name, isId)</code>,
	    <code>Element.setIdAttributeNS(namespaceURI, localName,
	      isId)</code>, and <code>Element.setIdAttributeNode(idAttr,
	      isId)</code>.
	  </p>
	  
	</def>
      </gitem>
      <gitem>
	<label>Interface <code>Node</code></label>
	<def>
	  <p>The <code>Node</code> interface has two new attributes,
	    <code>Node.baseURI</code> and <code>Node.textContent</code>.
	    It has nine new methods:
	    <code>Node.compareDocumentPosition(other)</code>,
	    <code>Node.isSameNode(other)</code>,
	    <code>Node.lookupPrefix(namespaceURI)</code>,
	    <code>Node.isDefaultNamespace(namespaceURI)</code>,
	    <code>Node.lookupNamespaceURI(prefix)</code>,
	    <code>Node.isEqualNode(arg)</code>,
	    <code>Node.getFeature(feature, version)</code>,
	    <code>Node.setUserData(key, data, handler)</code>,
	    <code>Node.getUserData(key)</code>. It introduced 6 new
	    constants: <code>Node.DOCUMENT_POSITION_DISCONNECTED</code>,
	    <code>Node.DOCUMENT_POSITION_PRECEDING</code>,
	    <code>Node.DOCUMENT_POSITION_FOLLOWING</code>,
	    <code>Node.DOCUMENT_POSITION_CONTAINS</code>,
	    <code>Node.DOCUMENT_POSITION_CONTAINED_BY</code>, and
	    <code>Node.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC</code>. The
	    methods <code>Node.insertBefore(newChild, refChild)</code>,
	    <code>Node.replaceChild(newChild, oldChild)</code> and
	    <code>Node.removeChild(oldChild)</code> have been modified.
	  </p>
	</def>
      </gitem>
      <gitem>
	<label>Interface <code>Text</code></label>
	<def>
	  <p>
	    The <code>Text</code> interface has two new attributes,
	    <code>Text.wholeText</code> and
	    <code>Text.isElementContentWhitespace</code>, and one new
	    method, <code>Text.replaceWholeText(content)</code>.
	  </p>
	</def>
      </gitem>
    </glist>
  </div2>
  <div2 id="DOMLevel3Addons-features">
    <head>New DOM features</head>
    <glist>
      <gitem>
	<label>"XMLVersion"</label>
	<def>
	  <p>
	    The "XMLVersion" DOM feature was introduced to represent if
	    an implementation is able to support <bibref ref="XML"/> or
	    <bibref ref="XML11"/>. See <code>Document.xmlVersion</code>.
	  </p>
	</def>
      </gitem>
    </glist>
  </div2>
  <div2 id="DOMLevel3Addons-types">
    <head>New types</head>
    <glist>
      <gitem>
	<label><code>DOMUserData</code></label>
	<def>
	  <p>The <code>DOMUserData</code> type was added to the Core
	    module.</p>
	</def>
      </gitem>
      <gitem>
	<label><code>DOMObject</code></label>
	<def>
	  <p>The <code>DOMObject</code> type was added to the Core
	    module.</p>
	</def>
      </gitem>
    </glist>
  </div2>
  <div2 id="DOMLevel3Addons-interfaces">
    <head>New interfaces</head>
    <glist>
      <gitem>
	<label><code>DOMStringList</code></label>
	<def>
	  <p>
	    The <code>DOMStringList</code> interface has one
	    attribute, <code>DOMStringList.length</code>, and one
	    method, <code>DOMStringList.item(index)</code>.
	  </p>
	</def>
      </gitem>
      <gitem>
	<label><code>NameList</code></label>
	<def>
	  <p>
	    The <code>NameList</code> interface has one attribute,
	    <code>NameList.length</code>, and two methods,
	    <code>NameList.getName(index)</code> and
	    <code>NameList.getNamespaceURI(index)</code>.
	  </p>
	</def>
      </gitem>
      <gitem>
	<label><code>DOMImplementationList</code></label>
	<def>
	  <p>
	    The <code>DOMImplementationList</code> interface has one
	    attribute, <code>DOMImplementationList.length</code>, and
	    one method,
	    <code>DOMImplementationList.item(index)</code>.
	  </p>
	</def>
      </gitem>
      <gitem>
	<label><code>DOMImplementationSource</code></label>
	<def>
	  <p>
	    The <code>DOMImplementationSource</code> interface has two
	    methods,
	    <code>DOMImplementationSource.getDOMImplementation(features)</code>,
	    and
	    <code>DOMImplementationSource.getDOMImplementationList(features)</code>.
	  </p>
	</def>
      </gitem>
      <gitem>
	<label><code>TypeInfo</code></label>
	<def>
	  <p>
	    The <code>TypeInfo</code> interface has two attributes,
	    <code>TypeInfo.typeName</code>, and
	    <code>TypeInfo.typeNamespace</code>.
	  </p>
	</def>
      </gitem>
      <gitem>
	<label><code>UserDataHandler</code></label>
	<def>
	  <p>
	    The <code>UserDataHandler</code> interface has one method,
	    <code>UserDataHandler.handle(operation, key, data, src,
	      dst)</code>, and four constants:
	    <code>UserDataHandler.NODE_CLONED</code>,
	    <code>UserDataHandler.NODE_IMPORTED</code>,
	    <code>UserDataHandler.NODE_DELETED</code>, and
	    <code>UserDataHandler.NODE_RENAMED</code>.
	  </p>
	</def>
      </gitem>
      <gitem>
	<label><code>DOMError</code></label>
	<def>
	  <p>
	    The <code>DOMError</code> interface has six attributes:
	    <code>DOMError.severity</code>,
	    <code>DOMError.message</code>,
	    <code>DOMError.type</code>,
	    <code>DOMError.relatedException</code>,
	    <code>DOMError.relatedData</code>, and
	    <code>DOMError.location</code>. It has four constants:
	    <code>DOMError.SEVERITY_WARNING</code>,
	    <code>DOMError.SEVERITY_ERROR</code>, and
	    <code>DOMError.SEVERITY_FATAL_ERROR</code>.
	  </p>
	</def>
      </gitem>
      <gitem>
	<label><code>DOMErrorHandler</code></label>
	<def>
	  <p>
	    The <code>DOMErrorHandler</code> interface has one method:
	    <code>DOMErrorHandler.handleError(error)</code>.
	  </p>
	</def>
      </gitem>
      <gitem>
	<label><code>DOMLocator</code></label>
	<def>
	  <p>
	    The <code>DOMLocator</code> interface has seven attributes:
	    <code>DOMLocator.lineNumber</code>,
	    <code>DOMLocator.columnNumber</code>,
	    <code>DOMLocator.byteOffset</code>,
	    <code>DOMLocator.utf16Offset</code>,
	    <code>DOMLocator.relatedNode</code>,
	    <code>DOMLocator.uri</code>, and
	    <code>DOMLocator.lineNumber</code>.
	  </p>
	</def>
      </gitem>
      <gitem>
	<label><code>DOMConfiguration</code></label>
	<def>
	  <p>
	    The <code>DOMConfiguration</code> interface has one attribute:
	    <code>DOMConfiguration.parameterNames</code>.	    
	    It also has three methods:
	    <code>DOMConfiguration.setParameter(name, value)</code>,
	    <code>DOMConfiguration.getParameter(name)</code>, and
	    <code>DOMConfiguration.canSetParameter(name,
	      value)</code>.
	  </p>
	</def>
      </gitem>
    </glist>
  </div2>

  <div2 id="DOMLevel3Addons-objectss">
    <head>Objects</head>
    <p>
      This specification defines one object, only provided in the bindings:
    </p>
    <glist>
      <gitem>
	<label><code>DOMImplementationRegistry</code></label>
	<def>
	  <p>
	    The <code>DOMImplementationRegistry</code> object has two methods,
	    <code>DOMImplementationRegistry.getDOMImplementation(features)</code>,
	    and
	    <code>DOMImplementationRegistry.getDOMImplementationList(features)</code>.
	  </p>
	</def>
      </gitem>
    </glist>
  </div2>
  
</div1>

  
<!-- $Id: ns-algos.xml,v 1.20 2004/03/15 20:02:37 plehegar Exp $ -->
<div1 id="Algorithms">
  <head>Namespaces Algorithms</head>

   <orglist role="editors">
    <member>
      <name>Arnaud Le Hors</name> 
      <affiliation>IBM</affiliation>
    </member>
    <member>
      <name>Elena Litani</name> 
      <affiliation>IBM</affiliation>
    </member>
  </orglist>
  <?GENERATE-MINI-TOC?>
  <p>
    This appendix contains several namespace algorithms, such as namespace normalization algorithm
    that fixes namespace information in the Document Object Model to produce a 
    <termref def="dt-namespace-well-formed">namespace well-formed</termref> document.  
    If <bibref ref="XML"/> is in use (see <code>Document.xmlVersion</code>) the algorithms 
    conform to <bibref ref="Namespaces"/>, otherwise if  
    <bibref ref="XML11"/> is in use, algorithms conform to <bibref ref="Namespaces11"/>.

  </p>
  <div2 id="normalizeDocumentAlgo">
    <head>Namespace Normalization</head>

    <p>
      Namespace declaration attributes and prefixes are normalized as
      part of the <code>normalizeDocument</code> method of the
      <code>Document</code> interface as if the following method
      described in pseudo code was called on the document element.
    </p>
    <eg xml:space="preserve">
void Element.normalizeNamespaces()
{

  // Pick up local namespace declarations
  // 
  for ( all DOM Level 2 valid local namespace declaration attributes of Element ) 
  {    
      if (the namespace declaration is invalid) 
      {
          // Note: The prefix xmlns is used only to declare namespace bindings and
          // is by definition bound to the namespace name http://www.w3.org/2000/xmlns/.
          // It must not be declared. No other prefix may be bound to this namespace name.         
               
          ==&gt; Report an error.

      } 
      else 
      {
          ==&gt;  Record the namespace declaration
      }
  }


  // Fixup element's namespace
  //
  if ( Element's namespaceURI != null )
  {
    if ( Element's prefix/namespace pair (or default namespace,
         if no prefix) are within the scope of a binding )
    {
      ==&gt; do nothing, declaration in scope is inherited

      See section "B.1.1: Scope of a binding" for an example

    }
    else
    {
      ==&gt; Create a local namespace declaration attr for this namespace,
          with Element's current prefix (or a default namespace, if
          no prefix). If there's a conflicting local declaration
          already present, change its value to use this namespace.

          See section "B.1.2: Conflicting namespace declaration" for an example

          // NOTE that this may break other nodes within this Element's
          // subtree, if they're already using this prefix.
          // They will be repaired when we reach them.
    }
  }
  else
  {
    // Element has no namespace URI:
    if ( Element's localName is null )
    {
       // DOM Level 1 node
       ==&gt; if in process of validation against a namespace aware schema 
           (i.e XML Schema) report a fatal error: the processor can not recover 
           in this situation. 
           Otherwise, report an error: no namespace fixup will be performed on this node.
    }
    else
    {
      // Element has no pseudo-prefix
      if ( there's a conflicting local default namespace declaration
           already present )
      {
        ==&gt; change its value to use this empty namespace.
<!--          See example 3 -->
      }
      // NOTE that this may break other nodes within this Element's
      // subtree, if they're already using the default namespaces.
      // They will be repaired when we reach them.
    }
  }


  // Examine and polish the attributes
  //
  for ( all non-namespace Attrs of Element )
  {
     if ( Attr[i] has a namespace URI )
     {
        if ( attribute has no prefix (default namespace decl does not apply to attributes) 
             OR
             attribute prefix is not declared
             OR
             conflict: attribute has a prefix that conflicts with a binding
                       already active in scope)
        {              
           if (namespaceURI matches an in scope declaration of one or more prefixes) 
           {
               // pick the most local binding available; 
               // if there is more than one pick one arbitrarily

               ==&gt; change attribute's prefix.
           }
           else 
           {
               if (the current prefix is not null and it has no in scope declaration) 
               {
                   ==&gt; declare this prefix
               } 
               else 
               {
                   // find a prefix following the pattern "NS" +index (starting at 1)
                   // make sure this prefix is not declared in the current scope.
                   // create a local namespace declaration attribute

                   ==&gt; change attribute's prefix.
               }
           }           
        }
     }    
     else
     {
        // Attr[i] has no namespace URI
            
        if ( Attr[i] has no localName )
        {
           // DOM Level 1 node
           ==&gt; if in process of validation against a namespace aware schema 
               (i.e XML Schema) report a fatal error: the processor can not recover 
                in this situation. 
                Otherwise, report an error: no namespace fixup will be performed on this node.
        }
        else
        { 
           // attr has no namespace URI and no prefix
           // no action is required, since attrs don't use default
           ==&gt; do nothing 
        }
     }
  } // end for-all-Attrs

  // do this recursively
  for ( all child elements of Element )
  {
    childElement.normalizeNamespaces()
  }
} // end Element.normalizeNamespaces
      </eg>

    <div3 id="scope">
      <head>Scope of a Binding</head>
      <note>
	<p>
	  This section is informative.
	</p>
      </note>
      <p>
	An element's prefix/namespace URI pair is said to be within the
	scope of a binding if its namespace prefix is bound to the same
	namespace URI in the [in-scope namespaces] defined in <bibref ref="InfoSet"/>.
      </p>
      <p>
	As an example, the following document is loaded in a DOM tree:
      </p>
      <eg xml:space="preserve">
&lt;root&gt;
  &lt;parent xmlns:ns="http://www.example.org/ns1"
          xmlns:bar="http://www.example.org/ns2"&gt;
    &lt;ns:child1 xmlns:ns="http://www.example.org/ns2"/&gt;
  &lt;/parent&gt;
&lt;/root&gt;
      </eg>
      <p>
	In the case of the <code>child1</code> element, the namespace
	prefix and namespace URI are within the scope of the appropriate
	namespace declaration given that the namespace prefix
	<code>ns</code> of <code>child1</code> is bound to
	<code>http://www.example.org/ns2</code>.
      </p>      
      <p>
	Using the method <code>Node.appendChild</code>, a
	<code>child2</code> element is added as a sibling of
	<code>child1</code> with the same namespace prefix and namespace
	URI, i.e. <code>"ns"</code> and
	<code>"http://www.example.org/ns2"</code> respectively. Unlike
	<code>child1</code> which contains the appropriate namespace
	declaration in its attributes, <code>child2</code>'s prefix/namespace URI pair is within the
	scope of the namespace declaration of its parent, and the
	namespace prefix <code>"ns"</code> is bound to
	<code>"http://www.example.org/ns1"</code>. <code>child2</code>'s prefix/namespace URI pair
	is therefore not within the scope of a binding. In order to put
	them within a scope of a binding, the namespace
	normalization algorithm will create a namespace declaration
	attribute value to bind the namespace prefix <code>"ns"</code>
	to the namespace URI <code>"http://www.example.org/ns2"</code>
	and will attach to <code>child2</code>. The XML representation
	of the document after the completion of the namespace
	normalization algorithm will be:
      </p>
      <eg xml:space="preserve">
&lt;root&gt;
  &lt;parent xmlns:ns="http://www.example.org/ns1"
          xmlns:bar="http://www.example.org/ns2"&gt;
    &lt;ns:child1 xmlns:ns="http://www.example.org/ns2"/&gt;
    &lt;ns:child2 xmlns:ns="http://www.example.org/ns2"/&gt;
  &lt;/parent&gt;
&lt;/root&gt;
      </eg>
      <p>
	To determine if an element is within the scope of a binding, one
	can invoke <code>Node.lookupNamespaceURI</code>, using its
	namespace prefix as the parameter, and compare the resulting
	namespace URI against the desired URI, or one can invoke
	<code>Node.isDefaultNamespaceURI</code> using its namespace URI
	if the element has no namespace prefix.
      </p>
    </div3>

    <div3 id="conflicting">
      <head>Conflicting Namespace Declaration</head>
      <note>
	<p>
	  This section is informative.
	</p>
      </note>
      <p>
	A conflicting namespace declaration could occur on an element if
	an <code>Element</code> node and a namespace declaration
	attribute use the same prefix but map them to two different
	namespace URIs.
      </p>
      <p>
	As an example, the following document is loaded in a DOM tree:
      </p>
      <eg xml:space="preserve">
&lt;root&gt;
  &lt;ns:child1 xmlns:ns="http://www.example.org/ns1"&gt;
    &lt;ns:child2/&gt; 
  &lt;/ns:child1&gt;   
&lt;/root&gt;
      </eg>
      <p>
	Using the method <code>Node.renameNode</code>, the namespace URI
	of the element <code>child1</code> is renamed from
	<code>"http://www.example.org/ns1"</code> to
	<code>"http://www.example.org/ns2"</code>. The namespace prefix
	<code>"ns"</code> is now mapped to two different namespace URIs
	at the element <code>child1</code> level and thus the namespace
	declaration is declared conflicting. The namespace normalization
	algorithm will resolved the namespace prefix conflict by
	modifying the namespace declaration attribute value from
	<code>"http://www.example.org/ns1"</code> to
	<code>"http://www.example.org/ns2"</code>. The algorithm will
	then continue and consider the element <code>child2</code>, will
	no longer find a namespace declaration mapping the namespace
	prefix <code>"ns"</code> to
	<code>"http://www.example.org/ns1"</code> in the element's
	scope, and will create a new one.  The XML representation of the
	document after the completion of the namespace normalization
	algorithm will be:
      </p>
      <eg xml:space="preserve">
&lt;root&gt;
  &lt;ns:child1 xmlns:ns="http://www.example.org/ns2"&gt;
    &lt;ns:child2  xmlns:ns="http://www.example.org/ns1"/&gt; 
  &lt;/ns:child1&gt;   
&lt;/root&gt;
      </eg>

    </div3>

  </div2>


  <div2 id="lookupNamespacePrefixAlgo">
    <head>Namespace Prefix Lookup</head>

    <p>
      The following describes in pseudo code the algorithm used in the
      <code>lookupPrefix</code> method of the <code>Node</code>
      interface. Before returning found prefix the algorithm needs to
      make sure that the prefix is not redefined on an element from
      which the lookup started. This methods ignores DOM Level 1
      nodes.
    </p>
    <note>
      <p>
	This method ignores all <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/REC-xml-names/#NT-DefaultAttName" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">default
	namespace declarations</loc>.  To look up default namespace use
	<code>isDefaultNamespace</code> method.
      </p>
    </note>
    <eg xml:space="preserve">
DOMString lookupPrefix(in DOMString namespaceURI)
{
  if (namespaceURI has no value, i.e. namespaceURI is null or empty string) {
     return null;
  }
  short type = this.getNodeType(); 
  switch (type) { 
        case Node.ELEMENT_NODE: 
        { 
             return lookupNamespacePrefix(namespaceURI, this); 
        } 
        case Node.DOCUMENT_NODE:
        { 
             return getDocumentElement().lookupNamespacePrefix(namespaceURI); 
        } 
        case Node.ENTITY_NODE : 
        case Node.NOTATION_NODE: 
        case Node.DOCUMENT_FRAGMENT_NODE: 
        case Node.DOCUMENT_TYPE_NODE: 
            return null;  // type is unknown  
        case Node.ATTRIBUTE_NODE:
        {
             if ( Attr has an owner Element ) 
             { 
                 return ownerElement.lookupNamespacePrefix(namespaceURI); 
             } 
             return null; 
        } 
        default:
        { 
           if (Node has an ancestor Element )
           // EntityReferences may have to be skipped to get to it 
           { 
                    return ancestor.lookupNamespacePrefix(namespaceURI); 
           } 
            return null; 
        } 
     } 
 } 


DOMString lookupNamespacePrefix(DOMString namespaceURI, Element originalElement){ 
        if ( Element has a namespace and Element's namespace == namespaceURI and 
             Element has a prefix and 
             originalElement.lookupNamespaceURI(Element's prefix) == namespaceURI) 
        { 
             return (Element's prefix); 
        } 
        if ( Element has attributes)
        { 
            for ( all DOM Level 2 valid local namespace declaration attributes of Element )
            {
                if (Attr's prefix == "xmlns" and 
                   Attr's value == namespaceURI and 
                   originalElement.lookupNamespaceURI(Attr's localname) == namespaceURI) 
                   { 
                      return (Attr's localname);
                   } 
            }
        } 

        if (Node has an ancestor Element ) 
           // EntityReferences may have to be skipped to get to it 
        { 
            return ancestor.lookupNamespacePrefix(namespaceURI, originalElement); 
        } 
        return null; 
    } 
</eg>

  </div2>


  <div2 id="isDefaultNamespaceAlgo">
    <head>Default Namespace Lookup</head>

    <p>
      The following describes in pseudo code the algorithm used in the
      <code>isDefaultNamespace</code> method of the <code>Node</code>
      interface. This methods ignores DOM Level 1 nodes.
    </p>
    <eg xml:space="preserve">
boolean isDefaultNamespace(in DOMString namespaceURI)
{
  switch (nodeType) {
  case ELEMENT_NODE:  
     if ( Element has no prefix )
     {
          return (Element's namespace == namespaceURI);
     }
     if ( Element has attributes and there is a valid DOM Level 2 
          default namespace declaration, i.e. Attr's localName == "xmlns" )
     {
	  return (Attr's value == namespaceURI);
     }

     if ( Element has an ancestor Element )
         // EntityReferences may have to be skipped to get to it
     {
          return ancestorElement.isDefaultNamespace(namespaceURI);
     }
     else {
          return unknown (false);
     }    
  case DOCUMENT_NODE:
     return documentElement.isDefaultNamespace(namespaceURI);
  case ENTITY_NODE:
  case NOTATION_NODE:
  case DOCUMENT_TYPE_NODE:
  case DOCUMENT_FRAGMENT_NODE:
     return unknown (false);
  case ATTRIBUTE_NODE:
     if ( Attr has an owner Element )
     {          
          return ownerElement.isDefaultNamespace(namespaceURI);
     }
     else {
          return unknown (false);
     }    
  default:
     if ( Node has an ancestor Element )
         // EntityReferences may have to be skipped to get to it
     {          
          return ancestorElement.isDefaultNamespace(namespaceURI);
     }
     else {
          return unknown (false);
     }    
  }
}
      </eg>
  </div2>

  <div2 id="lookupNamespaceURIAlgo">
    <head>Namespace URI Lookup</head>

    <p>
      The following describes in pseudo code the algorithm used in the
      <code>lookupNamespaceURI</code> method of the <code>Node</code>
      interface. This methods ignores DOM Level 1 nodes.
    </p>
    <eg xml:space="preserve">
DOMString lookupNamespaceURI(in DOMString prefix) 
{ 
  switch (nodeType) { 
     case ELEMENT_NODE: 
     { 
         if ( Element's namespace != null and Element's prefix == prefix ) 
         { 
               // Note: prefix could be "null" in this case we are looking for default namespace 
               return (Element's namespace);
         } 
         if ( Element has attributes)
         { 
            for ( all DOM Level 2 valid local namespace declaration attributes of Element )
            {
                 if (Attr's prefix == "xmlns" and Attr's localName == prefix ) 
                       // non default namespace
                 { 
                        if (Attr's value is not empty) 
                        {
                          return (Attr's value);
                        }         
                        return unknown (null);                   
                 } 
                 else if (Attr's localname == "xmlns" and prefix == null)
                       // default namespace
                 { 
                        if (Attr's value is not empty) 
                        {
                          return (Attr's value);
                        }         
                        return unknown (null); 
                 } 
           }
         } 
         if ( Element has an ancestor Element ) 
            // EntityReferences may have to be skipped to get to it 
         { 
                   return ancestorElement.lookupNamespaceURI(prefix); 
         } 
         return null; 
     } 
     case DOCUMENT_NODE: 
          return documentElement.lookupNamespaceURI(prefix) 

     case ENTITY_NODE: 
     case NOTATION_NODE: 
     case DOCUMENT_TYPE_NODE: 
     case DOCUMENT_FRAGMENT_NODE: 
           return unknown (null); 

     case ATTRIBUTE_NODE: 
         if (Attr has an owner Element) 
         { 
             return ownerElement.lookupNamespaceURI(prefix); 
         } 
         else 
         { 
             return unknown (null); 
         } 
     default: 
         if (Node has an ancestor Element) 
          // EntityReferences may have to be skipped to get to it 
         { 
             return ancestorElement.lookupNamespaceURI(prefix); 
         } 
         else { 
             return unknown (null); 
         } 
  } 
} 
      </eg>
      
  </div2>

</div1>

  
<!-- $Id: infoset.xml,v 1.19 2004/03/15 20:01:16 plehegar Exp $ -->
<div1 id="InfosetMapping">
  <head>Infoset Mapping</head>

  <orglist role="editors">
    <member>
      <name>Philippe Le H&#233;garet</name>
      <affiliation>W3C</affiliation>
    </member>
  </orglist>
  <?GENERATE-MINI-TOC?>
  <p>
    This appendix contains the mappings between the XML Information Set
    <bibref ref="InfoSet"/> model and the Document Object Model.
    Starting from a <code>Document</code> node, each <term>information
    item</term> is mapped to its respective <code>Node</code>, and each
    <code>Node</code> is mapped to its respective <term>information
    item</term>. As used in the Infoset specification, the Infoset
    property names are shown in square brackets, <b>[thus]</b>.
  </p>
  <p>
    Unless specified, the Infoset to DOM node mapping makes no
    distinction between unknown and no value since both will be exposed
    as <code>null</code> (or <code>false</code> if the DOM attribute is
    of type <code>boolean</code>).
  </p>

  <div2 id="DocumentMapping">
    <head>Document Node Mapping</head>

    <div3 id="Infoset2Document">
      <head>Infoset to Document Node</head>
      <p>
	An <term>document information item</term> maps to a
	<code>Document</code> node. The attributes of the corresponding
	<code>Document</code> node are constructed as follows:
      </p>
      <table border="1" cellpadding="3" summary="The table contains the mapping of an       Infoset information item to a Node">
	<tbody>
	  <tr>
	    <th rowspan="1" colspan="1">Attribute</th>
	    <th rowspan="1" colspan="1">Value</th>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.nodeName</code></td>
	    <td rowspan="1" colspan="1"><code>"#document"</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.nodeValue</code></td>
	    <td rowspan="1" colspan="1"><code>null</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.nodeType</code></td>
	    <td rowspan="1" colspan="1"><code>Node.DOCUMENT_NODE</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.parentNode</code></td>
	    <td rowspan="1" colspan="1"><code>null</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.childNodes</code></td>
	    <td rowspan="1" colspan="1">A <code>NodeList</code> containing the information items
	      in the <b>[children]</b> property.
	    </td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.firstChild</code></td>
	    <td rowspan="1" colspan="1">The first node contained in <code>Node.childNodes</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.lastChild</code></td>
	    <td rowspan="1" colspan="1">The last node contained in <code>Node.childNodes</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.previousSibling</code></td>
	    <td rowspan="1" colspan="1"><code>null</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.nextSibling</code></td>
	    <td rowspan="1" colspan="1"><code>null</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.attributes</code></td>
	    <td rowspan="1" colspan="1"><code>null</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.ownerDocument</code></td>
	    <td rowspan="1" colspan="1"><code>null</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.namespaceURI</code></td>
	    <td rowspan="1" colspan="1"><code>null</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.prefix</code></td>
	    <td rowspan="1" colspan="1"><code>null</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.localName</code></td>
	    <td rowspan="1" colspan="1"><code>null</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.baseURI</code></td>
	    <td rowspan="1" colspan="1">same as <code>Document.documentURI</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.textContent</code></td>
	    <td rowspan="1" colspan="1"><code>null</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Document.doctype</code></td>
	    <td rowspan="1" colspan="1">The document type information item</td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Document.implementation</code></td>
	    <td rowspan="1" colspan="1">The <code>DOMImplementation</code> object used to create
	    this node</td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Document.documentElement</code></td>
	    <td rowspan="1" colspan="1">The <b>[document element]</b> property</td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Document.inputEncoding</code></td>
	    <td rowspan="1" colspan="1">The <b>[character encoding scheme]</b> property</td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Document.xmlEncoding</code></td>
	    <td rowspan="1" colspan="1"><code>null</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Document.xmlStandalone</code></td>
	    <td rowspan="1" colspan="1">The <b>[standalone]</b> property, or <code>false</code>
	      if the latter has no value.</td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Document.xmlVersion</code></td>
	    <td rowspan="1" colspan="1">The <b>[version]</b> property, or <code>"1.0"</code> if
	      the latter has no value.</td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Document.strictErrorChecking</code></td>
	    <td rowspan="1" colspan="1"><code>true</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Document.documentURI</code></td>
	    <td rowspan="1" colspan="1">The <b>[base URI]</b> property</td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Document.domConfig</code></td>
	    <td rowspan="1" colspan="1">A <code>DOMConfiguration</code> object whose parameters
	      are set to their default values</td>
	  </tr>
	</tbody>
      </table>
      <p>
	The <b>[notations]</b>, <b>[unparsed entities]</b> properties
	are being exposed in the <code>DocumentType</code> node.
      </p>
      <note>
	<p>
	  The <b>[all declarations processed]</b> property is not
	  exposed through the <code>Document</code> node.
	</p>
      </note>
    </div3>

    <div3 id="Document2Infoset">
      <head>Document Node to Infoset</head>
      <p>
	A <code>Document</code> node maps to an <term>document
	information item</term>. <code>Document</code> nodes with no
	namespace URI (<code>Node.namespaceURI</code> equals to
	<code>null</code>) cannot be represented using the Infoset. The
	properties of the corresponding <term>document information
	item</term> are constructed as follows:
      </p>
      <table border="1" cellpadding="3" summary="The table contains the mapping of a       Node to the Infoset">
	<tbody>
	  <tr>
	    <th rowspan="1" colspan="1">Property</th>
	    <th rowspan="1" colspan="1">Value</th>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><b>[children]</b></td>
	    <td rowspan="1" colspan="1"><code>Node.childNodes</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><b>[document element]</b></td>
	    <td rowspan="1" colspan="1"><code>Document.documentElement</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><b>[notations]</b></td>
	    <td rowspan="1" colspan="1"><code>Document.doctype.notations</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><b>[unparsed entities]</b></td>
	    <td rowspan="1" colspan="1">The information items from
	      <code>Document.doctype.entities</code>, whose
	      <code>Node.childNodes</code> is an empty list</td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><b>[base URI]</b></td>
	    <td rowspan="1" colspan="1"><code>Document.documentURI</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><b>[character encoding scheme]</b></td>
	    <td rowspan="1" colspan="1"><code>Document.inputEncoding</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><b>[standalone]</b></td>
	    <td rowspan="1" colspan="1"><code>Document.xmlStandalone</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><b>[version]</b></td>
	    <td rowspan="1" colspan="1"><code>Document.xmlVersion</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><b>[all declarations processed]</b></td>
	    <td rowspan="1" colspan="1">The value is implementation dependent</td>
	  </tr>
	</tbody>
      </table>
    </div3>

  </div2>

  <div2 id="ElementMapping">
    <head>Element Node Mapping</head>

    <div3 id="Infoset2Element">
      <head>Infoset to Element Node</head>
      <p>
	An <term>element information item</term> maps to a
	<code>Element</code> node. The attributes of the corresponding
	<code>Element</code> node are constructed as follows:
      </p>
      <table border="1" cellpadding="3" summary="The table contains the mapping of an       Infoset information item to a Node">
	<tbody>
	  <tr>
	    <th rowspan="1" colspan="1">Attribute</th>
	    <th rowspan="1" colspan="1">Value</th>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.nodeName</code></td>
	    <td rowspan="1" colspan="1">same as <code>Element.tagName</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.nodeValue</code></td>
	    <td rowspan="1" colspan="1"><code>null</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.nodeType</code></td>
	    <td rowspan="1" colspan="1"><code>Node.ELEMENT_NODE</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.parentNode</code></td>
	    <td rowspan="1" colspan="1">The <b>[parent]</b> property</td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.childNodes</code></td>
	    <td rowspan="1" colspan="1">A <code>NodeList</code> containing the information items
	      in the <b>[children]</b> property
	    </td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.firstChild</code></td>
	    <td rowspan="1" colspan="1">The first node contained in <code>Node.childNodes</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.lastChild</code></td>
	    <td rowspan="1" colspan="1">The last node contained in <code>Node.childNodes</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.previousSibling</code></td>
	    <td rowspan="1" colspan="1">The information item preceding the current one on the
	      <b>[children]</b> property contained in the <b>[parent]</b> property</td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.nextSibling</code></td>
	    <td rowspan="1" colspan="1">The information item following the current one on the
	      <b>[children]</b> property contained in the <b>[parent]</b> property</td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.attributes</code></td>
	    <td rowspan="1" colspan="1">The information items contained in
	      the <b>[attributes]</b> and <b>[namespace attributes]</b> properties</td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.ownerDocument</code></td>
	    <td rowspan="1" colspan="1">The document information item</td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.namespaceURI</code></td>
	    <td rowspan="1" colspan="1">The <b>[namespace name]</b> property</td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.prefix</code></td>
	    <td rowspan="1" colspan="1">The <b>[prefix]</b> property</td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.localName</code></td>
	    <td rowspan="1" colspan="1">The <b>[local name]</b> property</td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.baseURI</code></td>
	    <td rowspan="1" colspan="1">The <b>[base URI]</b> property</td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.textContent</code></td>
	    <td rowspan="1" colspan="1">Concatenation of the <code>Node.textContent</code>
	      attribute value of every child node, excluding
	      <code>COMMENT_NODE</code> and
	      <code>PROCESSING_INSTRUCTION_NODE</code> nodes. This is
	      the empty string if the node has no children.</td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Element.tagName</code></td>
	    <td rowspan="1" colspan="1">If the <b>[prefix]</b> property has no value, this contains the
	    <b>[local name]</b> property. Otherwise, this contains the
	      concatenation of the <b>[prefix]</b> property, the colon ':'
	      character, and the <b>[local name]</b> property.</td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Element.schemaTypeInfo</code></td>
	    <td rowspan="1" colspan="1">
	      A <code>TypeInfo</code> object whose
	      <code>TypeInfo.typeNamespace</code> and
	      <code>TypeInfo.typeName</code> are inferred from the
	      schema in use if available.
	    </td>
	  </tr>
	</tbody>
      </table>
      <note>
	<p>
	  The <b>[in-scope namespaces]</b> property is not exposed through the
	  <code>Element</code> node.
	</p>
      </note>
    </div3>

    <div3 id="Element2Infoset">
      <head>Element Node to Infoset</head>
      <p>
	An <code>Element</code> node maps to an <term>element
	information item</term>. Because the Infoset only represents
	unexpanded entity references, non-empty
	<code>EntityReference</code> nodes contained in
	<code>Node.childNodes</code> need to be replaced by their
	content. DOM applications could use the
	<code>Document.normalizeDocument()</code> method for that effect
	with the "<termref def="parameter-entities">entities</termref>"
	parameter set to <code>false</code>. The properties of the
	corresponding <term>element information item</term> are
	constructed as follows:
      </p>
      <table border="1" cellpadding="3" summary="The table contains the mapping of a       Node to the Infoset">
	<tbody>
	  <tr>
	    <th rowspan="1" colspan="1">Property</th>
	    <th rowspan="1" colspan="1">Value</th>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><b>[namespace name]</b></td>
	    <td rowspan="1" colspan="1"><code>Node.namespaceURI</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><b>[local name]</b></td>
	    <td rowspan="1" colspan="1"><code>Node.localName</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><b>[prefix]</b></td>
	    <td rowspan="1" colspan="1"><code>Node.prefix</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><b>[children]</b></td>
	    <td rowspan="1" colspan="1"><code>Node.childNodes</code>, whose
	      expanded entity references (<code>EntityReference</code>
	      nodes with children) have been replaced with
	    their content.</td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><b>[attributes]</b></td>
	    <td rowspan="1" colspan="1">The nodes contained in <code>Node.attributes</code>,
	      whose <code>Node.namespaceURI</code> value is different
	      from <code>"http://www.w3.org/2000/xmlns/"</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><b>[namespace attributes]</b></td>
	    <td rowspan="1" colspan="1">The nodes contained in <code>Node.attributes</code>,
	      whose <code>Node.namespaceURI</code> value is
	      <code>"http://www.w3.org/2000/xmlns/"</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><b>[in-scope namespaces]</b></td>
	    <td rowspan="1" colspan="1">
	      The namespace information items computed using the
	      <b>[namespace attributes]</b> properties of this node and
	      its ancestors. If the <bibref role="informative" ref="DOMXPath"/> module is supported, the namespace
	      information items can also be computed from the
	      <code>XPathNamespace</code> nodes.
	    </td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><b>[base URI]</b></td>
	    <td rowspan="1" colspan="1"><code>Node.baseURI</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><b>[parent]</b></td>
	    <td rowspan="1" colspan="1"><code>Node.parentNode</code></td>
	  </tr>
	</tbody>
      </table>
    </div3>

  </div2>

  <div2 id="AttrMapping">
    <head>Attr Node Mapping</head>

    <div3 id="Infoset2Attr">
      <head>Infoset to Attr Node</head>
      <p>
	An <term>attribute information item</term> map to
	a <code>Attr</code> node. The attributes of the corresponding
	<code>Attr</code> node are constructed as follows:
      </p>
      <table border="1" cellpadding="3" summary="The table contains the mapping of an       Infoset information item to a Node">
	<tbody>
	  <tr>
	    <th rowspan="1" colspan="1">Attribute/Method</th>
	    <th rowspan="1" colspan="1">Value</th>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.nodeName</code></td>
	    <td rowspan="1" colspan="1">same as <code>Attr.name</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.nodeValue</code></td>
	    <td rowspan="1" colspan="1">same as <code>Attr.value</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.nodeType</code></td>
	    <td rowspan="1" colspan="1"><code>Node.ATTRIBUTE_NODE</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.parentNode</code></td>
	    <td rowspan="1" colspan="1"><code>null</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.childNodes</code></td>
	    <td rowspan="1" colspan="1">A <code>NodeList</code> containing one <code>Text</code>
	    node whose text content is the same as
	      <code>Attr.value</code>.
	    </td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.firstChild</code></td>
	    <td rowspan="1" colspan="1">The <code>Text</code> node contained in <code>Node.childNodes</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.lastChild</code></td>
	    <td rowspan="1" colspan="1">The <code>Text</code> node contained in <code>Node.childNodes</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.previousSibling</code></td>
	    <td rowspan="1" colspan="1"><code>null</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.nextSibling</code></td>
	    <td rowspan="1" colspan="1"><code>null</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.attributes</code></td>
	    <td rowspan="1" colspan="1"><code>null</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.ownerDocument</code></td>
	    <td rowspan="1" colspan="1">The document information item</td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.namespaceURI</code></td>
	    <td rowspan="1" colspan="1">The <b>[namespace name]</b> property</td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.prefix</code></td>
	    <td rowspan="1" colspan="1">The <b>[prefix]</b> property</td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.localName</code></td>
	    <td rowspan="1" colspan="1">The <b>[local name]</b> property</td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.baseURI</code></td>
	    <td rowspan="1" colspan="1"><code>null</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.textContent</code></td>
	    <td rowspan="1" colspan="1">the value of <code>Node.textContent</code> of the
	      <code>Text</code> child.
	      same as <code>Node.nodeValue</code> (since this
	      attribute node only contains one <code>Text</code> node)</td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Attr.name</code></td>
	    <td rowspan="1" colspan="1">If the <b>[prefix]</b> property has no value, this contains the
	    <b>[local name]</b> property. Otherwise, this contains the
	      concatenation of the <b>[prefix]</b> property, the colon ':'
	      character, and the <b>[local name]</b> property.</td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Attr.specified</code></td>
	    <td rowspan="1" colspan="1">The <b>[specified]</b> property</td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Attr.value</code></td>
	    <td rowspan="1" colspan="1">The <b>[normalized value]</b> property</td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Attr.ownerElement</code></td>
	    <td rowspan="1" colspan="1">The <b>[owner element]</b> property</td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Attr.schemaTypeInfo</code></td>
	    <td rowspan="1" colspan="1">
	      A <code>TypeInfo</code> object whose
	      <code>TypeInfo.typeNamespace</code> is
	      <code>"http://www.w3.org/TR/REC-xml"</code> and
	      <code>TypeInfo.typeName</code> is the <b>[attribute
	      type]</b> property
	    </td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Attr.isId</code></td>
	    <td rowspan="1" colspan="1">
	      if the <b>[attribute type]</b> property is ID, this method return
	      <code>true</code>
	    </td>
	  </tr>
	</tbody>
      </table>
    </div3>

    <div3 id="Attr2Infoset">
      <head>Attr Node to Infoset</head>
      <p>
	An <code>Attr</code> node maps to an <term>attribute information
	item</term>. <code>Attr</code> nodes with no namespace URI
	(<code>Node.namespaceURI</code> equals to <code>null</code>)
	cannot be represented using the Infoset. The properties of the
	corresponding <term>attribute information item</term> are
	constructed as follows:
      </p>
      <table border="1" cellpadding="3" summary="The table contains the mapping of a       Node to the Infoset">
	<tbody>
	  <tr>
	    <th rowspan="1" colspan="1">Property</th>
	    <th rowspan="1" colspan="1">Value</th>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><b>[namespace name]</b></td>
	    <td rowspan="1" colspan="1"><code>Node.namespaceURI</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><b>[local name]</b></td>
	    <td rowspan="1" colspan="1"><code>Node.localName</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><b>[prefix]</b></td>
	    <td rowspan="1" colspan="1"><code>Node.prefix</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><b>[normalized value]</b></td>
	    <td rowspan="1" colspan="1"><code>Attr.value</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><b>[specified]</b></td>
	    <td rowspan="1" colspan="1"><code>Attr.specified</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><b>[attribute type]</b></td>
	    <td rowspan="1" colspan="1">
	      Using the <code>TypeInfo</code> object referenced from
	      <code>Attr.schemaTypeInfo</code>, the value of
	      <code>TypeInfo.typeName</code> if
	      <code>TypeInfo.typeNamespace</code> is
	      <code>"http://www.w3.org/TR/REC-xml"</code>.
	    </td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><b>[references]</b></td>
	    <td rowspan="1" colspan="1">
	      if the computed <b>[attribute type]</b> property is IDREF,
	      IDREFS, ENTITY, ENTITIES, or NOTATION, the value of this
	      property is an ordered list of the element, unparsed
	      entity, or notation information items referred to in the
	      attribute value, in the order that they appear there. The
	      ordered list is computed using
	      <code>Node.ownerDocument.getElementById</code>,
	      <code>Node.ownerDocument.doctype.entities</code>, and
	      <code>Node.ownerDocument.doctype.notations</code>.
	    </td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><b>[owner element]</b></td>
	    <td rowspan="1" colspan="1"><code>Attr.ownerElement</code></td>
	  </tr>
	</tbody>
      </table>
    </div3>

  </div2>

  <div2 id="ProcessingInstructionMapping">
    <head>ProcessingInstruction Node Mapping</head>

    <div3 id="Infoset2ProcessingInstruction">
      <head>Infoset to ProcessingInstruction Node</head>
      <p>
	A <term>processing instruction information item</term> map to a
	<code>ProcessingInstruction</code> node. The attributes of the
	corresponding <code>ProcessingInstruction</code> node are
	constructed as follows:
      </p>
      <table border="1" cellpadding="3" summary="The table contains the mapping of an       Infoset information item to a Node">
	<tbody>
	  <tr>
	    <th rowspan="1" colspan="1">Attribute</th>
	    <th rowspan="1" colspan="1">Value</th>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.nodeName</code></td>
	    <td rowspan="1" colspan="1">same as <code>ProcessingInstruction.target</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.nodeValue</code></td>
	    <td rowspan="1" colspan="1">same as <code>ProcessingInstruction.data</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.nodeType</code></td>
	    <td rowspan="1" colspan="1"><code>Node.PROCESSING_INSTRUCTION_NODE</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.parentNode</code></td>
	    <td rowspan="1" colspan="1">The <b>[parent]</b> property</td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.childNodes</code></td>
	    <td rowspan="1" colspan="1">empty <code>NodeList</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.firstChild</code></td>
	    <td rowspan="1" colspan="1"><code>null</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.lastChild</code></td>
	    <td rowspan="1" colspan="1"><code>null</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.previousSibling</code></td>
	    <td rowspan="1" colspan="1"><code>null</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.nextSibling</code></td>
	    <td rowspan="1" colspan="1"><code>null</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.attributes</code></td>
	    <td rowspan="1" colspan="1"><code>null</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.ownerDocument</code></td>
	    <td rowspan="1" colspan="1">The document information item</td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.namespaceURI</code></td>
	    <td rowspan="1" colspan="1"><code>null</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.prefix</code></td>
	    <td rowspan="1" colspan="1"><code>null</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.localName</code></td>
	    <td rowspan="1" colspan="1"><code>null</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.baseURI</code></td>
	    <td rowspan="1" colspan="1">The <b>[base URI]</b> property of the parent element if
	      any. The <b>[base URI]</b> property of the processing instruction
	    information item is not exposed through the
	      <code>ProcessingInstruction</code> node.</td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.textContent</code></td>
	    <td rowspan="1" colspan="1">same as <code>Node.nodeValue</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>ProcessingInstruction.target</code></td>
	    <td rowspan="1" colspan="1">The <b>[target]</b> property</td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>ProcessingInstruction.data</code></td>
	    <td rowspan="1" colspan="1">The <b>[content]</b> property</td>
	  </tr>
	</tbody>
      </table>
    </div3>

    <div3 id="ProcessingInstruction2Infoset">
      <head>ProcessingInstruction Node to Infoset</head>
      <p>
	A <code>ProcessingInstruction</code> node maps to an
	<term>processing instruction information item</term>. The
	properties of the corresponding <term>processing instruction
	information item</term> are constructed as follows:
      </p>
      <table border="1" cellpadding="3" summary="The table contains the mapping of a       Node to the Infoset">
	<tbody>
	  <tr>
	    <th rowspan="1" colspan="1">Property</th>
	    <th rowspan="1" colspan="1">Value</th>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><b>[target]</b></td>
	    <td rowspan="1" colspan="1"><code>ProcessingInstruction.target</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><b>[content]</b></td>
	    <td rowspan="1" colspan="1"><code>ProcessingInstruction.data</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><b>[base URI]</b></td>
	    <td rowspan="1" colspan="1"><code>Node.baseURI</code> (which is equivalent to the
	      base URI of its parent element if any)</td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><b>[notation]</b></td>
	    <td rowspan="1" colspan="1">
	      The <code>Notation</code> node named by the target and if
	      available from <code>Node.ownerDocument.doctype.notations</code>
	    </td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><b>[parent]</b></td>
	    <td rowspan="1" colspan="1"><code>Node.parentNode</code></td>
	  </tr>
	</tbody>
      </table>
    </div3>

  </div2>

  <div2 id="EntityReferenceMapping">
    <head>EntityReference Node Mapping</head>

    <div3 id="Infoset2EntityReference">
      <head>Infoset to EntityReference Node</head>
      <p>
	An <term>unexpanded entity reference information item</term>
	maps to a <code>EntityReference</code> node. The attributes of
	the corresponding <code>EntityReference</code> node are
	constructed as follows:
      </p>
      <table border="1" cellpadding="3" summary="The table contains the mapping of an       Infoset information item to a Node">
	<tbody>
	  <tr>
	    <th rowspan="1" colspan="1">Attribute</th>
	    <th rowspan="1" colspan="1">Value</th>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.nodeName</code></td>
	    <td rowspan="1" colspan="1">The <b>[name]</b> property</td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.nodeValue</code></td>
	    <td rowspan="1" colspan="1"><code>null</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.nodeType</code></td>
	    <td rowspan="1" colspan="1"><code>Node.ENTITY_REFERENCE_NODE</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.parentNode</code></td>
	    <td rowspan="1" colspan="1">the <b>[parent]</b> property</td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.childNodes</code></td>
	    <td rowspan="1" colspan="1">Empty <code>NodeList</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.firstChild</code></td>
	    <td rowspan="1" colspan="1"><code>null</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.lastChild</code></td>
	    <td rowspan="1" colspan="1"><code>null</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.previousSibling</code></td>
	    <td rowspan="1" colspan="1"><code>null</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.nextSibling</code></td>
	    <td rowspan="1" colspan="1"><code>null</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.attributes</code></td>
	    <td rowspan="1" colspan="1"><code>null</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.ownerDocument</code></td>
	    <td rowspan="1" colspan="1">The document information item</td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.namespaceURI</code></td>
	    <td rowspan="1" colspan="1"><code>null</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.prefix</code></td>
	    <td rowspan="1" colspan="1"><code>null</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.localName</code></td>
	    <td rowspan="1" colspan="1"><code>null</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.baseURI</code></td>
	    <td rowspan="1" colspan="1">The <b>[declaration base URI]</b> property</td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.textContent</code></td>
	    <td rowspan="1" colspan="1"><code>null</code> (the node has no children)</td>
	  </tr>
	</tbody>
      </table>

      <note>
	<p>
	  The <b>[system identifier]</b> and <b>[public identifier]</b>
	  properties are not exposed through the
	  <code>EntityReference</code> node, but through the
	  <code>Entity</code> node reference from this
	  <code>EntityReference</code> node, if any.
	</p>
      </note>
    </div3>

    <div3 id="EntityReference2Infoset">
      <head>EntityReference Node to Infoset</head>
      <p>
	An <code>EntityReference</code> node maps to an <term>unexpanded
	entity reference information
	item</term>. <code>EntityReference</code> nodes with children
	(<code>Node.childNodes</code> contains a non-empty list) cannot
	be represented using the Infoset. The properties of the
	corresponding <term>unexpanded entity reference information
	item</term> are constructed as follows:
      </p>
      <table border="1" cellpadding="3" summary="The table contains the mapping of a       Node to the Infoset">
	<tbody>
	  <tr>
	    <th rowspan="1" colspan="1">Property</th>
	    <th rowspan="1" colspan="1">Value</th>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><b>[name]</b></td>
	    <td rowspan="1" colspan="1"><code>Node.nodeName</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><b>[system identifier]</b></td>
	    <td rowspan="1" colspan="1">The <code>Entity.systemId</code> value of the
	      <code>Entity</code> node available from
	      <code>Node.ownerDocument.doctype.entities</code> if available</td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><b>[public identifier]</b></td>
	    <td rowspan="1" colspan="1">The <code>Entity.publicId</code> value of the
	      <code>Entity</code> node available from
	      <code>Node.ownerDocument.doctype.entities</code> if available</td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><b>[declaration base URI]</b></td>
	    <td rowspan="1" colspan="1"><code>Node.baseURI</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><b>[parent]</b></td>
	    <td rowspan="1" colspan="1"><code>Node.parentNode</code></td>
	  </tr>
	</tbody>
      </table>
    </div3>

  </div2>

  <div2 id="TextMapping">
    <head>Text and CDATASection Nodes Mapping</head>
    
    <p>
      Since the <bibref ref="InfoSet"/> doesn't represent the boundaries
      of CDATA marked sections, <code>CDATASection</code> nodes cannot
      occur from an infoset mapping.
    </p>

    <div3 id="Infoset2Text">
      <head>Infoset to Text Node</head>
      <p>
	Consecutive <term>character information items</term> map to a
	<code>Text</code> node. The attributes of the corresponding
	<code>Text</code> node are constructed as follows:
      </p>
      <table border="1" cellpadding="3" summary="The table contains the mapping of an       Infoset information item to a Node">
	<tbody>
	  <tr>
	    <th rowspan="1" colspan="1">Attribute/Method</th>
	    <th rowspan="1" colspan="1">Value</th>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.nodeName</code></td>
	    <td rowspan="1" colspan="1"><code>"#text"</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.nodeValue</code></td>
	    <td rowspan="1" colspan="1">same as <code>CharacterData.data</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.nodeType</code></td>
	    <td rowspan="1" colspan="1"><code>Node.TEXT_NODE</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.parentNode</code></td>
	    <td rowspan="1" colspan="1">The <b>[parent]</b> property</td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.childNodes</code></td>
	    <td rowspan="1" colspan="1">empty <code>NodeList</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.firstChild</code></td>
	    <td rowspan="1" colspan="1"><code>null</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.lastChild</code></td>
	    <td rowspan="1" colspan="1"><code>null</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.previousSibling</code></td>
	    <td rowspan="1" colspan="1"><code>null</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.nextSibling</code></td>
	    <td rowspan="1" colspan="1"><code>null</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.attributes</code></td>
	    <td rowspan="1" colspan="1"><code>null</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.ownerDocument</code></td>
	    <td rowspan="1" colspan="1">The document information item</td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.namespaceURI</code></td>
	    <td rowspan="1" colspan="1"><code>null</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.prefix</code></td>
	    <td rowspan="1" colspan="1"><code>null</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.localName</code></td>
	    <td rowspan="1" colspan="1"><code>null</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.baseURI</code></td>
	    <td rowspan="1" colspan="1">null</td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.textContent</code></td>
	    <td rowspan="1" colspan="1">same as <code>Node.nodeValue</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>CharacterData.data</code></td>
	    <td rowspan="1" colspan="1">
	      A <code>DOMString</code> including all <b>[character
	      code]</b> contained in the <term>character information
	      items</term>
	    </td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>CharacterData.length</code></td>
	    <td rowspan="1" colspan="1">
	      The number of 16-bit units needed to encode all ISO 10646
	      character code contained in the <term>character
	      information items</term> using the UTF-16 encoding.
	    </td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Text.isElementContentWhitespace</code></td>
	    <td rowspan="1" colspan="1">The <b>[element content whitespace]</b> property</td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Text.wholeText</code></td>
	    <td rowspan="1" colspan="1">same as <code>CharacterData.data</code></td>
	  </tr>
	</tbody>
      </table>
      <note>
	<p>
	  By construction, the values of the <b>[parent]</b> and <b>[element
	  content whitespace]</b> properties are necessarily the sames for
	  all consecutive <term>character information items</term>.
	</p>
      </note>
    </div3>

    <div3 id="Text2Infoset">
      <head>Text and CDATASection Nodes to Infoset</head>
      <p>
	The text content of a <code>Text</code> or a
	<code>CDATASection</code> node maps to a sequence of
	<term>character information items</term>. The number of items is
	less or equal to <code>CharacterData.length</code>. Text nodes
	contained in <code>Attr</code> nodes are mapped to the Infoset
	using the <code>Attr.value</code> attribute. Text nodes
	contained in <code>Document</code> nodes cannot be represented
	using the Infoset. The properties of the corresponding
	<term>character information items</term> are constructed as
	follows:
      </p>
      <table border="1" cellpadding="3" summary="The table contains the mapping of a       Node to the Infoset">
	<tbody>
	  <tr>
	    <th rowspan="1" colspan="1">Property</th>
	    <th rowspan="1" colspan="1">Value</th>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><b>[character code]</b></td>
	    <td rowspan="1" colspan="1">The ISO 10646 character code produced using one or two
	      <term>16-bit units</term> from <code>CharacterData.data</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><b>[element content whitespace]</b></td>
	    <td rowspan="1" colspan="1"><code>Text.isElementContentWhitespace</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><b>[parent]</b></td>
	    <td rowspan="1" colspan="1"><code>Node.parentNode</code></td>
	  </tr>
	</tbody>
      </table>
    </div3>

  </div2>

  <div2 id="CommentMapping">
    <head>Comment Node Mapping</head>

    <div3 id="Infoset2Comment">
      <head>Infoset to Comment Node</head>
      <p>
	A <term>comment information item</term> maps to a
	<code>Comment</code> node. The attributes of the corresponding
	<code>Comment</code> node are constructed as follows:
      </p>
      <table border="1" cellpadding="3" summary="The table contains the mapping of an       Infoset information item to a Node">
	<tbody>
	  <tr>
	    <th rowspan="1" colspan="1">Attribute</th>
	    <th rowspan="1" colspan="1">Value</th>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.nodeName</code></td>
	    <td rowspan="1" colspan="1"><code>"#comment"</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.nodeValue</code></td>
	    <td rowspan="1" colspan="1">same as <code>CharacterData.data</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.nodeType</code></td>
	    <td rowspan="1" colspan="1"><code>Node.COMMENT_NODE</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.parentNode</code></td>
	    <td rowspan="1" colspan="1">The <b>[parent]</b> property</td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.childNodes</code></td>
	    <td rowspan="1" colspan="1">empty <code>NodeList</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.firstChild</code></td>
	    <td rowspan="1" colspan="1"><code>null</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.lastChild</code></td>
	    <td rowspan="1" colspan="1"><code>null</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.previousSibling</code></td>
	    <td rowspan="1" colspan="1"><code>null</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.nextSibling</code></td>
	    <td rowspan="1" colspan="1"><code>null</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.attributes</code></td>
	    <td rowspan="1" colspan="1"><code>null</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.ownerDocument</code></td>
	    <td rowspan="1" colspan="1">The document information item</td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.namespaceURI</code></td>
	    <td rowspan="1" colspan="1"><code>null</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.prefix</code></td>
	    <td rowspan="1" colspan="1"><code>null</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.localName</code></td>
	    <td rowspan="1" colspan="1"><code>null</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.baseURI</code></td>
	    <td rowspan="1" colspan="1"><code>null</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.textContent</code></td>
	    <td rowspan="1" colspan="1">same as <code>Node.nodeValue</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>CharacterData.data</code></td>
	    <td rowspan="1" colspan="1">
	      The <b>[content]</b> property encoded using the UTF-16 encoding.
	    </td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>CharacterData.length</code></td>
	    <td rowspan="1" colspan="1">
	      The number of 16-bit units needed to encode all ISO character code
	      contained in the <b>[content]</b> property using the UTF-16 encoding.
	    </td>
	  </tr>
	</tbody>
      </table>
    </div3>

    <div3 id="Comment2Infoset">
      <head>Comment Node to Infoset</head>
      <p>
	A <code>Comment</code> maps to a <term>comment information
	item</term>. The properties of the corresponding <term>comment
	information item</term> are constructed as follows:
      </p>
      <table border="1" cellpadding="3" summary="The table contains the mapping of a       Node to the Infoset">
	<tbody>
	  <tr>
	    <th rowspan="1" colspan="1">Property</th>
	    <th rowspan="1" colspan="1">Value</th>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><b>[content]</b></td>
	    <td rowspan="1" colspan="1"><code>CharacterData.data</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><b>[parent]</b></td>
	    <td rowspan="1" colspan="1"><code>Node.parentNode</code></td>
	  </tr>
	</tbody>
      </table>
    </div3>

  </div2>

  <div2 id="DocumentTypeMapping">
    <head>DocumentType Node Mapping</head>

    <div3 id="Infoset2DocumentType">
      <head>Infoset to DocumentType Node</head>
      <p>
	A <term>document type declaration information item</term> maps
	to a <code>DocumentType</code> node. The attributes of the
	corresponding <code>DocumentType</code> node are constructed as
	follows:
      </p>
      <table border="1" cellpadding="3" summary="The table contains the mapping of an       Infoset information item to a Node">
	<tbody>
	  <tr>
	    <th rowspan="1" colspan="1">Attribute</th>
	    <th rowspan="1" colspan="1">Value</th>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.nodeName</code></td>
	    <td rowspan="1" colspan="1">same as <code>DocumentType.name</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.nodeValue</code></td>
	    <td rowspan="1" colspan="1"><code>null</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.nodeType</code></td>
	    <td rowspan="1" colspan="1"><code>Node.DOCUMENT_TYPE_NODE</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.parentNode</code></td>
	    <td rowspan="1" colspan="1">The <b>[parent]</b> property</td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.childNodes</code></td>
	    <td rowspan="1" colspan="1">empty <code>NodeList</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.firstChild</code></td>
	    <td rowspan="1" colspan="1"><code>null</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.lastChild</code></td>
	    <td rowspan="1" colspan="1"><code>null</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.previousSibling</code></td>
	    <td rowspan="1" colspan="1"><code>null</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.nextSibling</code></td>
	    <td rowspan="1" colspan="1"><code>null</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.attributes</code></td>
	    <td rowspan="1" colspan="1"><code>null</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.ownerDocument</code></td>
	    <td rowspan="1" colspan="1">The document information item</td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.namespaceURI</code></td>
	    <td rowspan="1" colspan="1"><code>null</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.prefix</code></td>
	    <td rowspan="1" colspan="1"><code>null</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.localName</code></td>
	    <td rowspan="1" colspan="1"><code>null</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.baseURI</code></td>
	    <td rowspan="1" colspan="1"><code>null</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.textContent</code></td>
	    <td rowspan="1" colspan="1"><code>null</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>DocumentType.name</code></td>
	    <td rowspan="1" colspan="1">
	      The name of the document element.
	    </td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>DocumentType.entities</code></td>
	    <td rowspan="1" colspan="1">
	      The <b>[unparsed entities]</b> property available from the
	      document information item.
	    </td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>DocumentType.notations</code></td>
	    <td rowspan="1" colspan="1">
	      The <b>[notations]</b> property available from the document
	      information item.
	    </td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>DocumentType.publicId</code></td>
	    <td rowspan="1" colspan="1">
	      The <b>[public identifier]</b> property
	    </td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>DocumentType.systemId</code></td>
	    <td rowspan="1" colspan="1">
	      The <b>[system identifier]</b> property
	    </td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>DocumentType.internalSubset</code></td>
	    <td rowspan="1" colspan="1">
	      The value is implementation dependent
	    </td>
	  </tr>
	</tbody>
      </table>

      <note>
	<p>
	  The <b>[children]</b> property is not exposed through the
	  <code>DocumentType</code> node.
	</p>
      </note>
    </div3>

    <div3 id="DocumentType2Infoset">
      <head>DocumentType Node to Infoset</head>
      <p>
	A <code>DocumentType</code> maps to a <term>document type
	declaration information item</term>. The properties of the
	corresponding <term>document type declaration information
	item</term> are constructed as follows:
      </p>
      <table border="1" cellpadding="3" summary="The table contains the mapping of a       Node to the Infoset">
	<tbody>
	  <tr>
	    <th rowspan="1" colspan="1">Property</th>
	    <th rowspan="1" colspan="1">Value</th>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><b>[system identifier]</b></td>
	    <td rowspan="1" colspan="1"><code>DocumentType.systemId</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><b>[public identifier]</b></td>
	    <td rowspan="1" colspan="1"><code>DocumentType.publicId</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><b>[children]</b></td>
	    <td rowspan="1" colspan="1">The value of this property is implementation dependent</td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><b>[parent]</b></td>
	    <td rowspan="1" colspan="1"><code>Node.parentNode</code></td>
	  </tr>
	</tbody>
      </table>
    </div3>

  </div2>

  <div2 id="EntityMapping">
    <head>Entity Node Mapping</head>

    <div3 id="Infoset2Entity">
      <head>Infoset to Entity Node</head>
      <p>
	An <term>unparsed entity information item</term> maps to
	a <code>Entity</code> node. The attributes of the corresponding
	<code>Entity</code> node are constructed as follows:
      </p>
      <table border="1" cellpadding="3" summary="The table contains the mapping of an       Infoset information item to a Node">
	<tbody>
	  <tr>
	    <th rowspan="1" colspan="1">Attribute</th>
	    <th rowspan="1" colspan="1">Value</th>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.nodeName</code></td>
	    <td rowspan="1" colspan="1">The <b>[name]</b> property</td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.nodeValue</code></td>
	    <td rowspan="1" colspan="1"><code>null</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.nodeType</code></td>
	    <td rowspan="1" colspan="1"><code>Node.ENTITY_NODE</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.parentNode</code></td>
	    <td rowspan="1" colspan="1"><code>null</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.childNodes</code></td>
	    <td rowspan="1" colspan="1">Empty <code>NodeList</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.firstChild</code></td>
	    <td rowspan="1" colspan="1"><code>null</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.lastChild</code></td>
	    <td rowspan="1" colspan="1"><code>null</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.previousSibling</code></td>
	    <td rowspan="1" colspan="1"><code>null</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.nextSibling</code></td>
	    <td rowspan="1" colspan="1"><code>null</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.attributes</code></td>
	    <td rowspan="1" colspan="1"><code>null</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.ownerDocument</code></td>
	    <td rowspan="1" colspan="1">The document information item</td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.namespaceURI</code></td>
	    <td rowspan="1" colspan="1"><code>null</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.prefix</code></td>
	    <td rowspan="1" colspan="1"><code>null</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.localName</code></td>
	    <td rowspan="1" colspan="1"><code>null</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.baseURI</code></td>
	    <td rowspan="1" colspan="1">The <b>[declaration base URI]</b> property</td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.textContent</code></td>
	    <td rowspan="1" colspan="1"><code>""</code> (the node has no children)</td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Entity.publicId</code></td>
	    <td rowspan="1" colspan="1">The <b>[public identifier]</b> property</td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Entity.systemId</code></td>
	    <td rowspan="1" colspan="1">The <b>[system identifier]</b> property</td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Entity.notationName</code></td>
	    <td rowspan="1" colspan="1">The <b>[notation name]</b> property</td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Entity.inputEncoding</code></td>
	    <td rowspan="1" colspan="1"><code>null</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Entity.xmlEncoding</code></td>
	    <td rowspan="1" colspan="1"><code>null</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Entity.xmlVersion</code></td>
	    <td rowspan="1" colspan="1"><code>null</code></td>
	  </tr>
	</tbody>
      </table>
      <note>
	<p>
	  The <b>[notation]</b> property is available through the
	  <code>DocumentType</code> node.
	</p>
      </note>

    </div3>

    <div3 id="Entity2Infoset">
      <head>Entity Node to Infoset</head>
      <p>
	An <code>Entity</code> node maps to an <term>unparsed entity
	information item</term>. <code>Entity</code> nodes with children
	(<code>Node.childNodes</code> contains a non-empty list) cannot
	be represented using the Infoset. The properties of the
	corresponding <term>unparsed entity information item</term> are
	constructed as follows:
      </p>
      <table border="1" cellpadding="3" summary="The table contains the mapping of a       Node to the Infoset">
	<tbody>
	  <tr>
	    <th rowspan="1" colspan="1">Property</th>
	    <th rowspan="1" colspan="1">Value</th>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><b>[name]</b></td>
	    <td rowspan="1" colspan="1"><code>Node.nodeName</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><b>[system identifier]</b></td>
	    <td rowspan="1" colspan="1"><code>Entity.systemId</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><b>[public identifier]</b></td>
	    <td rowspan="1" colspan="1"><code>Entity.publicId</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><b>[declaration base URI]</b></td>
	    <td rowspan="1" colspan="1"><code>Node.baseURI</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><b>[notation name]</b></td>
	    <td rowspan="1" colspan="1"><code>Entity.notationName</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><b>[notation]</b></td>
	    <td rowspan="1" colspan="1">The <code>Notation</code> node referenced from
	      <code>DocumentType.notations</code> whose name is the
	      <b>[notation name]</b> property</td>
	  </tr>
	</tbody>
      </table>
    </div3>

  </div2>

  <div2 id="NotationMapping">
    <head>Notation Node Mapping</head>

    <div3 id="Infoset2Notation">
      <head>Infoset to Notation Node</head>
      <p>
	A <term>notation information item</term> maps to a
	<code>Notation</code> node. The attributes of the corresponding
	<code>Notation</code> node are constructed as follows:
      </p>
      <table border="1" cellpadding="3" summary="The table contains the mapping of an       Infoset information item to a Node">
	<tbody>
	  <tr>
	    <th rowspan="1" colspan="1">Attribute</th>
	    <th rowspan="1" colspan="1">Value</th>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.nodeName</code></td>
	    <td rowspan="1" colspan="1">The <b>[name]</b> property</td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.nodeValue</code></td>
	    <td rowspan="1" colspan="1"><code>null</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.nodeType</code></td>
	    <td rowspan="1" colspan="1"><code>Node.NOTATION_NODE</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.parentNode</code></td>
	    <td rowspan="1" colspan="1"><code>null</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.childNodes</code></td>
	    <td rowspan="1" colspan="1">Empty <code>NodeList</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.firstChild</code></td>
	    <td rowspan="1" colspan="1"><code>null</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.lastChild</code></td>
	    <td rowspan="1" colspan="1"><code>null</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.previousSibling</code></td>
	    <td rowspan="1" colspan="1"><code>null</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.nextSibling</code></td>
	    <td rowspan="1" colspan="1"><code>null</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.attributes</code></td>
	    <td rowspan="1" colspan="1"><code>null</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.ownerDocument</code></td>
	    <td rowspan="1" colspan="1">The document information item</td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.namespaceURI</code></td>
	    <td rowspan="1" colspan="1"><code>null</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.prefix</code></td>
	    <td rowspan="1" colspan="1"><code>null</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.localName</code></td>
	    <td rowspan="1" colspan="1"><code>null</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.baseURI</code></td>
	    <td rowspan="1" colspan="1">The <b>[declaration base URI]</b> property</td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Node.textContent</code></td>
	    <td rowspan="1" colspan="1"><code>null</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Notation.publicId</code></td>
	    <td rowspan="1" colspan="1">The <b>[public identifier]</b> property</td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><code>Notation.systemId</code></td>
	    <td rowspan="1" colspan="1">The <b>[system identifier]</b> property</td>
	  </tr>
	</tbody>
      </table>
    </div3>

    <div3 id="Notation2Infoset">
      <head>Notation Node to Infoset</head>
      <p>
	A <code>Notation</code> maps to a <term>notation information
	item</term>. The properties of the corresponding <term>notation
	information item</term> are constructed as follows:
      </p>
      <table border="1" cellpadding="3" summary="The table contains the mapping of a       Notation node to the Infoset">
	<tbody>
	  <tr>
	    <th rowspan="1" colspan="1">Property</th>
	    <th rowspan="1" colspan="1">Value</th>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><b>[name]</b></td>
	    <td rowspan="1" colspan="1"><code>Node.nodeName</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><b>[system identifier]</b></td>
	    <td rowspan="1" colspan="1"><code>Notation.systemId</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><b>[public identifier]</b></td>
	    <td rowspan="1" colspan="1"><code>Notation.publicId</code></td>
	  </tr>
	  <tr>
	    <td rowspan="1" colspan="1"><b>[parent]</b></td>
	    <td rowspan="1" colspan="1"><code>Node.parentNode</code></td>
	  </tr>
	</tbody>
      </table>
    </div3>
  </div2>

</div1>

  
<!-- $Id: config-table.xml,v 1.7 2003/08/15 17:36:31 plehegar Exp $ -->
<div1 id="Parameters">
  <head>Configuration Settings</head>
  
  <orglist role="editors">
    <member>
      <name>Elena Litani</name> 
      <affiliation>IBM</affiliation>
    </member>
  </orglist>
  <div2 id="ConfigTable">
    <head>Configuration Scenarios</head>
    <p>
      Using the <code>DOMConfiguration</code> users can change behavior
      of the <code>DOMParser</code>, <code>DOMSerializer</code> and
      <code>Document.normalizeDocument()</code>.  If a DOM
      implementation supports XML Schemas and DTD validation, the table
      below defines behavior of such implementation following various
      parameter settings on the <code>DOMConfiguration</code>. Errors
      are effectively reported only if a <code>DOMErrorHandler</code>
      object is attached to the "<termref def="parameter-error-handler">error-handler</termref>" parameter.
    </p>
    
    <table summary="Layout table: the first cell contains the value of schema-type       parameter, the second contains the value of validate parameter,       the third contains the value of the validate-if-schema parameter,       the 4th contains the actual document schemas, the 5th contains the output       of such configuration, the 6th list addition parameters that can be effected." border="1">
      <tbody>	
        <tr> 
          <th rowspan="1" colspan="1">"<termref def="parameter-schema-type">schema-type</termref>"</th> 
          <th rowspan="1" colspan="1">"<termref def="parameter-validate">validate</termref>"</th> 
          <th rowspan="1" colspan="1">"<termref def="parameter-validate-if-schema">validate-if-schema</termref>"</th> 
          <th rowspan="1" colspan="1">Instance schemas, i.e. the current schema</th>
          <th rowspan="1" colspan="1">Outcome</th>
          <th rowspan="1" colspan="1">Other parameters</th> 
        </tr>
        <tr>
	  <td rowspan="2" colspan="1"><code>null</code></td>
	  <td rowspan="1" colspan="1"><code>true</code></td>
	  <td rowspan="1" colspan="1"><code>false</code></td>
	  <td rowspan="2" colspan="1">DTD and XML Schema</td>
	  <td rowspan="2" colspan="1">Implementation dependent</td>
	  <td rowspan="2" colspan="1">
	    The outcome of setting the "<termref def="parameter-datatype-normalization">datatype-normalization</termref>",
	    "<termref def="parameter-element-content-whitespace">element-content-whitespace</termref>"
	    or "<termref def="parameter-namespaces">namespaces</termref>" parameters
	    to <code>true</code> or <code>false</code> is implementation
	    dependent.
	  </td>
	</tr>
	<tr>
	  <td rowspan="1" colspan="1"><code>false</code></td>
	  <td rowspan="1" colspan="1"><code>true</code></td>
	</tr>
	<tr>
	  <td rowspan="2" colspan="1"><code>null</code></td>
	  <td rowspan="1" colspan="1"><code>true</code></td>
	  <td rowspan="1" colspan="1"><code>false</code></td>
	  <td rowspan="2" colspan="1">none</td>
	  <td rowspan="1" colspan="1">Report an error</td>
	  <td rowspan="2" colspan="1">
	    Setting the "<termref def="parameter-datatype-normalization">datatype-normalization</termref>"
	    to <code>true</code> or <code>false</code> has no effect on
	    the DOM.
	  </td>
	</tr>
	<tr>
	  <td rowspan="1" colspan="1"><code>false</code></td>
	  <td rowspan="1" colspan="1"><code>true</code></td>
	  <td rowspan="1" colspan="1">No error is reported</td>
	</tr>
	<tr>
	  <td rowspan="2" colspan="1"><code>null</code></td>
	  <td rowspan="1" colspan="1"><code>true</code></td>
	  <td rowspan="1" colspan="1"><code>false</code></td>
	  <td rowspan="2" colspan="1">DTD</td>
	  <td rowspan="2" colspan="1">Validate against DTD</td>
	  <td rowspan="2" colspan="1">
	    Setting the "<termref def="parameter-datatype-normalization">datatype-normalization</termref>"
	    to <code>true</code> or <code>false</code> has no effect on
	    the DOM.  </td>
	</tr>
	<tr>
	  <td rowspan="1" colspan="1"><code>false</code></td>
	  <td rowspan="1" colspan="1"><code>true</code></td></tr>
	<tr>
	  <td rowspan="2" colspan="1"><code>null</code></td>
	  <td rowspan="1" colspan="1"><code>true</code></td>
	  <td rowspan="1" colspan="1"><code>false</code></td>
	  <td rowspan="2" colspan="1">XML Schema</td>
	  <td rowspan="2" colspan="1">
	    Validate against XML Schema
	  </td>
	  <td rowspan="2" colspan="1">
	    The outcome of setting the "<termref def="parameter-namespaces">namespaces</termref>" to
	    <code>false</code> is implementation dependent (likely to be
	    an error). Setting the "<termref def="parameter-element-content-whitespace">element-content-whitespace</termref>"
	    to <code>false</code> does not have any effect on the DOM.
	  </td>
	</tr>
	<tr>
	  <td rowspan="1" colspan="1"><code>false</code></td>
	  <td rowspan="1" colspan="1"><code>true</code></td>
	</tr>
	<tr>
	  <td rowspan="2" colspan="1"><code>"http://www.w3.org/TR/REC-xml"</code></td>
	  <td rowspan="1" colspan="1"><code>true</code></td>
	  <td rowspan="1" colspan="1"><code>false</code></td>
	  <td rowspan="2" colspan="1">DTD or XML Schema or both</td>
	  <td rowspan="1" colspan="1">
	    If DTD is found, validate against DTD.  Otherwise, report an
	    error.
	  </td>
	  <td rowspan="2" colspan="1">
	    Setting the "<termref def="parameter-datatype-normalization">datatype-normalization</termref>"
	    to <code>true</code> or <code>false</code> has no effect on
	    the DOM.
	  </td>
	</tr>
	<tr>
	  <td rowspan="1" colspan="1"><code>false</code></td>
	  <td rowspan="1" colspan="1"><code>true</code></td>
	  <td rowspan="1" colspan="1">If DTD is found, validate against DTD.</td>
	</tr>
	
	<tr>
	  <td rowspan="2" colspan="1"><code>"http://www.w3.org/2001/XMLSchema"</code></td>
	  <td rowspan="1" colspan="1"><code>true</code></td>
	  <td rowspan="1" colspan="1"><code>false</code></td>
	  <td rowspan="2" colspan="1">DTD or XML Schema or both</td>
	  <td rowspan="1" colspan="1">
	    If XML Schema is found, validate against the schema. 
	    Otherwise, report an error.
	  </td>
	  <td rowspan="2" colspan="1">
	    Setting the "<termref def="parameter-datatype-normalization">datatype-normalization</termref>"
	    to <code>true</code> exposes XML Schema <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/2001/REC-xmlschema-1-20010502/#key-nv" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">normalized values</loc> in the
	    DOM.  The outcome of setting the "<termref def="parameter-namespaces">namespaces</termref>" to
	    <code>false</code> is implementation dependent (likely to be
	    an error).
	  </td>
	</tr>
	<tr>
	  <td rowspan="1" colspan="1"><code>false</code></td>
	  <td rowspan="1" colspan="1"><code>true</code></td>
	  <td rowspan="1" colspan="1">
	    If XML Schema is found, validate against the schema.
	  </td>
	</tr>
	<tr>
	  <td rowspan="1" colspan="1">
	    <code>"http://www.w3.org/2001/XMLSchema"</code> or
	    <code>"http://www.w3.org/TR/REC-xml"</code>
	  </td>
	  <td rowspan="1" colspan="1"><code>false</code></td>
	  <td rowspan="1" colspan="1"><code>false</code></td>
	  <td rowspan="1" colspan="1">DTD or XML Schema or both</td>
	  <td rowspan="1" colspan="1">
	    If XML Schema is found, it is ignored. DOM implementations
	    <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/2004/REC-xml-20040204#proc-types" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">may</loc> use information
	    available in the DTD to perform <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/2004/REC-xml-20040204#intern-replacement" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">entity
	    resolution</loc>.
	  </td>
	  <td rowspan="1" colspan="1">
	    Setting the "<termref def="parameter-datatype-normalization">datatype-normalization</termref>"
	    to <code>true</code> of <code>false</code> has no effect on
	    the DOM.
	  </td>
	</tr>
      </tbody>
    </table>

    <note>
      <p>
	If an error has to be reported, as specified in the "Outcome"
	column above, the <code>DOMError.type</code> is
	<code>"no-schema-available"</code>.
      </p>
    </note>
  </div2>
</div1>

  
<!-- $Id: i18nfunctions.xml,v 1.3 2003/08/05 21:26:52 plehegar Exp $ -->
<!--
 *************************************************************************
 * BEGINNING OF DOM I18N                                                 * 
 *************************************************************************
-->
<div1 id="i18n"> 
  <head>Accessing code point boundaries</head> 
  <orglist> 
    <member> 
      <name>Mark Davis</name> 
      <affiliation>IBM</affiliation> 
    </member> 
    <member> 
      <name>Lauren Wood</name> 
      <affiliation>SoftQuad Software Inc.</affiliation> 
    </member> 
  </orglist><?GENERATE-MINI-TOC?>
  <div2 id="i18n-introduction"> 
    <head>Introduction</head>
    <p>
      This appendix is an informative, not a normative, part of the Level 3 DOM
      specification.
    </p>

    <p>
      Characters are represented in Unicode by numbers called <i>code
      points</i> (also called <i>scalar values</i>). These numbers can range
      from 0 up to 1,114,111 = 10FFFF<sub>16</sub> (although some of these values are
      illegal). Each code point can be directly encoded with a 32-bit code unit. 
      This encoding is termed UCS-4 (or UTF-32). 
      The DOM specification, however, uses UTF-16, in which the most frequent 
      characters (which have values less than FFFF<sub>16</sub>) are represented 
      by a single 16-bit code unit, while characters above FFFF<sub>16</sub>
      use a special pair of code units called a <i>surrogate pair</i>. For more information, 
      see <bibref ref="Unicode"/> or the Unicode Web site.
    </p>

    <p>
      While indexing by code points as opposed to code units is not
      common in programs, some specifications such as <bibref role="informative" ref="XPath10"/> (and therefore XSLT and <bibref role="informative" ref="XPointer"/>) use code point indices.  For
      interfacing with such formats it is recommended that the
      programming language provide string processing methods for
      converting code point indices to code unit indices and back. Some
      languages do not provide these functions natively; for these it is
      recommended that the native <code>String</code> type that is bound
      to <code>DOMString</code> be extended to enable this
      conversion. An example of how such an API might look is supplied
      below.
    </p>
    <note>
      <p>
	Since these methods are supplied as an illustrative example of the type
	of functionality that is required, the names of the methods,
	exceptions, and interface may differ from those given here.
      </p>
    </note>

  </div2> 
  <div2 id="i18n-methods"> 
    <head>Methods</head> 
    <definitions> 
      <interface id="i18n-methods-StringExtend" name="StringExtend">
	<descr>
	  <p>Extensions to a language's native String class or interface</p>
	</descr>
	<method id="i18n-methods-StringExtend-findOffset16" name="findOffset16">
	  <descr>
	    <p>Returns the UTF-16 offset that corresponds to a UTF-32 offset.
	      Used for random access.</p>
		<note>
		  <p>
		    You can always round-trip from a UTF-32 offset to a UTF-16
		    offset and back. You can round-trip from a UTF-16 offset to
		    a UTF-32 offset and back if and only if the offset16 is not
		    in the middle of a surrogate pair. Unmatched surrogates
		    count as a single UTF-16 value.
		  </p>
		</note>
	  </descr>
	  <parameters>
	    <param name="offset32" type="int" attr="in">
	      <descr> 
		<p>
		  UTF-32 offset. 
		</p>
	      </descr>
	    </param>
	  </parameters>
	  <returns type="int">
	    <descr>
	      <p>UTF-16 offset</p>
	    </descr>
	  </returns>
	  <raises>
	    <exception name="StringIndexOutOfBoundsException">
	      <descr>
		<p>
		  if <code>offset32</code> is out of bounds.
		</p>
	      </descr>
	    </exception>
	  </raises>
	</method>
	<method id="i18n-methods-StringExtend-findOffset32" name="findOffset32">
	  <descr>
	    <p>
	      Returns the UTF-32 offset corresponding to a UTF-16 offset. Used
	      for random access. To find the UTF-32 length of a string, use:
	      <eg xml:space="preserve">len32 = findOffset32(source, source.length());</eg>
	    </p>
	    <note>
	      <p>
		If the UTF-16 offset is into the middle of a surrogate pair,
		then the UTF-32 offset of the <emph>end</emph> of the pair is
		returned; that is, the index of the char after the end of the
		pair. You can always round-trip from a UTF-32 offset to a UTF-16
		offset and back. You can round-trip from a UTF-16 offset to a
		UTF-32 offset and back if and only if the offset16 is not in
		the middle of a surrogate pair. Unmatched surrogates count as a
		single UTF-16 value.
	      </p>
	    </note>
	  </descr>
	  <parameters>
	    <param attr="in" type="int" name="offset16">
	      <descr>
		<p>UTF-16 offset</p>
	      </descr>
	    </param>
	  </parameters>
	  <returns type="int">
	    <descr>
	      <p>UTF-32 offset</p>
	    </descr>
	  </returns>
	  <raises>
	    <exception name="StringIndexOutOfBoundsException">
	      <descr>
		<p>if offset16 is out of bounds.</p>
	      </descr>
	    </exception>
	  </raises>
	</method>
      </interface>
    </definitions> 
  </div2>
</div1>


<div1 role="idl" id="idl">
  <head>IDL Definitions</head>

  <p>This appendix contains the complete OMG IDL <bibref ref="OMGIDL"/> for
  the Level 3 Document Object Model Core definitions.</p>

  <p>The IDL files are also available as: <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="idl.zip" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/idl.zip</loc></p>

    <!--
    ******************************************************
    | CORE OMG IDL DEFINITIONS                           |
    ******************************************************
    -->
      <?GENERATE-IDL Core dom w3c.org?>
</div1>

<div1 role="java-binding" id="java-binding">
  <head>Java Language Binding</head>

  <p>This appendix contains the complete Java <bibref ref="Java"/> bindings
  for the Level 3 Document Object Model Core.</p>

  <p>The Java files are also available as <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="java-binding.zip" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/java-binding.zip</loc></p>

  <!--
  ******************************************************
  | CORE JAVA BINDINGS                                 |
  ******************************************************
  -->
  
<!--[ Java Bootstrap extension ]-->    
<!-- $Id: java-bootstrap.xml,v 1.25 2004/04/01 19:47:41 plehegar Exp $ -->

<div2 id="Level-3-Java-Binding-Extension">
  <head>Java Binding Extension</head>

  <note>
    <p>
      This section is informative.
    </p>
  </note>
  <p>This section defines the <code>DOMImplementationRegistry</code> object,
    discussed in <specref ref="Bootstrap"/>, for Java.</p>
  <p>The <code>DOMImplementationRegistry</code> is first initialized by the
    application or the implementation, depending on the context, through the
    Java system property "org.w3c.dom.DOMImplementationSourceList". The value
    of this property is a space separated list of names of available classes
    implementing the <code>DOMImplementationSource</code> interface.</p>

  <source-code type="text/java" name="DOMImplementationRegistry" package="org.w3c.dom.bootstrap" xml:space="preserve">
package org.w3c.dom.bootstrap;

import java.util.StringTokenizer;
import java.util.Vector;
import org.w3c.dom.DOMImplementationSource;
import org.w3c.dom.DOMImplementationList;
import org.w3c.dom.DOMImplementation;
import java.io.InputStream;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.security.AccessController;
import java.security.PrivilegedAction;

/**
 * A factory that enables applications to obtain instances of
 * &lt;code&gt;DOMImplementation&lt;/code&gt;.
 *
 * &lt;p&gt;
 * Example:
 * &lt;/p&gt;
 *
 * &lt;pre class='example'&gt;
 *  // get an instance of the DOMImplementation registry
 *  DOMImplementationRegistry registry =
 *       DOMImplementationRegistry.newInstance();
 *  // get a DOM implementation the Level 3 XML module
 *  DOMImplementation domImpl =
 *       registry.getDOMImplementation("XML 3.0");
 * &lt;/pre&gt;
 *
 * &lt;p&gt;
 * This provides an application with an implementation-independent starting
 * point. DOM implementations may modify this class to meet new security
 * standards or to provide *additional* fallbacks for the list of
 * DOMImplementationSources.
 * &lt;/p&gt;
 *
 * @see DOMImplementation
 * @see DOMImplementationSource
 * @since DOM Level 3
 */
public final class DOMImplementationRegistry {
    /**
     * The system property to specify the
     * DOMImplementationSource class names.
     */
    public static final String PROPERTY =
	"org.w3c.dom.DOMImplementationSourceList";
    
    /**
     * Default columns per line.
     */
    private static final int DEFAULT_LINE_LENGTH = 80;
    
    /**
     * The list of DOMImplementationSources.
     */
    private Vector sources;
    
    /**
     * Private constructor.
     * @param srcs Vector List of DOMImplementationSources
     */
    private DOMImplementationRegistry(final Vector srcs) {
	sources = srcs;
    }
    
    /**
     * Obtain a new instance of a &lt;code&gt;DOMImplementationRegistry&lt;/code&gt;.
     *

     * The &lt;code&gt;DOMImplementationRegistry&lt;/code&gt; is initialized by the
     * application or the implementation, depending on the context, by
     * first checking the value of the Java system property
     * &lt;code&gt;org.w3c.dom.DOMImplementationSourceList&lt;/code&gt; and
     * the the service provider whose contents are at
     * "&lt;code&gt;META_INF/services/org.w3c.dom.DOMImplementationSourceList&lt;/code&gt;"
     * The value of this property is a white-space separated list of
     * names of availables classes implementing the
     * &lt;code&gt;DOMImplementationSource&lt;/code&gt; interface. Each class listed
     * in the class name list is instantiated and any exceptions
     * encountered are thrown to the application.
     *
     * @return an initialized instance of DOMImplementationRegistry
     * @throws ClassNotFoundException
     *     If any specified class can not be found
     * @throws InstantiationException
     *     If any specified class is an interface or abstract class
     * @throws IllegalAccessException
     *     If the default constructor of a specified class is not accessible
     * @throws ClassCastException
     *     If any specified class does not implement
     * &lt;code&gt;DOMImplementationSource&lt;/code&gt;
     */
    public static DOMImplementationRegistry newInstance()
	throws
	ClassNotFoundException,
	InstantiationException,
	IllegalAccessException,
	ClassCastException {
	Vector sources = new Vector();
	
	ClassLoader classLoader = getClassLoader();
	// fetch system property:
	String p = getSystemProperty(PROPERTY);
	
	//
	// if property is not specified then use contents of
        // META_INF/org.w3c.dom.DOMImplementationSourceList from classpath
	if (p == null) {
	    p = getServiceValue(classLoader);
	} 
        if (p == null) {
	    //
	    // DOM Implementations can modify here to add *additional* fallback
	    // mechanisms to access a list of default DOMImplementationSources.
	    
	}
	if (p != null) {
	    StringTokenizer st = new StringTokenizer(p);
	    while (st.hasMoreTokens()) {
		String sourceName = st.nextToken();
		// Use context class loader, falling back to Class.forName
		// if and only if this fails...
		Class sourceClass = null;
		if (classLoader != null) {
		    sourceClass = classLoader.loadClass(sourceName);
		} else {
		    sourceClass = Class.forName(sourceName);
		}
		DOMImplementationSource source =
		    (DOMImplementationSource) sourceClass.newInstance();
		sources.addElement(source);
	    }
	}
	return new DOMImplementationRegistry(sources);
    }
    
    /**
     * Return the first implementation that has the desired
     * features, or &lt;code&gt;null&lt;/code&gt; if none is found.
     *
     * @param features
     *            A string that specifies which features are required. This is
     *            a space separated list in which each feature is specified by
     *            its name optionally followed by a space and a version number.
     *            This is something like: "XML 1.0 Traversal +Events 2.0"
     * @return An implementation that has the desired features,
     *         or &lt;code&gt;null&lt;/code&gt; if none found.
     */
    public DOMImplementation getDOMImplementation(final String features) {
	int size = sources.size();
	String name = null;
	for (int i = 0; i &lt; size; i++) {
	    DOMImplementationSource source =
		(DOMImplementationSource) sources.elementAt(i);
	    DOMImplementation impl = source.getDOMImplementation(features);
	    if (impl != null) {
		return impl;
	    }
	}
	return null;
    }
    
    /**
     * Return a list of implementations that support the
     * desired features.
     *
     * @param features
     *            A string that specifies which features are required. This is
     *            a space separated list in which each feature is specified by
     *            its name optionally followed by a space and a version number.
     *            This is something like: "XML 1.0 Traversal +Events 2.0"
     * @return A list of DOMImplementations that support the desired features.
     */
    public DOMImplementationList getDOMImplementationList(final String features) {
	final Vector implementations = new Vector();
	int size = sources.size();
	for (int i = 0; i &lt; size; i++) {
	    DOMImplementationSource source =
		(DOMImplementationSource) sources.elementAt(i);
	    DOMImplementationList impls =
		source.getDOMImplementationList(features);
	    for (int j = 0; j &lt; impls.getLength(); j++) {
		DOMImplementation impl = impls.item(j);
		implementations.addElement(impl);
	    }
	}
	return new DOMImplementationList() {
		public DOMImplementation item(final int index) {
		    if (index &gt;= 0 &amp;&amp; index &lt; implementations.size()) {
			try {
			    return (DOMImplementation)
				implementations.elementAt(index);
			} catch (ArrayIndexOutOfBoundsException e) {
			    return null;
			}
		    }
		    return null;
		}
		
		public int getLength() {
		    return implementations.size();
		}
	    };
    }
    
    /**
     * Register an implementation.
     *
     * @param s The source to be registered, may not be &lt;code&gt;null&lt;/code&gt;
     */
    public void addSource(final DOMImplementationSource s) {
	if (s == null) {
	    throw new NullPointerException();
	}
	if (!sources.contains(s)) {
	    sources.addElement(s);
	}
    }
    
    /**
     *
     * Gets a class loader.
     *
     * @return A class loader, possibly &lt;code&gt;null&lt;/code&gt;
     */
    private static ClassLoader getClassLoader() {
	try {
	    ClassLoader contextClassLoader = getContextClassLoader();
	    
	    if (contextClassLoader != null) {
		return contextClassLoader;
	    }
	} catch (Exception e) {
	    // Assume that the DOM application is in a JRE 1.1, use the
	    // current ClassLoader
	    return DOMImplementationRegistry.class.getClassLoader();
	}
	return DOMImplementationRegistry.class.getClassLoader();
    }
    
    /**
     * This method attempts to return the first line of the resource
     * META_INF/services/org.w3c.dom.DOMImplementationSourceList
     * from the provided ClassLoader.
     *
     * @param classLoader classLoader, may not be &lt;code&gt;null&lt;/code&gt;.
     * @return first line of resource, or &lt;code&gt;null&lt;/code&gt;
     */
    private static String getServiceValue(final ClassLoader classLoader) {
	String serviceId = "META-INF/services/" + PROPERTY;
	// try to find services in CLASSPATH
	try {
	    InputStream is = getResourceAsStream(classLoader, serviceId);
	    
	    if (is != null) {
		BufferedReader rd;
		try {
		    rd =
			new BufferedReader(new InputStreamReader(is, "UTF-8"),
					   DEFAULT_LINE_LENGTH);
		} catch (java.io.UnsupportedEncodingException e) {
		    rd =
			new BufferedReader(new InputStreamReader(is),
					   DEFAULT_LINE_LENGTH);
		}		
		String serviceValue = rd.readLine();
		rd.close();
		if (serviceValue != null &amp;&amp; serviceValue.length() &gt; 0) {
		    return serviceValue;
		}
	    }
	} catch (Exception ex) {
	    return null;
	}
	return null;
    }
    
    /**
     * A simple JRE (Java Runtime Environment) 1.1 test
     *
     * @return &lt;code&gt;true&lt;/code&gt; if JRE 1.1 
     */
    private static boolean isJRE11() {
	try {
	    Class c = Class.forName("java.security.AccessController");
	    // java.security.AccessController existed since 1.2 so, if no
	    // exception was thrown, the DOM application is running in a JRE
	    // 1.2 or higher
	    return false;
	} catch (Exception ex) {
	    // ignore 
	}
	return true;
    }
    
    /**
     * This method returns the ContextClassLoader or &lt;code&gt;null&lt;/code&gt; if
     * running in a JRE 1.1
     *
     * @return The Context Classloader
     */
    private static ClassLoader getContextClassLoader() {
	return isJRE11()
	    ? null
	    : (ClassLoader)
 	      AccessController.doPrivileged(new PrivilegedAction() {
		    public Object run() {
			ClassLoader classLoader = null;
			try {
			    classLoader =
				Thread.currentThread().getContextClassLoader();
			} catch (SecurityException ex) {
			}
			return classLoader;
		    }
		});
    }
    
    /**
     * This method returns the system property indicated by the specified name
     * after checking access control privileges. For a JRE 1.1, this check is
     * not done.
     * 	 
     * @param name the name of the system property	 
     * @return the system property
     */
    private static String getSystemProperty(final String name) {
	return isJRE11()
	    ? (String) System.getProperty(name)
	    : (String) AccessController.doPrivileged(new PrivilegedAction() {
		    public Object run() {
			return System.getProperty(name);
		    }
		});
    }
    
    /**
     * This method returns an Inputstream for the reading resource
     * META_INF/services/org.w3c.dom.DOMImplementationSourceList after checking
     * access control privileges. For a JRE 1.1, this check is not done.
     *
     * @param classLoader classLoader	 
     * @param name the resource 	 
     * @return an Inputstream for the resource specified
     */
    private static InputStream getResourceAsStream(final ClassLoader classLoader,
						   final String name) {
	if (isJRE11()) {
	    InputStream ris;
	    if (classLoader == null) {
		ris = ClassLoader.getSystemResourceAsStream(name);
	    } else {
		ris = classLoader.getResourceAsStream(name);
	    }    
	    return ris;
	} else {
	    return (InputStream)
		AccessController.doPrivileged(new PrivilegedAction() {
			public Object run() {
			    InputStream ris;
			    if (classLoader == null) {
				ris =
				    ClassLoader.getSystemResourceAsStream(name);
			    } else {
				ris = classLoader.getResourceAsStream(name);
			    }
			    return ris;
			}
		    });
	}
    }
}
</source-code>

</div2>


  <div2 id="JavaCoreInterfaces">
    <head>Other Core interfaces</head>
    <?GENERATE-JAVA Core org.w3c dom?>
  </div2>
</div1>
<div1 role="ecma-binding" id="ecma-binding">
  <head>ECMAScript Language Binding</head>

  <p>This appendix contains the complete ECMAScript <bibref ref="ECMAScript"/> binding for the Level 3 Document Object Model Core
  definitions.</p>

    <!--
    ******************************************************
    | CORE ECMA SCRIPT BINDINGS                         |
    ******************************************************
    -->
  
<!--[ ECMAScript Bootstrap extension ]-->    
<!-- $Id: ecma-bootstrap.xml,v 1.5 2003/09/15 13:58:10 plehegar Exp $ -->

<div2 id="Level-3-ECMAScript-Binding-Extension">
  <head>ECMAScript Binding Extension</head>

  <p>This section defines the <code>DOMImplementationRegistry</code> object,
    discussed in <specref ref="Bootstrap"/>, for ECMAScript.</p>

  <glist role="ecma-block">
    <gitem>
      <label>Objects that implements the DOMImplementationRegistry
      interface</label>
      <def>
        <glist>
          <gitem>
            <label>DOMImplementationRegistry is a global variable
              which has the following functions:</label>
            <def>
              <glist>
                <gitem>
                  <label>getDOMImplementation(features)</label>
                  <def>
                    <p>This method returns the first registered object
                    that implements the <b>DOMImplementation</b>
                    interface and has the desired features, or
                    <b>null</b> if none is found.</p> <p>The
                    <b>features</b> parameter is a <b>String</b>. See
                    also
                    <code>DOMImplementationSource.getDOMImplementation()</code>.
		    </p>
                  </def>
                </gitem>
                <gitem>
                  <label>getDOMImplementationList(features)</label>
                  <def>
                    <p>This method returns a
		      <code>DOMImplementationList</code> list of registered object
                    that implements the <b>DOMImplementation</b>
                    interface and has the desired features.</p> <p>The
                    <b>features</b> parameter is a <b>String</b>. See
                    also
                    <code>DOMImplementationSource.getDOMImplementationList()</code>.
		    </p>
                  </def>
                </gitem>
              </glist>
            </def>
          </gitem>
        </glist>
      </def>
    </gitem>
  </glist>

</div2>


  <div2 id="ECMAScriptCoreInterfaces">
    <head>Other Core interfaces</head>
    <?GENERATE-ECMA Core?>

    <note>
      <p>
	In addition of having <code>DOMConfiguration</code> parameters
	exposed to the application using the <code>setParameter</code>
	and <code>getParameter</code>, those parameters are also exposed
	as ECMAScript properties on the <code>DOMConfiguration</code>
	object. The name of the parameter is converted into a property
	name using a camel-case convention: the character '-'
	(HYPHEN-MINUS) is removed and the following character is
	being replaced by its uppercase equivalent.
      </p>
    </note>
  </div2>
</div1>
    <div1 role="acknowledgements" id="contributors"> 
      <head>Acknowledgements</head> 
      
      <p>Many people contributed to the DOM specifications (Level 1, 2
      or 3), including participants of the DOM Working Group and the DOM
      Interest Group. We especially thank the following:</p>

      <p>
	Andrew Watson (Object Management Group), Andy Heninger (IBM),
	Angel Diaz (IBM), Arnaud Le Hors (W3C and IBM), Ashok Malhotra
	(IBM and Microsoft), Ben Chang (Oracle), Bill Smith (Sun), Bill
	Shea (Merrill Lynch), Bob Sutor (IBM), Chris Lovett (Microsoft),
	Chris Wilson (Microsoft), David Brownell (Sun), David Ezell
	(Hewlett-Packard Company), David Singer (IBM), Dimitris
	Dimitriadis (Improve AB and invited expert), Don Park (invited),
	Elena Litani (IBM), Eric Vasilik (Microsoft), Gavin Nicol
	(INSO), Ian Jacobs (W3C), James Clark (invited), James Davidson
	(Sun), Jared Sorensen (Novell), Jeroen van Rotterdam (X-Hive
	Corporation), Joe Kesselman (IBM), Joe Lapp (webMethods), Joe
	Marini (Macromedia), Johnny Stenback (Netscape/AOL), Jon
	Ferraiolo (Adobe), Jonathan Marsh (Microsoft), Jonathan Robie
	(Texcel Research and Software AG), Kim Adamson-Sharpe (SoftQuad
	Software Inc.), Lauren Wood (SoftQuad Software Inc.,
	<emph>former Chair</emph>), Laurence Cable (Sun), Mark Davis
	(IBM), Mark Scardina (Oracle), Martin D&#252;rst (W3C), Mary
	Brady (NIST), Mick Goulish (Software AG), Mike Champion
	(Arbortext and Software AG), Miles Sabin (Cromwell Media), Patti
	Lutsky (Arbortext), Paul Grosso (Arbortext), Peter Sharpe
	(SoftQuad Software Inc.), Phil Karlton (Netscape), Philippe Le
	H&#233;garet (W3C, <emph>W3C Team Contact and former
	Chair</emph>), Ramesh Lekshmynarayanan (Merrill Lynch), Ray
	Whitmer (iMall, Excite@Home, and Netscape/AOL,
	<emph>Chair</emph>), Rezaur Rahman (Intel), Rich Rollman
	(Microsoft), Rick Gessner (Netscape), Rick Jelliffe (invited),
	Rob Relyea (Microsoft), Scott Isaacs (Microsoft), Sharon Adler
	(INSO), Steve Byrne (JavaSoft), Tim Bray (invited), Tim Yu
	(Oracle), Tom Pixley (Netscape/AOL), Vidur Apparao (Netscape),
	Vinod Anupam (Lucent).
      </p>
      
      <p>
	Thanks to all those who have helped to improve this
	specification by sending suggestions and corrections (Please,
	keep bugging us with your issues!).
      </p>
      <p>
	Many thanks to Andrew Clover, Petteri Stenius, Curt Arnold,
	Glenn A. Adams, Christopher Aillon, Scott Nichol,
	Fran&#231;ois Yergeau, Anjana Manian, Susan Lesch, and Jeffery
	B. Rancier for their review and comments of this document.
      </p>
      
      <p>
	Special thanks to the <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/DOM/Test" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">DOM
	Conformance Test Suites</loc> contributors: Fred Drake, Mary
	Brady (NIST), Rick Rivello (NIST), Robert Clary (Netscape), with
	a special mention to Curt Arnold.
      </p>
      
      <div2 id="Productions"><head>Production Systems</head> 
	<p>
	  This specification was written in XML. The HTML, OMG IDL, Java and
	  ECMAScript bindings were all produced automatically.
	</p>
	
	<p>
	  Thanks to Joe English, author of <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.flightlab.com/cost" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">cost</loc>, which was
	  used as the basis for producing DOM Level 1. Thanks also to
	  Gavin Nicol, who wrote the scripts which run on top of
	  cost. Arnaud Le Hors and Philippe Le H&#233;garet maintained
	  the scripts.
	</p>
	
	<p>
	  After DOM Level 1, we used <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://xml.apache.org/xerces-j" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Xerces</loc> as the
	  basis DOM implementation and wish to thank the
	  authors. Philippe Le H&#233;garet and Arnaud Le Hors wrote
	  the <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://dev.w3.org/cvsweb/java/classes/org/w3c/tools/specgenerator/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Java
	  programs</loc> which are the DOM application.
	</p>
	
	<p>
	  Thanks also to Jan K&#228;rrman, author of <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://user.it.uu.se/~jan/html2ps.html" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">html2ps</loc>,
	  which we use in creating the PostScript version of the
	  specification.
	</p>
      </div2>
    </div1>

  
<!-- $Id: glossary.xml,v 1.30 2004/02/04 22:06:58 plehegar Exp $ -->
<!--
 *************************************************************************
 * BEGINNING OF DOM GLOSSARY                                             *
 *************************************************************************
-->
<div1 role="glossary" id="glossary">
  <head>Glossary</head>
  <orglist role="editors">
    <member>
      <name>Arnaud Le Hors</name>
      <affiliation>W3C</affiliation>
    </member>
    <member>
      <name>Robert S. Sutor</name>
      <affiliation>IBM Research (for DOM Level 1)</affiliation>
    </member>
  </orglist>
  <p>Some of the following term definitions have been borrowed or
    modified from similar definitions in other W3C or standards documents.
    See the links within the definitions for more information.</p>
  <glist>
    <!-- ................................................................ -->
    <gitem>
      <label id="dt-16-bit-unit">16-bit unit</label>
      <def><p>The base unit of a <code>DOMString</code>. This indicates that
          indexing on a <code>DOMString</code> occurs in units of 16 bits. 
          This must not be misunderstood to mean that a <code>DOMString</code>
          can store arbitrary 16-bit units. A <code>DOMString</code> is a 
          character string encoded in UTF-16; this means that the restrictions
          of UTF-16 as well as the other relevant restrictions on character strings
          must be maintained. A single character, for example in the form of a 
          numeric character reference, may correspond to one or two 16-bit units.</p>
      </def>
    </gitem>
    <!-- ................................................................ -->
    <gitem>
      <label id="dt-ancestor">ancestor</label>
      <def><p>An <term>ancestor</term> node of any node A is any node
	  above A in a tree model, where "above" means "toward the root."
	</p></def>
    </gitem>
    <!-- ................................................................ -->
    <gitem>
      <label id="dt-API">API</label>
      <def><p>An <term>API</term> is an Application Programming
	  Interface, a set of functions or methods used to access some
	  functionality.</p></def>
    </gitem>
    <!-- ................................................................ -->
    <gitem>
      <label id="dt-anonymous">anonymous type name</label>
      <def>
	<p>
          An <term>anonymous type name</term> is an
          implementation-defined, globally unique qualified name
          provided by the processor for every anonymous type declared in
          a <termref def="dt-schema">schema</termref>.
	</p>
      </def>
    </gitem>
    <!-- ................................................................ -->
    <gitem>
      <label id="dt-bubbling-phase">bubbling phase</label>
      <def>
	<p>
	  The process by which an <termref def="dt-event">event</termref> can be handled by one of the
	  target ancestors after being handled by the <termref def="dt-target-node">target node</termref>.
	</p>
      </def>
    </gitem>
    <!-- ................................................................ -->
    <gitem>
      <label id="dt-capture-phase">capture phase</label>
      <def>
	<p>
	  The process by which an <termref def="dt-event">event</termref> can be handled by one of the
	  target ancestors before being handled by the <termref def="dt-target-node">target node</termref>.
	</p>
      </def>
    </gitem>
    <!-- ................................................................ -->
    <gitem>
      <label id="dt-child">child</label>
      <def><p>A <term>child</term> is an immediate descendant node of
	  a node.</p></def>
    </gitem>
    <!-- ................................................................ -->
    <gitem>
      <label id="dt-application">client application</label>
      <def><p>A [client] application is any software that uses the
	  Document Object Model programming interfaces provided by the
	  hosting implementation to accomplish useful work. Some
	  examples of client applications are scripts within an HTML
	  or XML document.</p></def>
    </gitem>
    <!-- ................................................................ -->
    <gitem>
      <label id="dt-COM">COM</label>
      <def><p><term>COM</term> is Microsoft's Component Object Model <bibref role="informative" ref="COM"/>, a technology for building applications from binary
	    software components.</p></def>
    </gitem>
    <!-- ................................................................ -->
    <gitem>
      <label id="dt-content-model">content model</label>
      <def><p>The <term>content model</term> is a simple grammar
	  governing the allowed types of the child elements and the
	  order in which they appear. See <xspecref xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/2004/REC-xml-20040204#sec-element-content" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">Element Content</xspecref>
	  in XML <bibref role="informative" ref="XML"/>.</p></def>
    </gitem>
    <!-- ................................................................ -->
    <gitem>
      <label id="dt-convenience">convenience</label>
      <def><p>A <term>convenience method</term> is an operation on an
          object that could be accomplished by a program consisting of
          more basic operations on the object. Convenience methods are
          usually provided to make the API easier and simpler to use or to
	  allow specific programs to create more optimized implementations
	  for common operations. A similar definition holds for a
	  <term>convenience property</term>.
        </p></def>
    </gitem>
    <!-- ................................................................ -->
    <gitem>
      <label id="dt-cooked">cooked model</label>
      <def><p>A model for a document that represents the document
	  after it has been manipulated in some way. For example, any
	  combination of any of the following transformations would
	  create a cooked model:
	  <olist>
	    <item><p>Expansion of internal text entities.</p></item>
	    <item><p>Expansion of external entities.</p></item>
	    <item><p>Model augmentation with style-specified generated
		text.</p></item>
	    <item><p>Execution of style-specified
		reordering.</p></item>
	    <item><p>Execution of scripts.</p></item>
	  </olist> A browser might only be able to provide access to a
	  cooked model, while an editor might provide access to a
	  cooked or the initial structure model (also known as the
	  <term>uncooked model</term>) for a document. </p></def>
    </gitem>
    <!-- ................................................................ -->
    <gitem>
      <label id="dt-CORBA">CORBA</label>
      <def><p><term>CORBA</term> is the <term>Common Object Request Broker
	    Architecture</term> from the <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.omg.org" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">OMG</loc> <bibref role="informative" ref="CORBA"/>. This architecture is a collection of objects and
	    libraries that allow the creation of applications containing
	    objects that make and receive requests and responses in a
	    distributed environment.</p></def>
    </gitem>
    <!-- ................................................................ -->
    <gitem>
      <label id="dt-cursor">cursor</label>
      <def><p>A <term>cursor</term>is an object representation of a
	  node. It may possess information about context and the path
	  traversed to reach the node.</p></def>
    </gitem>
    <!-- ................................................................ -->
    <gitem>
      <label id="dt-datamodel">data model</label>
      <def><p>A <term>data model</term> is a collection of descriptions of data
	  structures and their contained fields, together with the operations
	  or functions that manipulate them.</p></def>
    </gitem>
    <!-- ................................................................ -->
    <gitem>
      <label id="dt-deprecation">deprecation</label>
      <def><p>When new releases of specifications are released, some older
	  features may be marked as being <term>deprecated</term>. This
	  means that new work should not use the features and that
	  although they are supported in the current release, they may
	  not be supported or available in future releases.</p></def>
    </gitem>
    <!-- ................................................................ -->
    <gitem>
      <label id="dt-descendant">descendant</label>
      <def><p>A <term>descendant</term> node of any node A is any node
	  below A in a tree model, where "below" means "away from the
	  root."</p></def>
    </gitem>

    <!-- ................................................................ -->
    <gitem>
      <label id="dt-document-element">document element</label>
      <def>
	<p>
	  There is only one document element in a <code>Document</code>. This
	  element node is a child of the <code>Document</code> node. See
	  <xspecref xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/2004/REC-xml-20040204#dt-root" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">Well-Formed XML
	  Documents</xspecref> in XML <bibref role="informative" ref="XML"/>.
	</p>
      </def>
    </gitem>
    <!-- ................................................................ -->
    <gitem>
      <label id="dt-document-order">document order</label>

      <def><p>There is an ordering, <term>document order</term>, defined on all
      the nodes in the document corresponding to the order in which the first
      character of the XML representation of each node occurs in the XML
      representation of the document after expansion of general entities. Thus,
      the <termref def="dt-document-element">document element</termref> node
      will be the first node. Element nodes occur before their children. Thus,
      document order orders element nodes in order of the occurrence of their
      start-tag in the XML (after expansion of entities). The attribute nodes
      of an element occur after the element and before its children. The
      relative order of attribute nodes is implementation-dependent.</p></def>
    </gitem>
    <!-- ................................................................ -->
    <gitem>
      <label id="dt-DOM-Level-0">DOM Level 0</label>
      <def><p>The term "DOM Level 0" refers to a mix (not formally specified)
	  of HTML document functionalities offered by Netscape Navigator
	  version 3.0 and Microsoft Internet Explorer version 3.0. In some
	  cases, attributes or methods have been included for reasons of
	  backward compatibility with "DOM Level 0".</p></def>
    </gitem>
    <!-- ................................................................ -->
    <gitem>
      <label id="dt-ECMAScript">ECMAScript</label>
      <def><p>The programming language defined by the ECMA-262 standard
	  <bibref role="informative" ref="ECMAScript"/>. As stated in the standard, the
            originating technology for ECMAScript was JavaScript <bibref role="informative" ref="JavaScript"/>. Note that in the ECMAScript binding, the word
              "property" is used in the same sense as the IDL term
              "attribute."</p></def>
    </gitem>
    <!-- ................................................................ -->
    <gitem>
      <label id="dt-element">element</label>
      <def><p>Each document contains one or more elements, the
	  boundaries of which are either delimited by start-tags and
	  end-tags, or, for empty elements by an empty-element tag.
	  Each element has a type, identified by name, and may have a
	  set of attributes. Each attribute has a name and a value.
	  See <xspecref xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/2004/REC-xml-20040204#sec-logical-struct" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">Logical
	    Structures</xspecref> in XML <bibref role="informative" ref="XML"/>.
	</p></def>
    </gitem>
    <gitem>
      <label id="dt-event">event</label>
      <def>
	<p>
	  An event is the representation of some asynchronous occurrence
	  (such as a mouse click on the presentation of the element, or
	  the removal of child node from an element, or any of
	  unthinkably many other possibilities) that gets associated
	  with an <termref def="dt-event-target">event target</termref>.
	</p>
      </def>
    </gitem>
    <!-- ................................................................ -->
    <gitem>
      <label id="dt-event-target">event target</label>
      <def>
	<p>
	  The object to which an <termref def="dt-event">event</termref>
	  is targeted.
	</p>
      </def>
    </gitem>
    <!-- ................................................................ -->
    <gitem>
      <label id="dt-equivalence">equivalence</label>
      <def>
	<p>Two nodes are <term>equivalent</term> if they have the same node
	  type and same node name. Also, if the nodes contain data, that must
	  be the same. Finally, if the nodes have attributes then collection
	  of attribute names must be the same and the attributes corresponding
	  by name must be equivalent as nodes.</p>

        <p>Two nodes are <term>deeply equivalent</term> if they are
	  <term>equivalent</term>, the child node lists are equivalent are
	  equivalent as <code>NodeList</code> objects, and the pairs of
	  equivalent attributes must in fact be deeply equivalent.</p>


        <p>Two <code>NodeList</code> objects are <term>equivalent</term> if they
	  have the same length,	and the nodes corresponding by index
	  are deeply equivalent. </p>

        <p>Two <code>NamedNodeMap</code> objects are <term>equivalent</term> if
	  they have the same length, they have same collection of names,
	  and the nodes corresponding by name in the maps are deeply
	  equivalent. </p>

        <p>Two <code>DocumentType</code> nodes are <term>equivalent</term> if
	  they are equivalent as nodes, have the same names, and have
	  equivalent entities and attributes <code>NamedNodeMap</code>
	  objects.</p>

      </def>
    </gitem>
    <!-- ................................................................ -->
    <gitem>
      <label id="dt-infoitem">information item</label>
      <def><p>An information item is an abstract representation of some
          component of an XML document. See the <bibref role="informative" ref="InfoSet"/>
            for details.
        </p></def>
    </gitem>
    <!-- ................................................................ -->
    <gitem>
      <label id="dt-logically-adjacent-text-nodes">logically-adjacent text nodes</label>
      <def><p>
        <term>Logically-adjacent text nodes</term> are <code>Text</code>
        or <code>CDATASection</code> nodes that can be visited
        sequentially in <termref def="dt-document-order">document
        order</termref> or in reversed document order without entering,
        exiting, or passing over <code>Element</code>,
        <code>Comment</code>, or <code>ProcessingInstruction</code>
        nodes.
	</p>
      </def>
    </gitem>
    <!-- ................................................................ -->
    <gitem>
      <label id="dt-global-declaration">global declaration</label>
      <def>
	<p>
	  A <term>global declaration</term> is a schema declaration,
	  usually for an element or an attribute, that is available for
	  use in content models throughout the <termref def="dt-schema">schema</termref>, i.e. a declaration that is
	  not bound to a particular context.
	</p>
      </def>
    </gitem>   
    <!-- ................................................................ -->
    <gitem>
      <label id="dt-implementation">hosting implementation</label>
      <def><p>A [hosting] implementation is a software module that
	  provides an implementation of the DOM interfaces so that a
	  client application can use them. Some examples of hosting
	  implementations are browsers, editors and document
	  repositories.</p></def>
    </gitem>
    <!-- ................................................................ -->
    <gitem>
      <label id="dt-HTML">HTML</label>
      <def><p>The HyperText Markup Language (<term>HTML</term>) is a
	  simple markup language used to create hypertext documents
	  that are portable from one platform to another. HTML
	  documents are SGML documents with generic semantics that are
	  appropriate for representing information from a wide range
	  of applications. <bibref role="informative" ref="HTML40"/></p></def>
    </gitem>
    <!-- ................................................................ -->
    <gitem>
      <label id="dt-IDL">IDL</label>
      <def><p>An Interface Definition Language (<term>IDL</term>) is used to
	  define the interfaces for accessing and operating upon
	  objects. Examples of IDLs are the Object Management Group's IDL
	  <bibref role="informative" ref="CORBA"/>, Microsoft's IDL <bibref role="informative" ref="MSIDL"/>, and
	      Sun's Java IDL <bibref role="informative" ref="JavaIDL"/>.</p></def>
    </gitem>
    <!-- ................................................................ -->
    <gitem>
      <label id="dt-implementor">implementor</label>
      <def><p>Companies, organizations, and individuals that claim to
	  support the Document Object Model as an API for their
	  products.</p></def>
    </gitem>
    <!-- ................................................................ -->
    <gitem>
      <label id="dt-inheritance">inheritance</label>
      <def><p>In object-oriented programming, the ability to create new
	  classes (or interfaces) that contain all the methods and properties
	  of another class (or interface), plus additional methods and
	  properties. If class (or interface) D inherits from class (or
	  interface) B, then D is said to be <term>derived</term> from B. B is
	  said to be a <term>base</term> class (or interface) for D. Some
	  programming languages allow for multiple inheritance, that is,
	  inheritance from more than one class or interface.</p></def>
    </gitem>
    <!-- ................................................................ -->
    <gitem>
      <label id="dt-raw-struct">initial structure model</label>
      <def><p>Also known as the <term>raw structure model</term> or
	  the <term>uncooked model</term>, this represents the
	  document before it has been modified by entity expansions,
	  generated text, style-specified reordering, or the execution
	  of scripts. In some implementations, this might correspond
	  to the "initial parse tree" for the document, if
	  it ever exists. Note that a given implementation might not
	  be able to provide access to the initial structure model for
	  a document, though an editor probably would.</p></def>
    </gitem>
    <!-- ................................................................ -->
    <gitem>
      <label id="dt-interface">interface</label>
      <def><p>An <term>interface</term> is a declaration of a set of
          methods with no information given about their implementation.
	  In object systems that support interfaces and inheritance,
	  interfaces can usually inherit from one another.
        </p></def>
    </gitem>
    <!-- ................................................................ -->
    <gitem>
      <label id="dt-lang-binding">language binding</label>
      <def><p>A programming <term>language binding</term> for an IDL
	  specification is an implementation of the interfaces in the
	  specification for the given language. For example, a Java
	  language binding for the Document Object Model IDL
	  specification would implement the concrete Java classes that
	  provide the functionality exposed by the
	  interfaces.</p></def>
    </gitem>
    <!-- ................................................................ -->
    <gitem>
      <label id="dt-live">live</label>
      <def>
          <p>An object is <term>live</term> if any change to the underlying
          document structure is reflected in the object.</p></def>      
    </gitem>
    <!-- ................................................................ -->
    <gitem>
      <label id="dt-localname">local name</label>
      <def><p>A <term>local name</term> is the local part of a <term>qualified
	    name</term>.
	  This is called the <xtermref xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/1999/REC-xml-names-19990114/#dt-localname" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">local
	    part</xtermref> in Namespaces in XML <bibref role="informative" ref="Namespaces"/>.</p></def>
    </gitem>
    <!-- ................................................................ -->
    <gitem>
      <label id="dt-method">method</label>
      <def><p>A <term>method</term> is an operation or function that is
	  associated with an object and is allowed to manipulate the
	  object's data.
        </p></def>
    </gitem>
    <!-- ................................................................ -->
    <gitem>
      <label id="dt-model">model</label>
      <def><p>A <term>model</term> is the actual data representation
	  for the information at hand. Examples are the structural
	  model and the style model representing the parse structure
	  and the style information associated with a document. The
	  model might be a tree, or a directed graph, or something
	  else.</p></def>
    </gitem>
    <!-- ................................................................ -->
    <gitem>
      <label id="dt-namespaceprefix">namespace prefix</label>
      <def><p>A <term>namespace prefix</term> is a string that associates
	  an element or attribute name with a <term>namespace URI</term> in
	  XML. See <xtermref xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/1999/REC-xml-names-19990114/#dt-prefix" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">namespace
	    prefix</xtermref> in Namespaces in XML <bibref role="informative" ref="Namespaces"/>.</p></def>
    </gitem>
    <!-- ................................................................ -->
    <gitem>
      <label id="dt-namespaceURI">namespace URI</label>
      <def>
	<p>
	  A <term>namespace URI</term> is a URI that identifies an XML
	  namespace. This is called the <xtermref xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/1999/REC-xml-names-19990114/#dt-NSName" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">namespace name</xtermref> in
	  Namespaces in XML <bibref role="informative" ref="Namespaces"/>. See also sections 1.3.2 "<xspecref xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/DOM-Level-3-Core/core.html#baseURIs-Considerations" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">DOM
	  URIs</xspecref>" and 1.3.3 "<xspecref xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/DOM-Level-3-Core/core.html#Namespaces-Considerations" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">XML
	  Namespaces</xspecref>" regarding URIs and namespace URIs
	  handling and comparison in the DOM APIs.
	</p>
      </def>
    </gitem>
    <!-- ................................................................ -->
    <gitem>
      <label id="dt-namespace-well-formed">namespace well-formed</label>
      <def>
	<p>
	  A node is a <term>namespace well-formed</term> XML node if it
	  is a <termref def="dt-well-formed">well-formed</termref> node,
	  and follows the productions and namespace constraints. If
	  <bibref ref="XML"/> is used, the constraints are defined in
	  <bibref ref="Namespaces"/>. If <bibref ref="XML11"/> is used,
	  the constraints are defined in <bibref ref="Namespaces11"/>.
	</p>
      </def>
    </gitem>
    <!-- ................................................................ -->
    <gitem>
      <label id="dt-object-model">object model</label>
      <def><p>An <term>object model</term>
	  is a collection of
	  descriptions of classes or interfaces,
	  together with their member data, member functions,
	  and class-static operations.
	</p></def>
    </gitem>
    <!-- ................................................................ -->
    <gitem>
      <label id="dt-parent">parent</label>
      <def><p>A <term>parent</term> is an immediate ancestor node of a
	  node.</p></def>
    </gitem>
    <gitem>
      <label id="dt-partially-valid">partially valid</label>
      <def>
	<p>A node in a DOM tree is <term>partially valid</term> if it is
	<termref def="dt-well-formed">well formed</termref> (this part is for
	comments and processing instructions) and its immediate children are
	those expected by the content model. The node may be missing trailing
	required children yet still be considered <term>partially
	valid</term>.
	</p>
      </def>
    </gitem>
    <!-- ................................................................ -->
    <gitem>
      <label id="dt-qualifiedname">qualified name</label>
      <def>
	<p>A <term>qualified name</term> is the name of an element or
	  attribute defined as the concatenation of a <term>local name</term>
	  (as defined in this specification), optionally preceded by a
	  <term>namespace prefix</term> and colon character. See <xspecref xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/1999/REC-xml-names-19990114/#ns-qualnames" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">Qualified Names</xspecref> in
	  Namespaces in XML <bibref role="informative" ref="Namespaces"/>.</p></def>
    </gitem>
    <!-- ................................................................ -->
    <gitem> 
      <label id="dt-readonly-node">read only node</label>
      <def><p>A <term>read only node</term> is a node that is immutable. This
          means its list of children, its content, and its attributes, when it
          is an element, cannot be changed in any way. However, a read only node
          can possibly be moved, when it is not itself contained in a read only
          node.</p></def>
    </gitem>
    <!-- ................................................................ -->
    <gitem>
      <label id="dt-root-node">root node</label>
      <def>
	<p>The <term>root node</term> is a node that is not a child of any
	other node. All other nodes are children or other descendants of the
	root node.</p></def>
    </gitem>
    <!-- ................................................................ -->
    <gitem>
      <label id="dt-schema">schema</label>
      <def>
	<p>
	  A <term>schema</term> defines a set of structural and value
	  constraints applicable to XML documents. Schemas can be
	  expressed in schema languages, such as DTD, XML Schema, etc.
	</p>
      </def>
    </gitem>
    <!-- ................................................................ -->
    <gitem>
      <label id="dt-sibling">sibling</label>
      <def><p>Two nodes are <term>siblings</term> if they have the
	  same parent node.</p></def>
    </gitem>
    <!-- ................................................................ -->
    <gitem>
      <label id="dt-string-compare">string comparison</label>
      <def><p>When string matching is required, it is to occur as
	  though the comparison was between 2 sequences of code points
	  from <bibref role="informative" ref="Unicode"/>.</p>
      </def>
    </gitem>
    <!-- ................................................................ -->
    <gitem>
      <label id="dt-tag-valid">tag valid document</label>
      <def><p>A document is <term>tag valid</term> if all begin and
	  end tags are properly balanced and nested.</p></def>
    </gitem>
    <!-- ................................................................ -->
    <gitem>
      <label id="dt-target-node">target node</label>
      <def>
	<p>
	  The target node is the node representing the <termref def="dt-event-target">event target</termref> to which an <termref def="dt-event">event</termref> is targeted using the DOM event
	  flow.
	</p>
      </def>
    </gitem>
    <!-- ................................................................ -->
    <gitem>
      <label id="dt-target-phase">target phase</label>
      <def>
	<p>
	  The process by which an <termref def="dt-event">event</termref> can be handled by the <termref def="dt-event-target">event target</termref>.
	</p>
      </def>
    </gitem>
    <!-- ................................................................ -->
    <gitem><label id="dt-token">token</label><def>
        <p>An information item such as an
          <xtermref xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/REC-xml.html#NT-Name" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">XML Name</xtermref> which has been
          <termref def="dt-tokenized">tokenized</termref>.</p></def>
    </gitem>
    <!-- ................................................................ -->
    <gitem><label id="dt-tokenized">tokenized</label><def>
        <p>The description given to various information items (for example,
          attribute values of various types, but not including the StringType
          CDATA) after having been processed by the XML processor. The process
          includes stripping leading and trailing white space, and replacing
          multiple space characters by one. See the definition of
          <xtermref xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/REC-xml.html#NT-TokenizedType" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">tokenized type</xtermref>.</p></def>
    </gitem>
    <!-- ................................................................ -->
    <gitem>
      <label id="dt-type-valid">type valid document</label>
      <def><p>A document is <term>type valid</term> if it conforms to
	  an explicit DTD.</p></def>
    </gitem>
    <!-- ................................................................ -->
    <gitem>
      <label id="dt-uncooked">uncooked model</label>
      <def><p>See initial structure model.</p></def>
    </gitem>
    <!-- ................................................................ -->
    <gitem>
      <label id="dt-well-formed">well-formed</label>
      <def>
	<p>
	  A node is a <term>well-formed</term> XML node if its
	  serialized form, without doing any transformation during its
	  serialization, matches its respective production in <bibref ref="XML"/> or <bibref ref="XML11"/> (depending on the XML
	  version in use) with all well-formedness constraints related
	  to that production, and if the entities which are referenced
	  within the node are also well-formed. If namespaces for XML
	  are in use, the node must also be <termref def="dt-namespace-well-formed">namespace
	  well-formed</termref>.
	</p>
      </def>
    </gitem>
    <!-- ................................................................ -->
    <gitem>
      <label id="dt-XML">XML</label>
      <def><p>Extensible Markup Language (<term>XML</term>) is an
	  extremely simple dialect of SGML which is completely
	  described in this document. The goal is to enable generic
	  SGML to be served, received, and processed on the Web in the
	  way that is now possible with HTML. XML has been designed
	  for ease of implementation and for interoperability with
	  both SGML and HTML. <bibref role="informative" ref="XML"/></p></def>
    </gitem>
    <!-- ................................................................ -->
    <gitem>
      <label id="dt-XML-name">XML name</label>
      <def><p>See <xspecref xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/2004/REC-xml-20040204#NT-Name" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">XML name</xspecref> in
	  the XML specification (<bibref role="informative" ref="XML"/>).
        </p></def>
    </gitem>
    <!--
    ................................................................ -->
    <gitem>
      <label id="dt-XML-namespace">XML namespace</label>
      <def><p>An <term>XML namespace</term> is a collection of names,
	  identified by a URI reference <bibref role="informative" ref="URIRef"/>, which are used
	    in XML documents as element types and attribute names. <bibref role="informative" ref="Namespaces"/></p></def>
    </gitem>
    <!-- ................................................................ -->
  </glist>
</div1>
<!--
 *************************************************************************
 * END OF DOM GLOSSARY                                                   *
 *************************************************************************
-->
 
  
<!-- $Id: references.xml,v 1.77 2004/04/05 19:03:43 plehegar Exp $ -->
<!--
 *************************************************************************
 * BEGINNING OF REFERENCES                                               *
 *************************************************************************
-->
<div1 role="references" id="References">
  <head>References</head>
  <p>
    For the latest version of any W3C specification please consult the list of
    <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">W3C Technical Reports</loc> available at
    http://www.w3.org/TR.
  </p>
  
    <blist>      
      <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="c14n" href="http://www.w3.org/TR/2001/REC-xml-c14n-20010315" key="Canonical XML" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
	<titleref xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">Canonical XML Version 1.0</titleref>, J. Boyer,
	Editor. World Wide Web Consortium, 15 March 2001. This version
	of the Canonical XML Recommendation is
	http://www.w3.org/TR/2001/REC-xml-c14n-20010315. The <loc href="http://www.w3.org/TR/xml-c14n" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">latest version of Canonical
	XML</loc> is available at http://www.w3.org/TR/xml-c14n.
      </bibl>
      <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="Charmod" key="CharModel" href="http://www.w3.org/TR/2004/WD-charmod-norm-20040225" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
	<titleref xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">Character Model for the World Wide Web 1.0:
	Normalization</titleref>, M. D&#252;rst, F. Yergeau, R. Ishida,
	M. Wolf, T. Texin, and A. Phillips, Editors. World Wide Web
	Consortium, February 2004. This version of the Character Model
	for the World Wide Web 1.0: Normalization specification is
	http://www.w3.org/TR/2004/WD-charmod-norm-20040225. The <loc href="http://www.w3.org/TR/charmod-norm" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">latest version of
	Character Model for the World Wide Web 1.0: Normalization</loc>
	is available at http://www.w3.org/TR/charmod-norm.
      </bibl>
      <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="COM" key="COM" href="http://www.microsoft.com/com/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
        <titleref xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">The Microsoft Component Object Model</titleref>,
        Microsoft Corporation. Available at http://www.microsoft.com/com.
      </bibl>
      <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="CORBA" key="CORBA" href="http://www.omg.org/technology/documents/formal/corba_2.htm" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
	<titleref xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">The Common Object Request Broker: Architecture and
	Specification, version 2</titleref>. Object Management
	Group. The latest version of CORBA version  2.0 is available at
        http://www.omg.org/technology/documents/formal/corba_2.htm.
      </bibl>
      <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="CSS2" key="CSS2" href="http://www.w3.org/TR/1998/REC-CSS2-19980512" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
	<titleref xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">Cascading Style Sheets, level 2
	Specification</titleref>, B. Bos, H. Wium Lie, C.
	Lilley, and I. Jacobs, Editors. World Wide Web Consortium, 12
	May 1998. This version of the Cascading Style Sheets
	Recommendation is http://www.w3.org/TR/1998/REC-CSS2-19980512. The <loc href="http://www.w3.org/TR/REC-CSS2" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">latest version of Cascading
	Style Sheets</loc> is available at
	http://www.w3.org/TR/REC-CSS2.
    </bibl>
      <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="DOM-Level-1" key="DOM Level 1" href="http://www.w3.org/TR/1998/REC-DOM-Level-1-19981001/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
	<titleref xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">DOM Level 1 Specification</titleref>, V. Apparao,
	et al., Editors. World Wide Web Consortium, 1 October 1998. This
	version of the DOM Level 1 Recommendation is http://www.w3.org/TR/1998/REC-DOM-Level-1-19981001. The
	<loc href="http://www.w3.org/TR/REC-DOM-Level-1/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">latest version
	of DOM Level 1</loc> is available at
	http://www.w3.org/TR/REC-DOM-Level-1.
      </bibl>
      <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="DOM2Core" key="DOM Level 2 Core" href="http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
	<titleref xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">Document Object Model Level 2 Core
	Specification</titleref>, A. Le Hors, et al., Editors. World
	Wide Web Consortium, 13 November 2000. This version of the DOM
	Level 2 Core Recommendation is http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113. The <loc href="http://www.w3.org/TR/DOM-Level-2-Core" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">latest version of
	DOM Level 2 Core</loc> is available at
	http://www.w3.org/TR/DOM-Level-2-Core.
      </bibl>
      <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="DOMCore" key="DOM Level 3 Core" href="http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
        <titleref xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">Document Object Model Level 3 Core
        Specification</titleref>, A. Le Hors, et al., Editors. World
        Wide Web Consortium, 7 April 2004. This version of the Document
        Object Model Level 3 Core Recommendation is
        http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407. The <loc href="http://www.w3.org/TR/DOM-Level-3-Core" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">latest version of
        DOM Level 3 Core</loc> is available at
        http://www.w3.org/TR/DOM-Level-3-Core.
      </bibl>
      <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="DOM2Events" key="DOM Level 2 Events" href="http://www.w3.org/TR/2000/REC-DOM-Level-2-Events-20001113" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
 	<titleref xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">Document Object Model Level 2 Events
 	Specification</titleref>, T. Pixley, Editor. World Wide Web
 	Consortium, 13 November 2000. This version of the Document
 	Object Model Level 2 Events Recommendation is http://www.w3.org/TR/2000/REC-DOM-Level-2-Events-20001113.  The
 	<loc href="http://www.w3.org/TR/DOM-Level-2-Events" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">latest
 	version of Document Object Model Level 2 Events</loc> is
 	available at http://www.w3.org/TR/DOM-Level-2-Events.
      </bibl>
      <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="DOMEvents" key="DOM Level 3 Events" href="http://www.w3.org/TR/2003/NOTE-DOM-Level-3-Events-20031107" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
	<titleref xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">Document Object Model Level 3 Events
	Specification</titleref>, P. Le H&#233;garet, T. Pixley,
	Editors.  World Wide Web Consortium, November 2003. This version of
	the Document Object Model Level 3 Events specification is
	http://www.w3.org/TR/2003/NOTE-DOM-Level-3-Events-20031107.  The <loc href="http://www.w3.org/TR/DOM-Level-3-Events" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">latest version of
	Document Object Model Level 3 Events</loc> is available at
	http://www.w3.org/TR/DOM-Level-3-Events.
      </bibl>
      <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="DOMLS" key="DOM Level 3 Load and Save" href="http://www.w3.org/TR/2004/REC-DOM-Level-3-LS-20040407" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
        <titleref xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">Document Object Model Level 3 Load and Save
        Specification</titleref>, J. Stenback, A. Heninger,
        Editors. World Wide Web Consortium, 7 April 2004.  This version
        of the DOM Level 3 Load and Save Recommendation is http://www.w3.org/TR/2004/REC-DOM-Level-3-LS-20040407. The
        <loc href="http://www.w3.org/TR/DOM-Level-3-LS" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">latest version of DOM Level 3 Load
        and Save</loc> is available at http://www.w3.org/TR/DOM-Level-3-LS.
      </bibl>
      <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="DOM2HTML" key="DOM Level 2 HTML" href="http://www.w3.org/TR/2003/REC-DOM-Level-2-HTML-20030109" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
        <titleref xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">Document Object Model Level 2 HTML
        Specification</titleref>, J. Stenback, et al., Editors. World
        Wide Web Consortium, 9 January 2003. This version of the Document
        Object Model Level 2 HTML Recommendation is http://www.w3.org/TR/2003/REC-DOM-Level-2-HTML-20030109.  The <loc href="http://www.w3.org/TR/DOM-Level-2-HTML" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">latest version of
        Document Object Model Level 2 HTML</loc> is available at
        http://www.w3.org/TR/DOM-Level-2-HTML.
      </bibl>
      <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="DOM-Level-3-Requirements" key="DOM Level 3 Requirements" href="http://www.w3.org/TR/2004/NOTE-DOM-Requirements-20040226#Level3" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">    
       <quote>DOM Requirements for DOM Level 3</quote> in <titleref xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">DOM
       Requirements for DOM Level 3</titleref>, B. Chang, et al.,
       Editors.  World Wide Web Consortium, February 2004. This version of
       the DOM Requirements for DOM Level 3 is
       http://www.w3.org/TR/2004/NOTE-DOM-Requirements-20040226#Level3.
       The <loc href="http://www.w3.org/TR/DOM-Requirements" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">latest
       version of DOM Requirements</loc> is available at
       http://www.w3.org/TR/DOM-Requirements.
      </bibl>
      <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="DOM2Style" key="DOM Level 2 Style Sheets and CSS" href="http://www.w3.org/TR/2000/REC-DOM-Level-2-Style-20001113" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
       <titleref xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">Document Object Model Level 2 Style Sheets and CSS
       Specification</titleref>, C. Wilson, P. Le H&#233;garet,
       V. Apparao, Editors.  World Wide Web Consortium, 13 November
       2000. This version of the Document Object Model Level 2 Style
       Sheets and CSS Recommendation is http://www.w3.org/TR/2000/REC-DOM-Level-2-Style-20001113.  The <loc href="http://www.w3.org/TR/DOM-Level-2-Style" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">latest version of
       Document Object Model Level 2 Style Sheets and CSS</loc> is
       available at http://www.w3.org/TR/DOM-Level-2-Style.
      </bibl>
      <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="DOM2Traversal-Range" key="DOM Level 2 Traversal and      Range" href="http://www.w3.org/TR/2000/REC-DOM-Level-2-Traversal-Range-20001113" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
	<titleref xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">Document Object Model Level 2 Traversal and Range
	Specification</titleref>, J. Kesselman, J. Robie, M.
	Champion, P. Sharpe, V. Apparao, L. Wood,
	Editors. World Wide Web Consortium, 13 November 2000. This
	version of the Document Object Model Level 2 Traversal and Range
	Recommendation is http://www.w3.org/TR/2000/REC-DOM-Level-2-Traversal-Range-20001113.  The <loc href="http://www.w3.org/TR/DOM-Level-2-Traversal-Range" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">latest
	version of Document Object Model Level 2 Traversal and
	Range</loc> is available at
	http://www.w3.org/TR/DOM-Level-2-Traversal-Range.
      </bibl>
      <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="DOMVal" key="DOM Level 3 Validation" href="http://www.w3.org/TR/2004/REC-DOM-Level-3-Val-20040127/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
        <titleref xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">Document Object Model Level 3 Validation
        Specification</titleref>, B. Chang, J. Kesselman, R. Rahman,
        Editors. World Wide Web Consortium, 27 January 2003.  This version of
        the DOM Level 3 Validation Recommendation is
        http://www.w3.org/TR/2004/REC-DOM-Level-3-Val-20040127/. The <loc href="http://www.w3.org/TR/DOM-Level-3-Val" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">latest version of
        DOM Level 3 Validation</loc> is available at
        http://www.w3.org/TR/DOM-Level-3-Val.
      </bibl>
      <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="DOM2Views" key="DOM Level 2 Views" href="http://www.w3.org/TR/2000/REC-DOM-Level-2-Views-20001113" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
	<titleref xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">Document Object Model Level 2 Views
	Specification</titleref>, A. Le Hors, L. Cable, Editors.  World Wide Web
	Consortium, 13 November 2000. This version of the Document Object
	Model Level 2 Views Recommendation is http://www.w3.org/TR/2000/REC-DOM-Level-2-Views-20001113.  The <loc href="http://www.w3.org/TR/DOM-Level-2-Views" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">latest version of Document Object Model Level 2
	Views</loc> is available at http://www.w3.org/TR/DOM-Level-2-Views.
      </bibl>
      <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="DOMXPath" key="DOM Level 3 XPath" href="http://www.w3.org/TR/2004/NOTE-DOM-Level-3-XPath-20040226/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
	<titleref xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">Document Object Model Level 3 XPath
	Specification</titleref>, R. Whitmer, Editor. World Wide Web
	Consortium, March 2003. This version of the Document Object
	Model Level 3 XPath specification is http://www.w3.org/TR/2004/NOTE-DOM-Level-3-XPath-20040226.  The
	<loc href="http://www.w3.org/TR/DOM-Level-3-XPath" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">latest
	version of Document Object Model Level 3 XPath</loc> is
	available at http://www.w3.org/TR/DOM-Level-3-XPath.
      </bibl>
      <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="DWW95" key="DWW95" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
	<titleref xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">Developing International Software for Windows 95 and
	Windows NT: A Handbook for International Software
	Design</titleref>, N. Kano, Author. Microsoft Press, 1995. ISBN
	1-55615-840-8.
      </bibl>
      <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="ECMAScript" key="ECMAScript" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
	<titleref xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">ECMAScript Language Specification</titleref>, Third
	Edition. European Computer Manufacturers Association, Standard
	ECMA-262, December 1999. This version of the ECMAScript
	Language is available from http://www.ecma-international.org/.
      </bibl>
      <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="HTML40" key="HTML 4.01" href="http://www.w3.org/TR/1999/REC-html401-19991224/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
        <titleref xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">HTML 4.01 Specification</titleref>, D. Raggett, A. Le
        Hors, and I. Jacobs, Editors. World Wide Web Consortium, 17
        December 1997, revised 24 April 1998, revised 24 December
        1999. This version of the HTML 4.01 Recommendation is
        http://www.w3.org/TR/1999/REC-html401-19991224. The <loc href="http://www.w3.org/TR/html4" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">latest version of HTML 4</loc> is
        available at http://www.w3.org/TR/html4.
      </bibl>      
      <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="IANA-CHARSETS" key="IANA-CHARSETS" href="ftp://ftp.isi.edu/in-notes/iana/assignments/character-sets" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
        <titleref xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">Official Names for Character Sets</titleref>,
        K. Simonsen, et al., Editors. Internet Assigned Numbers
        Authority. Available at
        ftp://ftp.isi.edu/in-notes/iana/assignments/character-sets.
      </bibl>
      <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="ISO10646" key="ISO/IEC 10646" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
        <titleref xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">ISO/IEC 10646-2000 (E). Information technology -
        Universal Multiple-Octet Coded Character Set (UCS) - Part 1:
        Architecture and Basic Multilingual Plane</titleref>, as, from
        time to time, amended, replaced by a new edition or expanded by
        the addition of new parts. [Geneva]: International Organization
        for Standardization, 2000. See also <loc href="http://www.iso.ch" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">International Organization for
        Standardization</loc>, available at http://www.iso.ch, for the
        latest version.
      </bibl>
      <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="Java" key="Java" href="http://java.sun.com/docs/books/jls" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
	<titleref xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">The Java Language Specification</titleref>, J.
	Gosling, B. Joy, and G. Steele, Authors. Addison-Wesley,
	September 1996. Available at http://java.sun.com/docs/books/jls
      </bibl>
      <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="JavaIDL" key="Java IDL" href="http://java.sun.com/products/jdk/idl/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
	<titleref xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">Java IDL</titleref>. Sun Microsystems. Available at http://java.sun.com/products/jdk/idl/
      </bibl>      
      <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="JavaScript" key="JavaScript" href="http://devedge.netscape.com/central/javascript/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
	<titleref xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">JavaScript Resources</titleref>. Netscape
	Communications Corporation. Available at http://devedge.netscape.com/central/javascript/
      </bibl>
      <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="JAXP" key="JAXP" href="http://java.sun.com/xml/jaxp/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
	<titleref xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">Java API for XML Processing (JAXP)</titleref>. Sun
	Microsystems. Available at
	http://java.sun.com/xml/jaxp/.
	</bibl>
      <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="JScript" key="JScript" href="http://msdn.microsoft.com/library/en-us/script56/html/js56jslrfjscriptlanguagereference.asp" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
	<titleref xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">JScript Resources</titleref>. Microsoft. Available at
	http://msdn.microsoft.com/library/en-us/script56/html/js56jslrfjscriptlanguagereference.asp
      </bibl>    
      <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="KeyEvent" key="KeyEvent for Java" href="http://java.sun.com/j2se/1.4.2/docs/api/java/awt/event/KeyEvent.html" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
	<titleref xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">Java 2 Platform, Standard Edition, v. 1.4.2 API
	Specification, Class java.awt.events.KeyEvent</titleref>. Sun
	Microsystems. Available at
	http://java.sun.com/j2se/1.4.2/docs/api/java/awt/event/KeyEvent.html.
      </bibl>
      <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="Keys" key="Keys enumeration for .Net" href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/cpref/html/frlrfSystemWindowsFormsKeysClassTopic.asp" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
	<titleref xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">.NET Framework Class Library, Keys
	Enumeration</titleref>. Microsoft. Available at
	http://msdn.microsoft.com/library/default.asp?url=/library/en-us/cpref/html/frlrfSystemWindowsFormsKeysClassTopic.asp.
      </bibl>
      <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="MathML2" key="MathML 2.0" href="http://www.w3.org/TR/2003/REC-MathML2-20031021" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
	<titleref xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">Mathematical Markup Language (MathML) Version 2.0
	(Second Edition)</titleref>, D. Carlisle, P. Ion, R. Miner,
	N. Poppelier, Editors. World Wide Web Consortium, 21 October
	2001, revised 21 February 2001. This version of the Math 2.0
	Recommendation is http://www.w3.org/TR/2003/REC-MathML2-20031021. The <loc href="http://www.w3.org/TR/MathML2" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">latest version of MathML
	2.0</loc> is available at http://www.w3.org/TR/MathML2.
      </bibl>
      <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="MSIDL" key="MIDL" href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/midl/midl/midl_language_reference.asp" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
        <titleref xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">MIDL Language
        Reference</titleref>. Microsoft. Available at http://msdn.microsoft.com/library/default.asp?url=/library/en-us/midl/midl/midl_language_reference.asp.
      </bibl>
      <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="OMGIDL" key="OMG IDL" href="http://www.omg.org/technology/documents/formal/corba_2.htm" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
        <quote>OMG IDL Syntax and Semantics</quote> defined in
        <titleref xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">The Common Object Request Broker: Architecture and
        Specification, version 2</titleref>, Object Management
        Group. The latest version of CORBA version 2.0 is available at
        http://www.omg.org/technology/documents/formal/corba_2.htm.
      </bibl>
      <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="IRIRef" key="IETF IRIs" href="http://www.w3.org/International/iri-edit/draft-duerst-iri-03.txt" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
	<titleref xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">Internationalized Resource Identifiers
	(IRIs)</titleref>, M. D&#252;rst, and M. Suignard, Authors. Internet
	Engineering Task Force, March 2003. Available at
	http://www.w3.org/International/iri-edit/draft-duerst-iri-03.txt.
      </bibl>
      <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="URIRef" key="IETF RFC 2396" href="http://www.ietf.org/rfc/rfc2396.txt" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
	<titleref xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">Uniform Resource Identifiers (URI): Generic Syntax</titleref>, T. Berners-Lee,
	R. Fielding, L. Masinter, Authors. Internet Engineering Task Force, August 1998. Available at
	http://www.ietf.org/rfc/rfc2396.txt.
      </bibl>      
      <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="RFC2616" key="IETF RFC 2616" href="http://www.ietf.org/rfc/rfc2616.txt" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
	<titleref xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">Hypertext Transfer Protocol -- HTTP/1.1</titleref>,
	R. Fielding, et al., Authors. Internet Engineering Task Force,
	June 1999. Available at http://www.ietf.org/rfc/rfc2616.txt.
      </bibl>
      <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="RFC3023" key="IETF RFC 3023" href="http://www.ietf.org/rfc/rfc3023.txt" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
	<titleref xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">XML Media Types</titleref>, M. Murata, S. St.Laurent,
	and D. Kohn, Editors. Internet Engineering Task Force, January
	2001. Available at http://www.ietf.org/rfc/rfc3023.txt.
      </bibl>
      <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="SAX" key="SAX" href="http://www.saxproject.org/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
        <titleref xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">Simple API for XML</titleref>, D. Megginson and
        D. Brownell, Maintainers. Available at
        http://www.saxproject.org/.
      </bibl>
      <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="SVG1" key="SVG 1.1" href="http://www.w3.org/TR/2003/REC-SVG11-20030114/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
	<titleref xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">Scalable Vector Graphics (SVG) 1.1
	Specification</titleref>, J. Ferraiolo, &#34276;&#27810;
	&#28147; (FUJISAWA Jun), and D. Jackson, Editors. World Wide Web
	Consortium, 14 January 2003. This version of the SVG 1.1
	Recommendation is http://www.w3.org/TR/2003/REC-SVG11-20030114/. The <loc href="http://www.w3.org/TR/SVG" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">latest version of SVG 1.1</loc>
	is available at http://www.w3.org/TR/SVG.
      </bibl>
      <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="Unicode" key="Unicode" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
	<titleref xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">The Unicode Standard, Version 4</titleref>, ISBN
	0-321-18578-1, as updated from time to time by the publication
	of new versions. The Unicode Consortium, 2000. See also <loc href="http://www.unicode.org/unicode/standard/versions" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Versions
	of the Unicode Standard</loc>, available at
	http://www.unicode.org/unicode/standard/versions, for latest
	version and additional information on versions of the standard
	and of the Unicode Character Database.
      </bibl>
      <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="UnicodeNormalization" key="UTR #15" href="http://www.unicode.org/unicode/reports/tr15/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
	<titleref xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">Unicode Normalization Forms</titleref>, The Unicode
	Standard Annex #15. The Unicode Consortium, 2003. The latest
	version of this annex is available at
	http://www.unicode.org/unicode/reports/tr15/.
      </bibl>
      <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="VoiceXML20" key="VoiceXML 2.0" href="http://www.w3.org/TR/2004/REC-voicexml20-20040316" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
        <titleref xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">Voice Extensible Markup Language (VoiceXML) Version
        2.0</titleref>, S. McGlashan, et al., Editors. World Wide Web
        Consortium, 16 March 2004. This version of the Voice Extensible
        Markup Language Version 2.0 Recommendation is
        http://www.w3.org/TR/2004/REC-voicexml20-20040316. The <loc href="http://www.w3.org/TR/voicexml20/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">latest version of Voice
        Extensible Markup Language Version 2.0</loc> is available at
        http://www.w3.org/TR/voicexml20/.
      </bibl>
      <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="XForms10" key="XForms 1.0" href="http://www.w3.org/TR/2003/REC-xforms-20031014/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
        <titleref xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">XForms 1.0</titleref>, M. Dubinko, et al.,
        Editors. World Wide Web Consortium, 14 October 2003. This
        version of the XForms 1.0 Recommendation is http://www.w3.org/TR/2003/REC-xforms-20031014/. The <loc href="http://www.w3.org/TR/xforms/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">latest version of XForms
        1.0</loc> is available at http://www.w3.org/TR/xforms/.
      </bibl>
      <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="XHTML10" key="XHTML 1.0" href="http://www.w3.org/TR/2002/REC-xhtml1-20020801" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
        <titleref xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">XHTML 1.0: The Extensible HyperText Markup
        Language</titleref>, S. Pemberton, et al., Authors. World Wide
        Web Consortium, 26 January 2000, revised 1 August 2002. This
        version of the XHTML 1.0 Recommendation is http://www.w3.org/TR/2002/REC-xhtml1-20020801. The <loc href="http://www.w3.org/TR/xhtml1" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">latest version of XHTML
        1.0</loc> is available at http://www.w3.org/TR/xhtml1.
      </bibl>
<!--
      <bibl id='XHTML11' key='XHTML 1.1'>
	W3C (World Wide Web Consortium) <loc href='&xhtml11;'>XHTML 1.1 -
	  Module-base XHTML</loc>, May 2001. Available at &xhtml11;
      </bibl>
-->
      <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="XPath20DataModel" key="XQuery 1.0 and XPath 2.0 Data Model" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
	W3C (World Wide Web Consortium) <loc href="http://www.w3.org/TR/query-datamodel/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">XQuery
	1.0 and XML Path 2.0 Data Model</loc>, November 2003. Available at
	http://www.w3.org/TR/query-datamodel
      </bibl>
      <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="XML" key="XML 1.0" href="http://www.w3.org/TR/2004/REC-xml-20040204" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
	<titleref xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">Extensible Markup Language (XML) 1.0 (Third
	Edition)</titleref>, T. Bray, J. Paoli, C. M. Sperberg-McQueen,
	E. Maler, and F. Yergeau, Editors. World Wide Web Consortium, 4
	February 2004, revised 10 February 1998 and 6 October 2000. This
	version of the XML 1.0 Recommendation is http://www.w3.org/TR/2004/REC-xml-20040204. The <loc href="http://www.w3.org/TR/REC-xml" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">latest version of XML
	1.0</loc> is available at http://www.w3.org/TR/REC-xml.
      </bibl>
      <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="XML11" key="XML 1.1" href="http://www.w3.org/TR/2004/REC-xml11-20040204/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
	<titleref xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">XML 1.1</titleref>, T. Bray, and al., Editors. World
	Wide Web Consortium, 4 February 2004. This version of the XML 1.1
	Recommendation is http://www.w3.org/TR/2004/REC-xml11-20040204. The <loc href="http://www.w3.org/TR/xml11/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">latest version of XML
	1.1</loc> is available at http://www.w3.org/TR/xml11.
      </bibl>
      <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="XMLBase" key="XML Base" href="http://www.w3.org/TR/2001/REC-xmlbase-20010627/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
	<titleref xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">XML Base</titleref>, J. Marsh, Editor. World
	Wide Web Consortium, June 2001.  This version of the XML Base
	Recommendation is http://www.w3.org/TR/2001/REC-xmlbase-20010627. The <loc href="http://www.w3.org/TR/xmlbase/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">latest version of XML
	Base</loc> is available at http://www.w3.org/TR/xmlbase.
      </bibl>
      <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="InfoSet" key="XML Information Set" href="http://www.w3.org/TR/2004/REC-xml-infoset-20040204/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
        <titleref xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">XML Information Set (Second Edition)</titleref>,
        J. Cowan and R. Tobin, Editors. World Wide Web Consortium, 4
        February 2004, revised 24 October 2001.  This version of the XML
        Information Set Recommendation is http://www.w3.org/TR/2004/REC-xml-infoset-20040204. The <loc href="http://www.w3.org/TR/xml-infoset/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">latest version of XML
        Information Set</loc> is available at
        http://www.w3.org/TR/xml-infoset.
      </bibl>
      <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="XMLEvents" key="XML Events" href="http://www.w3.org/TR/2003/PR-xml-events-20030804/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
	<titleref xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">XML Events</titleref>, S. McCarron, S. Pemberton,
	and T.V. Raman, Editors. World Wide Web Consortium, August
	2003. This version of the XML Events specification is
	http://www.w3.org/TR/2003/PR-xml-events-20030804. The <loc href="http://www.w3.org/TR/xml-events/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">latest version of XML
	Events</loc> is available at http://www.w3.org/TR/xml-events.
      </bibl>
      <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="Namespaces" key="XML Namespaces" href="http://www.w3.org/TR/1999/REC-xml-names-19990114/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
	<titleref xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">Namespaces in XML</titleref>, T. Bray, D.  Hollander,
	and A. Layman, Editors. World Wide Web Consortium, 14 January
	1999. This version of the Namespaces in XML Recommendation is
	http://www.w3.org/TR/1999/REC-xml-names-19990114. The <loc href="http://www.w3.org/TR/REC-xml-names/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">latest version of
	Namespaces in XML</loc> is available at
	http://www.w3.org/TR/REC-xml-names.
      </bibl>
      <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="Namespaces11" key="XML Namespaces 1.1" href="http://www.w3.org/TR/2004/REC-xml-names11-20040204/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
	<titleref xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">Namespaces in XML 1.1</titleref>, T. Bray, D.
	Hollander, A. Layman, and R. Tobin, Editors. World Wide Web
	Consortium, 4 February 2004. This version of the Namespaces in
	XML 1.1 Recommendation is
	http://www.w3.org/TR/2004/REC-xml-names11-20040204. The <loc href="http://www.w3.org/TR/xml-names11/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">latest version of
	Namespaces in XML 1.1</loc> is available at
	http://www.w3.org/TR/xml-names11/.
      </bibl>
      <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="XMLSchema0" key="XML Schema Part 0" href="http://www.w3.org/TR/2001/REC-xmlschema-0-20010502/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
	<titleref xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">XML Schema Part 0: Primer</titleref>, D. Fallside,
	Editor. World Wide Web Consortium, 2 May 2001.  This version of
	the XML Part 0 Recommendation is http://www.w3.org/TR/2001/REC-xmlschema-0-20010502. The
	<loc href="http://www.w3.org/TR/xmlschema-0/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">latest version of
	XML Schema Part 0</loc> is available at
	http://www.w3.org/TR/xmlschema-0.
      </bibl>
      <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="XMLSchema1" key="XML Schema Part 1" href="http://www.w3.org/TR/2001/REC-xmlschema-1-20010502/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
	<titleref xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">XML Schema Part 1: Structures</titleref>, H. Thompson,
	D. Beech, M. Maloney, and N. Mendelsohn, Editors. World Wide Web
	Consortium, 2 May 2001. This version of the XML Part 1
	Recommendation is http://www.w3.org/TR/2001/REC-xmlschema-1-20010502. The <loc href="http://www.w3.org/TR/xmlschema-1/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">latest version of XML
	Schema Part 1</loc> is available at
	http://www.w3.org/TR/xmlschema-1.
      </bibl>
      <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="XMLSchema2" key="XML Schema Part 2" href="http://www.w3.org/TR/2001/REC-xmlschema-2-20010502/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
	<titleref xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">XML Schema Part 2: Datatypes</titleref>, P. Byron and
	Ashok Malhotra, Editors. World Wide Web Consortium, 2 May 2001.
	This version of the XML Part 2 Recommendation is
	http://www.w3.org/TR/2001/REC-xmlschema-2-20010502. The <loc href="http://www.w3.org/TR/xmlschema-2/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">latest version of XML
	Schema Part 2</loc> is available at
	http://www.w3.org/TR/xmlschema-2.
      </bibl>
      <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="XML-StyleSheet" key="XML StyleSheet" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
	W3C (World Wide Web Consortium) <loc href="http://www.w3.org/1999/06/REC-xml-stylesheet-19990629" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Associating Style Sheets with XML
	documents Version 1.0</loc>, June 1999. Available at
	http://www.w3.org/1999/06/REC-xml-stylesheet-19990629
      </bibl>
      <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="XPath10" href="http://www.w3.org/TR/1999/REC-xpath-19991116" key="XPath 1.0" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
	<titleref xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">XML Path Language (XPath) Version 1.0</titleref>,
	J. Clark and S. DeRose, Editors. World Wide Web
	Consortium, 16 November 1999. This version of the XPath 1.0
	Recommendation is http://www.w3.org/TR/1999/REC-xpath-19991116. The <loc href="http://www.w3.org/TR/xpath" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">latest version of XPath
	1.0</loc> is available at http://www.w3.org/TR/xpath.
      </bibl>
      <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="XPointer" key="XPointer" href="http://www.w3.org/TR/2003/REC-xptr-framework-20030325/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
	<titleref xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">XPointer Framework</titleref>, P. Grosso, E. Maler,
	J. Marsh, and N. Walsh., Editors. World Wide Web Consortium,
	25 March 2003.  This version of the XPointer Framework
	Recommendation is http://www.w3.org/TR/2003/REC-xptr-framework-20030325/. The <loc href="http://www.w3.org/TR/xptr-framework/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">latest version of
	XPointer Framework</loc> is available at
	http://www.w3.org/TR/xptr-framework/.
      </bibl>
    </blist>

</div1>
<!--
 *************************************************************************
 * END OF REFERENCES                                                     *
 *************************************************************************
-->

  
<!-- $Id: index.xml,v 1.1 2000/01/13 18:55:20 lwood Rel $ -->
<!--
 *************************************************************************
 * BEGINNING OF DOM INDEX                                                * 
 *************************************************************************
-->
<div1 role="index" id="Index">
  <head>Index</head>
  <?GENERATE-DEFINITION-INDEX?>
</div1>
<!--
 *************************************************************************
 * END OF DOM INDEX                                                      *
 *************************************************************************
-->
 
</back> </spec>